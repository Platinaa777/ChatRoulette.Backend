{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar MediaSignaling = require('./mediasignaling');\nvar TrackPrioritySignaling = /** @class */function (_super) {\n  __extends(TrackPrioritySignaling, _super);\n  /**\n   * Construct a {@link TrackPrioritySignaling}.\n   * @param {Promise<DataTrackReceiver>} getReceiver\n   */\n  function TrackPrioritySignaling(getReceiver, options) {\n    var _this = _super.call(this, getReceiver, 'track_priority', options) || this;\n    Object.defineProperties(_this, {\n      _enqueuedPriorityUpdates: {\n        value: new Map()\n      }\n    });\n    _this.on('ready', function (transport) {\n      Array.from(_this._enqueuedPriorityUpdates.keys()).forEach(function (trackSid) {\n        transport.publish({\n          type: 'track_priority',\n          track: trackSid,\n          subscribe: _this._enqueuedPriorityUpdates.get(trackSid)\n        });\n        // NOTE(mpatwardhan)- we do not clear _enqueuedPriorityUpdates intentionally,\n        // this cache will is used to re-send the priorities in case of VMS-FailOver.\n      });\n    });\n\n    return _this;\n  }\n  /**\n   * @param {Track.SID} trackSid\n   * @param {'publish'|'subscribe'} publishOrSubscribe\n   * @param {Track.Priority} priority\n   */\n  TrackPrioritySignaling.prototype.sendTrackPriorityUpdate = function (trackSid, publishOrSubscribe, priority) {\n    if (publishOrSubscribe !== 'subscribe') {\n      throw new Error('only subscribe priorities are supported, found: ' + publishOrSubscribe);\n    }\n    this._enqueuedPriorityUpdates.set(trackSid, priority);\n    if (this._transport) {\n      this._transport.publish({\n        type: 'track_priority',\n        track: trackSid,\n        subscribe: priority\n      });\n    }\n  };\n  return TrackPrioritySignaling;\n}(MediaSignaling);\nmodule.exports = TrackPrioritySignaling;","map":{"version":3,"names":["MediaSignaling","require","TrackPrioritySignaling","_super","__extends","getReceiver","options","_this","call","Object","defineProperties","_enqueuedPriorityUpdates","value","Map","on","transport","Array","from","keys","forEach","trackSid","publish","type","track","subscribe","get","prototype","sendTrackPriorityUpdate","publishOrSubscribe","priority","Error","set","_transport","module","exports"],"sources":["/home/denis/RiderProjects/ChatRoulette/WebUI/chat-app/node_modules/twilio-video/lib/signaling/v2/trackprioritysignaling.js"],"sourcesContent":["'use strict';\n\nconst MediaSignaling = require('./mediasignaling');\nclass TrackPrioritySignaling extends MediaSignaling {\n  /**\n   * Construct a {@link TrackPrioritySignaling}.\n   * @param {Promise<DataTrackReceiver>} getReceiver\n   */\n  constructor(getReceiver, options) {\n    super(getReceiver, 'track_priority', options);\n\n    Object.defineProperties(this, {\n      _enqueuedPriorityUpdates: {\n        value: new Map()\n      },\n    });\n\n    this.on('ready', transport => {\n      Array.from(this._enqueuedPriorityUpdates.keys()).forEach(trackSid => {\n        transport.publish({\n          type: 'track_priority',\n          track: trackSid,\n          subscribe: this._enqueuedPriorityUpdates.get(trackSid)\n        });\n        // NOTE(mpatwardhan)- we do not clear _enqueuedPriorityUpdates intentionally,\n        // this cache will is used to re-send the priorities in case of VMS-FailOver.\n      });\n    });\n  }\n\n  /**\n   * @param {Track.SID} trackSid\n   * @param {'publish'|'subscribe'} publishOrSubscribe\n   * @param {Track.Priority} priority\n   */\n  sendTrackPriorityUpdate(trackSid, publishOrSubscribe, priority) {\n    if (publishOrSubscribe !== 'subscribe') {\n      throw new Error('only subscribe priorities are supported, found: ' + publishOrSubscribe);\n    }\n    this._enqueuedPriorityUpdates.set(trackSid, priority);\n    if (this._transport) {\n      this._transport.publish({\n        type: 'track_priority',\n        track: trackSid,\n        subscribe: priority\n      });\n    }\n  }\n}\n\nmodule.exports = TrackPrioritySignaling;\n"],"mappings":"AAAA,YAAY;;;;;;;;;;;;;;;;;;;;;;AAEZ,IAAMA,cAAc,GAAGC,OAAO,CAAC,kBAAkB,CAAC;AAClD,IAAAC,sBAAA,0BAAAC,MAAA;EAAqCC,SAAA,CAAAF,sBAAA,EAAAC,MAAA;EACnC;;;;EAIA,SAAAD,uBAAYG,WAAW,EAAEC,OAAO;IAAhC,IAAAC,KAAA,GACEJ,MAAA,CAAAK,IAAA,OAAMH,WAAW,EAAE,gBAAgB,EAAEC,OAAO,CAAC;IAE7CG,MAAM,CAACC,gBAAgB,CAACH,KAAI,EAAE;MAC5BI,wBAAwB,EAAE;QACxBC,KAAK,EAAE,IAAIC,GAAG;;KAEjB,CAAC;IAEFN,KAAI,CAACO,EAAE,CAAC,OAAO,EAAE,UAAAC,SAAS;MACxBC,KAAK,CAACC,IAAI,CAACV,KAAI,CAACI,wBAAwB,CAACO,IAAI,EAAE,CAAC,CAACC,OAAO,CAAC,UAAAC,QAAQ;QAC/DL,SAAS,CAACM,OAAO,CAAC;UAChBC,IAAI,EAAE,gBAAgB;UACtBC,KAAK,EAAEH,QAAQ;UACfI,SAAS,EAAEjB,KAAI,CAACI,wBAAwB,CAACc,GAAG,CAACL,QAAQ;SACtD,CAAC;QACF;QACA;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;;;EACJ;EAEA;;;;;EAKAlB,sBAAA,CAAAwB,SAAA,CAAAC,uBAAuB,GAAvB,UAAwBP,QAAQ,EAAEQ,kBAAkB,EAAEC,QAAQ;IAC5D,IAAID,kBAAkB,KAAK,WAAW,EAAE;MACtC,MAAM,IAAIE,KAAK,CAAC,kDAAkD,GAAGF,kBAAkB,CAAC;;IAE1F,IAAI,CAACjB,wBAAwB,CAACoB,GAAG,CAACX,QAAQ,EAAES,QAAQ,CAAC;IACrD,IAAI,IAAI,CAACG,UAAU,EAAE;MACnB,IAAI,CAACA,UAAU,CAACX,OAAO,CAAC;QACtBC,IAAI,EAAE,gBAAgB;QACtBC,KAAK,EAAEH,QAAQ;QACfI,SAAS,EAAEK;OACZ,CAAC;;EAEN,CAAC;EACH,OAAA3B,sBAAC;AAAD,CAAC,CA7CoCF,cAAc;AA+CnDiC,MAAM,CAACC,OAAO,GAAGhC,sBAAsB"},"metadata":{},"sourceType":"script","externalDependencies":[]}