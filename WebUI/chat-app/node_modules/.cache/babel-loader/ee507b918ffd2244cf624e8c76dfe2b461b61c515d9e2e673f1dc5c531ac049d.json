{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar mixinRemoteMediaTrack = require('./remotemediatrack');\nvar VideoTrack = require('./videotrack');\nvar documentVisibilityMonitor = require('../../util/documentvisibilitymonitor.js');\nvar NullObserver = require('../../util/nullobserver.js').NullObserver;\nvar Timeout = require('../../util/timeout');\nvar RemoteMediaVideoTrack = mixinRemoteMediaTrack(VideoTrack);\nvar TRACK_TURN_OF_DELAY_MS = 50;\n/**\n * A {@link RemoteVideoTrack} represents a {@link VideoTrack} published to a\n * {@link Room} by a {@link RemoteParticipant}.\n * @extends VideoTrack\n * @property {boolean} isEnabled - Whether the {@link RemoteVideoTrack} is enabled\n * @property {boolean} isSwitchedOff - Whether the {@link RemoteVideoTrack} is switched off\n * @property {Track.SID} sid - The {@link RemoteVideoTrack}'s SID\n * @property {?Track.Priority} priority - The subscribe priority of the {@link RemoteVideoTrack}\n * @emits RemoteVideoTrack#dimensionsChanged\n * @emits RemoteVideoTrack#disabled\n * @emits RemoteVideoTrack#enabled\n * @emits RemoteVideoTrack#started\n * @emits RemoteVideoTrack#switchedOff\n * @emits RemoteVideoTrack#switchedOn\n */\nvar RemoteVideoTrack = /** @class */function (_super) {\n  __extends(RemoteVideoTrack, _super);\n  /**\n   * Construct a {@link RemoteVideoTrack}.\n   * @param {Track.SID} sid - The {@link RemoteVideoTrack}'s SID\n   * @param {MediaTrackReceiver} mediaTrackReceiver - A video MediaStreamTrack container\n   * @param {boolean} isEnabled - whether the {@link RemoteVideoTrack} is enabled\n   * @param {boolean} isSwitchedOff - Whether the {@link RemoteVideoTrack} is switched off\n   * @param {function(?Track.Priority): void} setPriority - Set or clear the subscribe\n   *  {@link Track.Priority} of the {@link RemoteVideoTrack}\n   * @param {function(ClientRenderHint): void} setRenderHint - Set render hints.\n   * @param {{log: Log}} options - The {@link RemoteTrack} options\n   */\n  function RemoteVideoTrack(sid, mediaTrackReceiver, isEnabled, isSwitchedOff, setPriority, setRenderHint, options) {\n    var _this = this;\n    options = Object.assign({\n      clientTrackSwitchOffControl: 'auto',\n      contentPreferencesMode: 'auto',\n      enableDocumentVisibilityTurnOff: true\n    }, options);\n    options = Object.assign({\n      IntersectionObserver: typeof IntersectionObserver === 'undefined' || options.clientTrackSwitchOffControl !== 'auto' ? NullObserver : IntersectionObserver,\n      ResizeObserver: typeof ResizeObserver === 'undefined' || options.contentPreferencesMode !== 'auto' ? NullObserver : ResizeObserver\n    }, options);\n    _this = _super.call(this, sid, mediaTrackReceiver, isEnabled, isSwitchedOff, setPriority, setRenderHint, options) || this;\n    Object.defineProperties(_this, {\n      _enableDocumentVisibilityTurnOff: {\n        value: options.enableDocumentVisibilityTurnOff === true && options.clientTrackSwitchOffControl === 'auto'\n      },\n      _documentVisibilityTurnOffCleanup: {\n        value: null,\n        writable: true\n      },\n      _clientTrackSwitchOffControl: {\n        value: options.clientTrackSwitchOffControl\n      },\n      _contentPreferencesMode: {\n        value: options.contentPreferencesMode\n      },\n      _invisibleElements: {\n        value: new WeakSet()\n      },\n      _elToPipCallbacks: {\n        value: new WeakMap()\n      },\n      _elToPipWindows: {\n        value: new WeakMap()\n      },\n      _turnOffTimer: {\n        value: new Timeout(function () {\n          _this._setRenderHint({\n            enabled: false\n          });\n        }, TRACK_TURN_OF_DELAY_MS, false)\n      },\n      _resizeObserver: {\n        value: new options.ResizeObserver(function (entries) {\n          // NOTE(mpatwardhan): we ignore elements in _invisibleElements\n          // to ensure that ResizeObserver does not end-up turning off a track when a fresh Video element is\n          // attached and IntersectionObserver has not had its callback executed yet.\n          var visibleElementResized = entries.find(function (entry) {\n            return !_this._invisibleElements.has(entry.target);\n          });\n          if (visibleElementResized) {\n            maybeUpdateDimensionHint(_this);\n          }\n        })\n      },\n      _intersectionObserver: {\n        value: new options.IntersectionObserver(function (entries) {\n          var shouldSetRenderHint = false;\n          entries.forEach(function (entry) {\n            var wasVisible = !_this._invisibleElements.has(entry.target);\n            if (wasVisible !== entry.isIntersecting) {\n              if (entry.isIntersecting) {\n                _this._log.debug('intersectionObserver detected: Off => On');\n                _this._invisibleElements.delete(entry.target);\n              } else {\n                _this._log.debug('intersectionObserver detected: On => Off');\n                _this._invisibleElements.add(entry.target);\n              }\n              shouldSetRenderHint = true;\n            }\n          });\n          if (shouldSetRenderHint) {\n            maybeUpdateEnabledHint(_this);\n            // when visibility of an element changes that may cause the \"biggest\" element to change,\n            // update dimensions as well. since dimensions are cached and de-duped at signaling layer,\n            // its okay if they got  resent.\n            maybeUpdateDimensionHint(_this);\n          }\n        }, {\n          threshold: 0.25\n        })\n      }\n    });\n    return _this;\n  }\n  /**\n   * @private\n   */\n  RemoteVideoTrack.prototype._start = function (dummyEl) {\n    var result = _super.prototype._start.call(this, dummyEl);\n    // NOTE(mpatwardhan): after emitting started, update turn off track if not visible.\n    maybeUpdateEnabledHint(this);\n    return result;\n  };\n  /**\n   * Request to switch on a {@link RemoteVideoTrack}, This method is applicable only for the group rooms and only when connected with\n   * clientTrackSwitchOffControl in video bandwidth profile options set to 'manual'\n   * @returns {this}\n   */\n  RemoteVideoTrack.prototype.switchOn = function () {\n    if (this._clientTrackSwitchOffControl !== 'manual') {\n      throw new Error('Invalid state. You can call switchOn only when bandwidthProfile.video.clientTrackSwitchOffControl is set to \"manual\"');\n    }\n    this._setRenderHint({\n      enabled: true\n    });\n    return this;\n  };\n  /**\n   * Request to switch off a {@link RemoteVideoTrack}, This method is applicable only for the group rooms and only when connected with\n   * clientTrackSwitchOffControl in video bandwidth profile options set to 'manual'\n   * @returns {this}\n   */\n  RemoteVideoTrack.prototype.switchOff = function () {\n    if (this._clientTrackSwitchOffControl !== 'manual') {\n      throw new Error('Invalid state. You can call switchOff only when bandwidthProfile.video.clientTrackSwitchOffControl is set to \"manual\"');\n    }\n    this._setRenderHint({\n      enabled: false\n    });\n    return this;\n  };\n  /**\n   * Set the {@link RemoteVideoTrack}'s content preferences. This method is applicable only for the group rooms and only when connected with\n   * videoContentPreferencesMode in video bandwidth profile options set to 'manual'\n   * @param {VideoContentPreferences} contentPreferences - requested preferences.\n   * @returns {this}\n   */\n  RemoteVideoTrack.prototype.setContentPreferences = function (contentPreferences) {\n    if (this._contentPreferencesMode !== 'manual') {\n      throw new Error('Invalid state. You can call switchOn only when bandwidthProfile.video.contentPreferencesMode is set to \"manual\"');\n    }\n    if (contentPreferences.renderDimensions) {\n      this._setRenderHint({\n        renderDimensions: contentPreferences.renderDimensions\n      });\n    }\n    return this;\n  };\n  RemoteVideoTrack.prototype._unObservePip = function (el) {\n    var pipCallbacks = this._elToPipCallbacks.get(el);\n    if (pipCallbacks) {\n      el.removeEventListener('enterpictureinpicture', pipCallbacks.onEnterPip);\n      el.removeEventListener('leavepictureinpicture', pipCallbacks.onLeavePip);\n      this._elToPipCallbacks.delete(el);\n    }\n  };\n  RemoteVideoTrack.prototype._observePip = function (el) {\n    var _this = this;\n    var pipCallbacks = this._elToPipCallbacks.get(el);\n    if (!pipCallbacks) {\n      var onEnterPip = function (event) {\n        return _this._onEnterPip(event, el);\n      };\n      var onLeavePip = function (event) {\n        return _this._onLeavePip(event, el);\n      };\n      var onResizePip = function (event) {\n        return _this._onResizePip(event, el);\n      };\n      el.addEventListener('enterpictureinpicture', onEnterPip);\n      el.addEventListener('leavepictureinpicture', onLeavePip);\n      this._elToPipCallbacks.set(el, {\n        onEnterPip: onEnterPip,\n        onLeavePip: onLeavePip,\n        onResizePip: onResizePip\n      });\n    }\n  };\n  RemoteVideoTrack.prototype._onEnterPip = function (event, videoEl) {\n    this._log.debug('onEnterPip');\n    var pipWindow = event.pictureInPictureWindow;\n    this._elToPipWindows.set(videoEl, pipWindow);\n    var onResizePip = this._elToPipCallbacks.get(videoEl).onResizePip;\n    pipWindow.addEventListener('resize', onResizePip);\n    maybeUpdateEnabledHint(this);\n  };\n  RemoteVideoTrack.prototype._onLeavePip = function (event, videoEl) {\n    this._log.debug('onLeavePip');\n    this._elToPipWindows.delete(videoEl);\n    var onResizePip = this._elToPipCallbacks.get(videoEl).onResizePip;\n    var pipWindow = event.pictureInPictureWindow;\n    pipWindow.removeEventListener('resize', onResizePip);\n    maybeUpdateEnabledHint(this);\n  };\n  RemoteVideoTrack.prototype._onResizePip = function () {\n    maybeUpdateDimensionHint(this);\n  };\n  RemoteVideoTrack.prototype.attach = function (el) {\n    var result = _super.prototype.attach.call(this, el);\n    if (this._clientTrackSwitchOffControl === 'auto') {\n      // start off the element as invisible. will mark it\n      // visible (and update render hints) once intersection observer calls back.\n      this._invisibleElements.add(result);\n    }\n    this._intersectionObserver.observe(result);\n    this._resizeObserver.observe(result);\n    if (this._enableDocumentVisibilityTurnOff) {\n      this._documentVisibilityTurnOffCleanup = this._documentVisibilityTurnOffCleanup || setupDocumentVisibilityTurnOff(this);\n    }\n    this._observePip(result);\n    return result;\n  };\n  RemoteVideoTrack.prototype.detach = function (el) {\n    var _this = this;\n    var result = _super.prototype.detach.call(this, el);\n    var elements = Array.isArray(result) ? result : [result];\n    elements.forEach(function (element) {\n      _this._intersectionObserver.unobserve(element);\n      _this._resizeObserver.unobserve(element);\n      _this._invisibleElements.delete(element);\n      _this._unObservePip(element);\n    });\n    if (this._attachments.size === 0) {\n      if (this._documentVisibilityTurnOffCleanup) {\n        this._documentVisibilityTurnOffCleanup();\n        this._documentVisibilityTurnOffCleanup = null;\n      }\n    }\n    maybeUpdateEnabledHint(this);\n    maybeUpdateDimensionHint(this);\n    return result;\n  };\n  /**\n   * Add a {@link VideoProcessor} to allow for custom processing of video frames belonging to a VideoTrack.\n   * When a Participant un-publishes and re-publishes a VideoTrack, a new RemoteVideoTrack is created and\n   * any VideoProcessors attached to the previous RemoteVideoTrack would have to be re-added again.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to use.\n   * @param {AddProcessorOptions} [options] - {@link AddProcessorOptions} to provide.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * const grayscaleProcessor = new GrayScaleProcessor(100);\n   *\n   * Array.from(room.participants.values()).forEach(participant => {\n   *   const remoteVideoTrack = Array.from(participant.videoTracks.values())[0].track;\n   *   remoteVideoTrack.addProcessor(grayscaleProcessor);\n   * });\n   */\n  RemoteVideoTrack.prototype.addProcessor = function () {\n    return _super.prototype.addProcessor.apply(this, arguments);\n  };\n  /**\n   * Remove the previously added {@link VideoProcessor} using `addProcessor` API.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to remove.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * const grayscaleProcessor = new GrayScaleProcessor(100);\n   *\n   * Array.from(room.participants.values()).forEach(participant => {\n   *   const remoteVideoTrack = Array.from(participant.videoTracks.values())[0].track;\n   *   remoteVideoTrack.addProcessor(grayscaleProcessor);\n   * });\n   *\n   * document.getElementById('remove-button').onclick = () => {\n   *   Array.from(room.participants.values()).forEach(participant => {\n   *     const remoteVideoTrack = Array.from(participant.videoTracks.values())[0].track;\n   *     remoteVideoTrack.removeProcessor(grayscaleProcessor);\n   *   });\n   * }\n   */\n  RemoteVideoTrack.prototype.removeProcessor = function () {\n    return _super.prototype.removeProcessor.apply(this, arguments);\n  };\n  RemoteVideoTrack.prototype.toString = function () {\n    return \"[RemoteVideoTrack #\" + this._instanceId + \": \" + this.sid + \"]\";\n  };\n  /**\n   * Update the subscribe {@link Track.Priority} of the {@link RemoteVideoTrack}.\n   * @param {?Track.Priority} priority - the new subscribe {@link Track.Priority};\n   *   If <code>null</code>, then the subscribe {@link Track.Priority} is cleared, which\n   *   means the {@link Track.Priority} set by the publisher is now the effective priority.\n   * @returns {this}\n   * @throws {RangeError}\n   */\n  RemoteVideoTrack.prototype.setPriority = function (priority) {\n    return _super.prototype.setPriority.call(this, priority);\n  };\n  return RemoteVideoTrack;\n}(RemoteMediaVideoTrack);\nfunction setupDocumentVisibilityTurnOff(removeVideoTrack) {\n  function onVisibilityChanged() {\n    maybeUpdateEnabledHint(removeVideoTrack);\n  }\n  documentVisibilityMonitor.onVisibilityChange(1, onVisibilityChanged);\n  return function () {\n    documentVisibilityMonitor.offVisibilityChange(1, onVisibilityChanged);\n  };\n}\nfunction maybeUpdateEnabledHint(remoteVideoTrack) {\n  if (remoteVideoTrack._clientTrackSwitchOffControl !== 'auto') {\n    return;\n  }\n  var visibleElements = remoteVideoTrack._getAllAttachedElements().filter(function (el) {\n    return !remoteVideoTrack._invisibleElements.has(el);\n  });\n  var pipWindows = remoteVideoTrack._getAllAttachedElements().filter(function (el) {\n    return remoteVideoTrack._elToPipWindows.has(el);\n  });\n  // even when document is invisible we may have track playing in pip window.\n  var enabled = pipWindows.length > 0 || document.visibilityState === 'visible' && visibleElements.length > 0;\n  if (enabled === true) {\n    remoteVideoTrack._turnOffTimer.clear();\n    remoteVideoTrack._setRenderHint({\n      enabled: true\n    });\n  } else if (!remoteVideoTrack._turnOffTimer.isSet) {\n    // set the track to be turned off after some delay.\n    remoteVideoTrack._turnOffTimer.start();\n  }\n}\nfunction maybeUpdateDimensionHint(remoteVideoTrack) {\n  if (remoteVideoTrack._contentPreferencesMode !== 'auto') {\n    return;\n  }\n  var visibleElements = remoteVideoTrack._getAllAttachedElements().filter(function (el) {\n    return !remoteVideoTrack._invisibleElements.has(el);\n  });\n  var pipElements = remoteVideoTrack._getAllAttachedElements().map(function (el) {\n    var pipWindow = remoteVideoTrack._elToPipWindows.get(el);\n    return pipWindow ? {\n      clientHeight: pipWindow.height,\n      clientWidth: pipWindow.width\n    } : {\n      clientHeight: 0,\n      clientWidth: 0\n    };\n  });\n  var totalElements = visibleElements.concat(pipElements);\n  if (totalElements.length > 0) {\n    var _a = __read(totalElements.sort(function (el1, el2) {\n        return el2.clientHeight + el2.clientWidth - el1.clientHeight - el1.clientWidth - 1;\n      }), 1),\n      _b = _a[0],\n      clientHeight = _b.clientHeight,\n      clientWidth = _b.clientWidth;\n    var renderDimensions = {\n      height: clientHeight,\n      width: clientWidth\n    };\n    remoteVideoTrack._setRenderHint({\n      renderDimensions: renderDimensions\n    });\n  }\n}\n/**\n * @typedef {object} VideoContentPreferences\n * @property {VideoTrack.Dimensions} [renderDimensions] - Render Dimensions to request for the {@link RemoteVideoTrack}.\n */\n/**\n * The {@link RemoteVideoTrack}'s dimensions changed.\n * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} whose\n *   dimensions changed\n * @event RemoteVideoTrack#dimensionsChanged\n */\n/**\n * The {@link RemoteVideoTrack} was disabled, i.e. \"paused\".\n * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} that was\n *   disabled\n * @event RemoteVideoTrack#disabled\n */\n/**\n * The {@link RemoteVideoTrack} was enabled, i.e. \"resumed\".\n * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} that was\n *   enabled\n * @event RemoteVideoTrack#enabled\n */\n/**\n * The {@link RemoteVideoTrack} started. This means there is enough video data\n * to begin playback.\n * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} that started\n * @event RemoteVideoTrack#started\n */\n/**\n * A {@link RemoteVideoTrack} was switched off.\n * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} that was\n *   switched off\n * @event RemoteVideoTrack#switchedOff\n */\n/**\n * A {@link RemoteVideoTrack} was switched on.\n * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} that was\n *   switched on\n * @event RemoteVideoTrack#switchedOn\n */\nmodule.exports = RemoteVideoTrack;","map":{"version":3,"names":["mixinRemoteMediaTrack","require","VideoTrack","documentVisibilityMonitor","NullObserver","Timeout","RemoteMediaVideoTrack","TRACK_TURN_OF_DELAY_MS","RemoteVideoTrack","_super","__extends","sid","mediaTrackReceiver","isEnabled","isSwitchedOff","setPriority","setRenderHint","options","_this","Object","assign","clientTrackSwitchOffControl","contentPreferencesMode","enableDocumentVisibilityTurnOff","IntersectionObserver","ResizeObserver","call","defineProperties","_enableDocumentVisibilityTurnOff","value","_documentVisibilityTurnOffCleanup","writable","_clientTrackSwitchOffControl","_contentPreferencesMode","_invisibleElements","WeakSet","_elToPipCallbacks","WeakMap","_elToPipWindows","_turnOffTimer","_setRenderHint","enabled","_resizeObserver","entries","visibleElementResized","find","entry","has","target","maybeUpdateDimensionHint","_intersectionObserver","shouldSetRenderHint","forEach","wasVisible","isIntersecting","_log","debug","delete","add","maybeUpdateEnabledHint","threshold","prototype","_start","dummyEl","result","switchOn","Error","switchOff","setContentPreferences","contentPreferences","renderDimensions","_unObservePip","el","pipCallbacks","get","removeEventListener","onEnterPip","onLeavePip","_observePip","event","_onEnterPip","_onLeavePip","onResizePip","_onResizePip","addEventListener","set","videoEl","pipWindow","pictureInPictureWindow","attach","observe","setupDocumentVisibilityTurnOff","detach","elements","Array","isArray","element","unobserve","_attachments","size","addProcessor","apply","arguments","removeProcessor","toString","_instanceId","priority","removeVideoTrack","onVisibilityChanged","onVisibilityChange","offVisibilityChange","remoteVideoTrack","visibleElements","_getAllAttachedElements","filter","pipWindows","length","document","visibilityState","clear","isSet","start","pipElements","map","clientHeight","height","clientWidth","width","totalElements","concat","_a","__read","sort","el1","el2","_b","module","exports"],"sources":["/home/denis/RiderProjects/ChatRoulette/WebUI/chat-app/node_modules/twilio-video/lib/media/track/remotevideotrack.js"],"sourcesContent":["'use strict';\n\nconst mixinRemoteMediaTrack = require('./remotemediatrack');\nconst VideoTrack = require('./videotrack');\nconst documentVisibilityMonitor = require('../../util/documentvisibilitymonitor.js');\nconst { NullObserver } = require('../../util/nullobserver.js');\nconst Timeout = require('../../util/timeout');\n\nconst RemoteMediaVideoTrack = mixinRemoteMediaTrack(VideoTrack);\nconst TRACK_TURN_OF_DELAY_MS = 50;\n\n/**\n * A {@link RemoteVideoTrack} represents a {@link VideoTrack} published to a\n * {@link Room} by a {@link RemoteParticipant}.\n * @extends VideoTrack\n * @property {boolean} isEnabled - Whether the {@link RemoteVideoTrack} is enabled\n * @property {boolean} isSwitchedOff - Whether the {@link RemoteVideoTrack} is switched off\n * @property {Track.SID} sid - The {@link RemoteVideoTrack}'s SID\n * @property {?Track.Priority} priority - The subscribe priority of the {@link RemoteVideoTrack}\n * @emits RemoteVideoTrack#dimensionsChanged\n * @emits RemoteVideoTrack#disabled\n * @emits RemoteVideoTrack#enabled\n * @emits RemoteVideoTrack#started\n * @emits RemoteVideoTrack#switchedOff\n * @emits RemoteVideoTrack#switchedOn\n */\nclass RemoteVideoTrack extends RemoteMediaVideoTrack {\n  /**\n   * Construct a {@link RemoteVideoTrack}.\n   * @param {Track.SID} sid - The {@link RemoteVideoTrack}'s SID\n   * @param {MediaTrackReceiver} mediaTrackReceiver - A video MediaStreamTrack container\n   * @param {boolean} isEnabled - whether the {@link RemoteVideoTrack} is enabled\n   * @param {boolean} isSwitchedOff - Whether the {@link RemoteVideoTrack} is switched off\n   * @param {function(?Track.Priority): void} setPriority - Set or clear the subscribe\n   *  {@link Track.Priority} of the {@link RemoteVideoTrack}\n   * @param {function(ClientRenderHint): void} setRenderHint - Set render hints.\n   * @param {{log: Log}} options - The {@link RemoteTrack} options\n   */\n  constructor(sid, mediaTrackReceiver, isEnabled, isSwitchedOff, setPriority, setRenderHint, options) {\n    options = Object.assign({\n      clientTrackSwitchOffControl: 'auto',\n      contentPreferencesMode: 'auto',\n      enableDocumentVisibilityTurnOff: true,\n    }, options);\n\n    options = Object.assign({\n      IntersectionObserver: typeof IntersectionObserver === 'undefined' || options.clientTrackSwitchOffControl !== 'auto'  ? NullObserver : IntersectionObserver,\n      ResizeObserver: typeof ResizeObserver === 'undefined' || options.contentPreferencesMode !== 'auto' ?  NullObserver : ResizeObserver,\n    }, options);\n\n    super(sid, mediaTrackReceiver, isEnabled, isSwitchedOff, setPriority, setRenderHint, options);\n\n    Object.defineProperties(this, {\n      _enableDocumentVisibilityTurnOff: {\n        value: options.enableDocumentVisibilityTurnOff === true && options.clientTrackSwitchOffControl === 'auto',\n      },\n      _documentVisibilityTurnOffCleanup: {\n        value: null,\n        writable: true\n      },\n      _clientTrackSwitchOffControl: {\n        value: options.clientTrackSwitchOffControl,\n      },\n      _contentPreferencesMode: {\n        value: options.contentPreferencesMode,\n      },\n      _invisibleElements: {\n        value: new WeakSet(),\n      },\n      _elToPipCallbacks: {\n        value: new WeakMap(),\n      },\n      _elToPipWindows: {\n        value: new WeakMap(),\n      },\n      _turnOffTimer: {\n        value: new Timeout(() => {\n          this._setRenderHint({ enabled: false });\n        }, TRACK_TURN_OF_DELAY_MS, false),\n      },\n      _resizeObserver: {\n        value: new options.ResizeObserver(entries => {\n          // NOTE(mpatwardhan): we ignore elements in _invisibleElements\n          // to ensure that ResizeObserver does not end-up turning off a track when a fresh Video element is\n          // attached and IntersectionObserver has not had its callback executed yet.\n          const visibleElementResized = entries.find(entry => !this._invisibleElements.has(entry.target));\n          if (visibleElementResized) {\n            maybeUpdateDimensionHint(this);\n          }\n        })\n      },\n      _intersectionObserver: {\n        value: new options.IntersectionObserver(entries => {\n          let shouldSetRenderHint = false;\n          entries.forEach(entry => {\n            const wasVisible = !this._invisibleElements.has(entry.target);\n            if (wasVisible !== entry.isIntersecting) {\n              if (entry.isIntersecting) {\n                this._log.debug('intersectionObserver detected: Off => On');\n                this._invisibleElements.delete(entry.target);\n              } else {\n                this._log.debug('intersectionObserver detected: On => Off');\n                this._invisibleElements.add(entry.target);\n              }\n              shouldSetRenderHint = true;\n            }\n          });\n          if (shouldSetRenderHint) {\n            maybeUpdateEnabledHint(this);\n\n            // when visibility of an element changes that may cause the \"biggest\" element to change,\n            // update dimensions as well. since dimensions are cached and de-duped at signaling layer,\n            // its okay if they got  resent.\n            maybeUpdateDimensionHint(this);\n          }\n        }, { threshold: 0.25 })\n      },\n    });\n  }\n\n  /**\n   * @private\n   */\n  _start(dummyEl) {\n    const result = super._start.call(this, dummyEl);\n    // NOTE(mpatwardhan): after emitting started, update turn off track if not visible.\n    maybeUpdateEnabledHint(this);\n    return result;\n  }\n\n  /**\n   * Request to switch on a {@link RemoteVideoTrack}, This method is applicable only for the group rooms and only when connected with\n   * clientTrackSwitchOffControl in video bandwidth profile options set to 'manual'\n   * @returns {this}\n   */\n  switchOn() {\n    if (this._clientTrackSwitchOffControl !== 'manual') {\n      throw new Error('Invalid state. You can call switchOn only when bandwidthProfile.video.clientTrackSwitchOffControl is set to \"manual\"');\n    }\n    this._setRenderHint({ enabled: true });\n    return this;\n  }\n\n  /**\n   * Request to switch off a {@link RemoteVideoTrack}, This method is applicable only for the group rooms and only when connected with\n   * clientTrackSwitchOffControl in video bandwidth profile options set to 'manual'\n   * @returns {this}\n   */\n  switchOff() {\n    if (this._clientTrackSwitchOffControl !== 'manual') {\n      throw new Error('Invalid state. You can call switchOff only when bandwidthProfile.video.clientTrackSwitchOffControl is set to \"manual\"');\n    }\n    this._setRenderHint({ enabled: false });\n    return this;\n  }\n\n  /**\n   * Set the {@link RemoteVideoTrack}'s content preferences. This method is applicable only for the group rooms and only when connected with\n   * videoContentPreferencesMode in video bandwidth profile options set to 'manual'\n   * @param {VideoContentPreferences} contentPreferences - requested preferences.\n   * @returns {this}\n   */\n  setContentPreferences(contentPreferences) {\n    if (this._contentPreferencesMode !== 'manual') {\n      throw new Error('Invalid state. You can call switchOn only when bandwidthProfile.video.contentPreferencesMode is set to \"manual\"');\n    }\n\n    if (contentPreferences.renderDimensions) {\n      this._setRenderHint({ renderDimensions: contentPreferences.renderDimensions });\n    }\n    return this;\n  }\n\n  _unObservePip(el) {\n    const pipCallbacks = this._elToPipCallbacks.get(el);\n    if (pipCallbacks) {\n      el.removeEventListener('enterpictureinpicture', pipCallbacks.onEnterPip);\n      el.removeEventListener('leavepictureinpicture', pipCallbacks.onLeavePip);\n      this._elToPipCallbacks.delete(el);\n    }\n  }\n\n  _observePip(el) {\n    const pipCallbacks = this._elToPipCallbacks.get(el);\n    if (!pipCallbacks) {\n      const onEnterPip = event => this._onEnterPip(event, el);\n      const onLeavePip = event => this._onLeavePip(event, el);\n      const onResizePip = event => this._onResizePip(event, el);\n\n      el.addEventListener('enterpictureinpicture', onEnterPip);\n      el.addEventListener('leavepictureinpicture', onLeavePip);\n      this._elToPipCallbacks.set(el, { onEnterPip, onLeavePip, onResizePip });\n    }\n  }\n\n  _onEnterPip(event, videoEl) {\n    this._log.debug('onEnterPip');\n    const pipWindow = event.pictureInPictureWindow;\n    this._elToPipWindows.set(videoEl, pipWindow);\n    const { onResizePip } = this._elToPipCallbacks.get(videoEl);\n    pipWindow.addEventListener('resize', onResizePip);\n    maybeUpdateEnabledHint(this);\n  }\n\n  _onLeavePip(event, videoEl) {\n    this._log.debug('onLeavePip');\n    this._elToPipWindows.delete(videoEl);\n    const { onResizePip } = this._elToPipCallbacks.get(videoEl);\n    const pipWindow = event.pictureInPictureWindow;\n    pipWindow.removeEventListener('resize', onResizePip);\n    maybeUpdateEnabledHint(this);\n  }\n\n  _onResizePip() {\n    maybeUpdateDimensionHint(this);\n  }\n\n  attach(el) {\n    const result = super.attach(el);\n\n    if (this._clientTrackSwitchOffControl === 'auto') {\n      // start off the element as invisible. will mark it\n      // visible (and update render hints) once intersection observer calls back.\n      this._invisibleElements.add(result);\n    }\n\n    this._intersectionObserver.observe(result);\n    this._resizeObserver.observe(result);\n\n    if (this._enableDocumentVisibilityTurnOff) {\n      this._documentVisibilityTurnOffCleanup = this._documentVisibilityTurnOffCleanup || setupDocumentVisibilityTurnOff(this);\n    }\n\n    this._observePip(result);\n    return result;\n  }\n\n  detach(el) {\n    const result = super.detach(el);\n    const elements = Array.isArray(result) ? result : [result];\n    elements.forEach(element => {\n      this._intersectionObserver.unobserve(element);\n      this._resizeObserver.unobserve(element);\n      this._invisibleElements.delete(element);\n      this._unObservePip(element);\n    });\n\n    if (this._attachments.size === 0) {\n      if (this._documentVisibilityTurnOffCleanup) {\n        this._documentVisibilityTurnOffCleanup();\n        this._documentVisibilityTurnOffCleanup = null;\n      }\n    }\n\n    maybeUpdateEnabledHint(this);\n    maybeUpdateDimensionHint(this);\n    return result;\n  }\n\n  /**\n   * Add a {@link VideoProcessor} to allow for custom processing of video frames belonging to a VideoTrack.\n   * When a Participant un-publishes and re-publishes a VideoTrack, a new RemoteVideoTrack is created and\n   * any VideoProcessors attached to the previous RemoteVideoTrack would have to be re-added again.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to use.\n   * @param {AddProcessorOptions} [options] - {@link AddProcessorOptions} to provide.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * const grayscaleProcessor = new GrayScaleProcessor(100);\n   *\n   * Array.from(room.participants.values()).forEach(participant => {\n   *   const remoteVideoTrack = Array.from(participant.videoTracks.values())[0].track;\n   *   remoteVideoTrack.addProcessor(grayscaleProcessor);\n   * });\n   */\n  addProcessor() {\n    return super.addProcessor.apply(this, arguments);\n  }\n\n  /**\n   * Remove the previously added {@link VideoProcessor} using `addProcessor` API.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to remove.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * const grayscaleProcessor = new GrayScaleProcessor(100);\n   *\n   * Array.from(room.participants.values()).forEach(participant => {\n   *   const remoteVideoTrack = Array.from(participant.videoTracks.values())[0].track;\n   *   remoteVideoTrack.addProcessor(grayscaleProcessor);\n   * });\n   *\n   * document.getElementById('remove-button').onclick = () => {\n   *   Array.from(room.participants.values()).forEach(participant => {\n   *     const remoteVideoTrack = Array.from(participant.videoTracks.values())[0].track;\n   *     remoteVideoTrack.removeProcessor(grayscaleProcessor);\n   *   });\n   * }\n   */\n  removeProcessor() {\n    return super.removeProcessor.apply(this, arguments);\n  }\n\n  toString() {\n    return `[RemoteVideoTrack #${this._instanceId}: ${this.sid}]`;\n  }\n\n  /**\n   * Update the subscribe {@link Track.Priority} of the {@link RemoteVideoTrack}.\n   * @param {?Track.Priority} priority - the new subscribe {@link Track.Priority};\n   *   If <code>null</code>, then the subscribe {@link Track.Priority} is cleared, which\n   *   means the {@link Track.Priority} set by the publisher is now the effective priority.\n   * @returns {this}\n   * @throws {RangeError}\n   */\n  setPriority(priority) {\n    return super.setPriority(priority);\n  }\n}\n\nfunction setupDocumentVisibilityTurnOff(removeVideoTrack) {\n  function onVisibilityChanged() {\n    maybeUpdateEnabledHint(removeVideoTrack);\n  }\n\n  documentVisibilityMonitor.onVisibilityChange(1, onVisibilityChanged);\n  return () => {\n    documentVisibilityMonitor.offVisibilityChange(1, onVisibilityChanged);\n  };\n}\n\nfunction maybeUpdateEnabledHint(remoteVideoTrack) {\n  if (remoteVideoTrack._clientTrackSwitchOffControl !== 'auto') {\n    return;\n  }\n\n  const visibleElements = remoteVideoTrack._getAllAttachedElements().filter(el => !remoteVideoTrack._invisibleElements.has(el));\n  const pipWindows = remoteVideoTrack._getAllAttachedElements().filter(el => remoteVideoTrack._elToPipWindows.has(el));\n\n  // even when document is invisible we may have track playing in pip window.\n  const enabled = pipWindows.length > 0 || (document.visibilityState === 'visible' && visibleElements.length > 0);\n\n  if (enabled === true) {\n    remoteVideoTrack._turnOffTimer.clear();\n    remoteVideoTrack._setRenderHint({ enabled: true });\n  } else if (!remoteVideoTrack._turnOffTimer.isSet) {\n    // set the track to be turned off after some delay.\n    remoteVideoTrack._turnOffTimer.start();\n  }\n}\n\nfunction maybeUpdateDimensionHint(remoteVideoTrack) {\n  if (remoteVideoTrack._contentPreferencesMode !== 'auto') {\n    return;\n  }\n\n  const visibleElements = remoteVideoTrack._getAllAttachedElements().filter(el => !remoteVideoTrack._invisibleElements.has(el));\n  const pipElements = remoteVideoTrack._getAllAttachedElements().map(el => {\n    const pipWindow = remoteVideoTrack._elToPipWindows.get(el);\n    return pipWindow ? { clientHeight: pipWindow.height, clientWidth: pipWindow.width } : { clientHeight: 0, clientWidth: 0 };\n  });\n  const totalElements = visibleElements.concat(pipElements);\n  if (totalElements.length > 0) {\n    const [{ clientHeight, clientWidth }] = totalElements.sort((el1, el2) =>\n      el2.clientHeight + el2.clientWidth - el1.clientHeight - el1.clientWidth - 1);\n    const renderDimensions = { height: clientHeight, width: clientWidth };\n    remoteVideoTrack._setRenderHint({ renderDimensions });\n  }\n}\n\n/**\n * @typedef {object} VideoContentPreferences\n * @property {VideoTrack.Dimensions} [renderDimensions] - Render Dimensions to request for the {@link RemoteVideoTrack}.\n */\n\n/**\n * The {@link RemoteVideoTrack}'s dimensions changed.\n * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} whose\n *   dimensions changed\n * @event RemoteVideoTrack#dimensionsChanged\n */\n\n/**\n * The {@link RemoteVideoTrack} was disabled, i.e. \"paused\".\n * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} that was\n *   disabled\n * @event RemoteVideoTrack#disabled\n */\n\n/**\n * The {@link RemoteVideoTrack} was enabled, i.e. \"resumed\".\n * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} that was\n *   enabled\n * @event RemoteVideoTrack#enabled\n */\n\n/**\n * The {@link RemoteVideoTrack} started. This means there is enough video data\n * to begin playback.\n * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} that started\n * @event RemoteVideoTrack#started\n */\n\n/**\n * A {@link RemoteVideoTrack} was switched off.\n * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} that was\n *   switched off\n * @event RemoteVideoTrack#switchedOff\n */\n\n/**\n * A {@link RemoteVideoTrack} was switched on.\n * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} that was\n *   switched on\n * @event RemoteVideoTrack#switchedOn\n */\n\nmodule.exports = RemoteVideoTrack;\n"],"mappings":"AAAA,YAAY;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEZ,IAAMA,qBAAqB,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AAC3D,IAAMC,UAAU,GAAGD,OAAO,CAAC,cAAc,CAAC;AAC1C,IAAME,yBAAyB,GAAGF,OAAO,CAAC,yCAAyC,CAAC;AAC5E,IAAAG,YAAY,GAAKH,OAAO,CAAC,4BAA4B,CAAC,CAAAG,YAA1C;AACpB,IAAMC,OAAO,GAAGJ,OAAO,CAAC,oBAAoB,CAAC;AAE7C,IAAMK,qBAAqB,GAAGN,qBAAqB,CAACE,UAAU,CAAC;AAC/D,IAAMK,sBAAsB,GAAG,EAAE;AAEjC;;;;;;;;;;;;;;;AAeA,IAAAC,gBAAA,0BAAAC,MAAA;EAA+BC,SAAA,CAAAF,gBAAA,EAAAC,MAAA;EAC7B;;;;;;;;;;;EAWA,SAAAD,iBAAYG,GAAG,EAAEC,kBAAkB,EAAEC,SAAS,EAAEC,aAAa,EAAEC,WAAW,EAAEC,aAAa,EAAEC,OAAO;IAAlG,IAAAC,KAAA;IACED,OAAO,GAAGE,MAAM,CAACC,MAAM,CAAC;MACtBC,2BAA2B,EAAE,MAAM;MACnCC,sBAAsB,EAAE,MAAM;MAC9BC,+BAA+B,EAAE;KAClC,EAAEN,OAAO,CAAC;IAEXA,OAAO,GAAGE,MAAM,CAACC,MAAM,CAAC;MACtBI,oBAAoB,EAAE,OAAOA,oBAAoB,KAAK,WAAW,IAAIP,OAAO,CAACI,2BAA2B,KAAK,MAAM,GAAIjB,YAAY,GAAGoB,oBAAoB;MAC1JC,cAAc,EAAE,OAAOA,cAAc,KAAK,WAAW,IAAIR,OAAO,CAACK,sBAAsB,KAAK,MAAM,GAAIlB,YAAY,GAAGqB;KACtH,EAAER,OAAO,CAAC;IAEXC,KAAA,GAAAT,MAAA,CAAAiB,IAAA,OAAMf,GAAG,EAAEC,kBAAkB,EAAEC,SAAS,EAAEC,aAAa,EAAEC,WAAW,EAAEC,aAAa,EAAEC,OAAO,CAAC;IAE7FE,MAAM,CAACQ,gBAAgB,CAACT,KAAI,EAAE;MAC5BU,gCAAgC,EAAE;QAChCC,KAAK,EAAEZ,OAAO,CAACM,+BAA+B,KAAK,IAAI,IAAIN,OAAO,CAACI,2BAA2B,KAAK;OACpG;MACDS,iCAAiC,EAAE;QACjCD,KAAK,EAAE,IAAI;QACXE,QAAQ,EAAE;OACX;MACDC,4BAA4B,EAAE;QAC5BH,KAAK,EAAEZ,OAAO,CAACI;OAChB;MACDY,uBAAuB,EAAE;QACvBJ,KAAK,EAAEZ,OAAO,CAACK;OAChB;MACDY,kBAAkB,EAAE;QAClBL,KAAK,EAAE,IAAIM,OAAO;OACnB;MACDC,iBAAiB,EAAE;QACjBP,KAAK,EAAE,IAAIQ,OAAO;OACnB;MACDC,eAAe,EAAE;QACfT,KAAK,EAAE,IAAIQ,OAAO;OACnB;MACDE,aAAa,EAAE;QACbV,KAAK,EAAE,IAAIxB,OAAO,CAAC;UACjBa,KAAI,CAACsB,cAAc,CAAC;YAAEC,OAAO,EAAE;UAAK,CAAE,CAAC;QACzC,CAAC,EAAElC,sBAAsB,EAAE,KAAK;OACjC;MACDmC,eAAe,EAAE;QACfb,KAAK,EAAE,IAAIZ,OAAO,CAACQ,cAAc,CAAC,UAAAkB,OAAO;UACvC;UACA;UACA;UACA,IAAMC,qBAAqB,GAAGD,OAAO,CAACE,IAAI,CAAC,UAAAC,KAAK;YAAI,QAAC5B,KAAI,CAACgB,kBAAkB,CAACa,GAAG,CAACD,KAAK,CAACE,MAAM,CAAC;UAA1C,CAA0C,CAAC;UAC/F,IAAIJ,qBAAqB,EAAE;YACzBK,wBAAwB,CAAC/B,KAAI,CAAC;;QAElC,CAAC;OACF;MACDgC,qBAAqB,EAAE;QACrBrB,KAAK,EAAE,IAAIZ,OAAO,CAACO,oBAAoB,CAAC,UAAAmB,OAAO;UAC7C,IAAIQ,mBAAmB,GAAG,KAAK;UAC/BR,OAAO,CAACS,OAAO,CAAC,UAAAN,KAAK;YACnB,IAAMO,UAAU,GAAG,CAACnC,KAAI,CAACgB,kBAAkB,CAACa,GAAG,CAACD,KAAK,CAACE,MAAM,CAAC;YAC7D,IAAIK,UAAU,KAAKP,KAAK,CAACQ,cAAc,EAAE;cACvC,IAAIR,KAAK,CAACQ,cAAc,EAAE;gBACxBpC,KAAI,CAACqC,IAAI,CAACC,KAAK,CAAC,0CAA0C,CAAC;gBAC3DtC,KAAI,CAACgB,kBAAkB,CAACuB,MAAM,CAACX,KAAK,CAACE,MAAM,CAAC;eAC7C,MAAM;gBACL9B,KAAI,CAACqC,IAAI,CAACC,KAAK,CAAC,0CAA0C,CAAC;gBAC3DtC,KAAI,CAACgB,kBAAkB,CAACwB,GAAG,CAACZ,KAAK,CAACE,MAAM,CAAC;;cAE3CG,mBAAmB,GAAG,IAAI;;UAE9B,CAAC,CAAC;UACF,IAAIA,mBAAmB,EAAE;YACvBQ,sBAAsB,CAACzC,KAAI,CAAC;YAE5B;YACA;YACA;YACA+B,wBAAwB,CAAC/B,KAAI,CAAC;;QAElC,CAAC,EAAE;UAAE0C,SAAS,EAAE;QAAI,CAAE;;KAEzB,CAAC;;EACJ;EAEA;;;EAGApD,gBAAA,CAAAqD,SAAA,CAAAC,MAAM,GAAN,UAAOC,OAAO;IACZ,IAAMC,MAAM,GAAGvD,MAAA,CAAAoD,SAAA,CAAMC,MAAM,CAACpC,IAAI,CAAC,IAAI,EAAEqC,OAAO,CAAC;IAC/C;IACAJ,sBAAsB,CAAC,IAAI,CAAC;IAC5B,OAAOK,MAAM;EACf,CAAC;EAED;;;;;EAKAxD,gBAAA,CAAAqD,SAAA,CAAAI,QAAQ,GAAR;IACE,IAAI,IAAI,CAACjC,4BAA4B,KAAK,QAAQ,EAAE;MAClD,MAAM,IAAIkC,KAAK,CAAC,sHAAsH,CAAC;;IAEzI,IAAI,CAAC1B,cAAc,CAAC;MAAEC,OAAO,EAAE;IAAI,CAAE,CAAC;IACtC,OAAO,IAAI;EACb,CAAC;EAED;;;;;EAKAjC,gBAAA,CAAAqD,SAAA,CAAAM,SAAS,GAAT;IACE,IAAI,IAAI,CAACnC,4BAA4B,KAAK,QAAQ,EAAE;MAClD,MAAM,IAAIkC,KAAK,CAAC,uHAAuH,CAAC;;IAE1I,IAAI,CAAC1B,cAAc,CAAC;MAAEC,OAAO,EAAE;IAAK,CAAE,CAAC;IACvC,OAAO,IAAI;EACb,CAAC;EAED;;;;;;EAMAjC,gBAAA,CAAAqD,SAAA,CAAAO,qBAAqB,GAArB,UAAsBC,kBAAkB;IACtC,IAAI,IAAI,CAACpC,uBAAuB,KAAK,QAAQ,EAAE;MAC7C,MAAM,IAAIiC,KAAK,CAAC,iHAAiH,CAAC;;IAGpI,IAAIG,kBAAkB,CAACC,gBAAgB,EAAE;MACvC,IAAI,CAAC9B,cAAc,CAAC;QAAE8B,gBAAgB,EAAED,kBAAkB,CAACC;MAAgB,CAAE,CAAC;;IAEhF,OAAO,IAAI;EACb,CAAC;EAED9D,gBAAA,CAAAqD,SAAA,CAAAU,aAAa,GAAb,UAAcC,EAAE;IACd,IAAMC,YAAY,GAAG,IAAI,CAACrC,iBAAiB,CAACsC,GAAG,CAACF,EAAE,CAAC;IACnD,IAAIC,YAAY,EAAE;MAChBD,EAAE,CAACG,mBAAmB,CAAC,uBAAuB,EAAEF,YAAY,CAACG,UAAU,CAAC;MACxEJ,EAAE,CAACG,mBAAmB,CAAC,uBAAuB,EAAEF,YAAY,CAACI,UAAU,CAAC;MACxE,IAAI,CAACzC,iBAAiB,CAACqB,MAAM,CAACe,EAAE,CAAC;;EAErC,CAAC;EAEDhE,gBAAA,CAAAqD,SAAA,CAAAiB,WAAW,GAAX,UAAYN,EAAE;IAAd,IAAAtD,KAAA;IACE,IAAMuD,YAAY,GAAG,IAAI,CAACrC,iBAAiB,CAACsC,GAAG,CAACF,EAAE,CAAC;IACnD,IAAI,CAACC,YAAY,EAAE;MACjB,IAAMG,UAAU,GAAG,SAAAA,CAAAG,KAAK;QAAI,OAAA7D,KAAI,CAAC8D,WAAW,CAACD,KAAK,EAAEP,EAAE,CAAC;MAA3B,CAA2B;MACvD,IAAMK,UAAU,GAAG,SAAAA,CAAAE,KAAK;QAAI,OAAA7D,KAAI,CAAC+D,WAAW,CAACF,KAAK,EAAEP,EAAE,CAAC;MAA3B,CAA2B;MACvD,IAAMU,WAAW,GAAG,SAAAA,CAAAH,KAAK;QAAI,OAAA7D,KAAI,CAACiE,YAAY,CAACJ,KAAK,EAAEP,EAAE,CAAC;MAA5B,CAA4B;MAEzDA,EAAE,CAACY,gBAAgB,CAAC,uBAAuB,EAAER,UAAU,CAAC;MACxDJ,EAAE,CAACY,gBAAgB,CAAC,uBAAuB,EAAEP,UAAU,CAAC;MACxD,IAAI,CAACzC,iBAAiB,CAACiD,GAAG,CAACb,EAAE,EAAE;QAAEI,UAAU,EAAAA,UAAA;QAAEC,UAAU,EAAAA,UAAA;QAAEK,WAAW,EAAAA;MAAA,CAAE,CAAC;;EAE3E,CAAC;EAED1E,gBAAA,CAAAqD,SAAA,CAAAmB,WAAW,GAAX,UAAYD,KAAK,EAAEO,OAAO;IACxB,IAAI,CAAC/B,IAAI,CAACC,KAAK,CAAC,YAAY,CAAC;IAC7B,IAAM+B,SAAS,GAAGR,KAAK,CAACS,sBAAsB;IAC9C,IAAI,CAAClD,eAAe,CAAC+C,GAAG,CAACC,OAAO,EAAEC,SAAS,CAAC;IACpC,IAAAL,WAAW,GAAK,IAAI,CAAC9C,iBAAiB,CAACsC,GAAG,CAACY,OAAO,CAAC,CAAAJ,WAAxC;IACnBK,SAAS,CAACH,gBAAgB,CAAC,QAAQ,EAAEF,WAAW,CAAC;IACjDvB,sBAAsB,CAAC,IAAI,CAAC;EAC9B,CAAC;EAEDnD,gBAAA,CAAAqD,SAAA,CAAAoB,WAAW,GAAX,UAAYF,KAAK,EAAEO,OAAO;IACxB,IAAI,CAAC/B,IAAI,CAACC,KAAK,CAAC,YAAY,CAAC;IAC7B,IAAI,CAAClB,eAAe,CAACmB,MAAM,CAAC6B,OAAO,CAAC;IAC5B,IAAAJ,WAAW,GAAK,IAAI,CAAC9C,iBAAiB,CAACsC,GAAG,CAACY,OAAO,CAAC,CAAAJ,WAAxC;IACnB,IAAMK,SAAS,GAAGR,KAAK,CAACS,sBAAsB;IAC9CD,SAAS,CAACZ,mBAAmB,CAAC,QAAQ,EAAEO,WAAW,CAAC;IACpDvB,sBAAsB,CAAC,IAAI,CAAC;EAC9B,CAAC;EAEDnD,gBAAA,CAAAqD,SAAA,CAAAsB,YAAY,GAAZ;IACElC,wBAAwB,CAAC,IAAI,CAAC;EAChC,CAAC;EAEDzC,gBAAA,CAAAqD,SAAA,CAAA4B,MAAM,GAAN,UAAOjB,EAAE;IACP,IAAMR,MAAM,GAAGvD,MAAA,CAAAoD,SAAA,CAAM4B,MAAM,CAAA/D,IAAA,OAAC8C,EAAE,CAAC;IAE/B,IAAI,IAAI,CAACxC,4BAA4B,KAAK,MAAM,EAAE;MAChD;MACA;MACA,IAAI,CAACE,kBAAkB,CAACwB,GAAG,CAACM,MAAM,CAAC;;IAGrC,IAAI,CAACd,qBAAqB,CAACwC,OAAO,CAAC1B,MAAM,CAAC;IAC1C,IAAI,CAACtB,eAAe,CAACgD,OAAO,CAAC1B,MAAM,CAAC;IAEpC,IAAI,IAAI,CAACpC,gCAAgC,EAAE;MACzC,IAAI,CAACE,iCAAiC,GAAG,IAAI,CAACA,iCAAiC,IAAI6D,8BAA8B,CAAC,IAAI,CAAC;;IAGzH,IAAI,CAACb,WAAW,CAACd,MAAM,CAAC;IACxB,OAAOA,MAAM;EACf,CAAC;EAEDxD,gBAAA,CAAAqD,SAAA,CAAA+B,MAAM,GAAN,UAAOpB,EAAE;IAAT,IAAAtD,KAAA;IACE,IAAM8C,MAAM,GAAGvD,MAAA,CAAAoD,SAAA,CAAM+B,MAAM,CAAAlE,IAAA,OAAC8C,EAAE,CAAC;IAC/B,IAAMqB,QAAQ,GAAGC,KAAK,CAACC,OAAO,CAAC/B,MAAM,CAAC,GAAGA,MAAM,GAAG,CAACA,MAAM,CAAC;IAC1D6B,QAAQ,CAACzC,OAAO,CAAC,UAAA4C,OAAO;MACtB9E,KAAI,CAACgC,qBAAqB,CAAC+C,SAAS,CAACD,OAAO,CAAC;MAC7C9E,KAAI,CAACwB,eAAe,CAACuD,SAAS,CAACD,OAAO,CAAC;MACvC9E,KAAI,CAACgB,kBAAkB,CAACuB,MAAM,CAACuC,OAAO,CAAC;MACvC9E,KAAI,CAACqD,aAAa,CAACyB,OAAO,CAAC;IAC7B,CAAC,CAAC;IAEF,IAAI,IAAI,CAACE,YAAY,CAACC,IAAI,KAAK,CAAC,EAAE;MAChC,IAAI,IAAI,CAACrE,iCAAiC,EAAE;QAC1C,IAAI,CAACA,iCAAiC,EAAE;QACxC,IAAI,CAACA,iCAAiC,GAAG,IAAI;;;IAIjD6B,sBAAsB,CAAC,IAAI,CAAC;IAC5BV,wBAAwB,CAAC,IAAI,CAAC;IAC9B,OAAOe,MAAM;EACf,CAAC;EAED;;;;;;;;;;;;;;;;;;;;;;;;;;EA0BAxD,gBAAA,CAAAqD,SAAA,CAAAuC,YAAY,GAAZ;IACE,OAAO3F,MAAA,CAAAoD,SAAA,CAAMuC,YAAY,CAACC,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;EAClD,CAAC;EAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA8BA9F,gBAAA,CAAAqD,SAAA,CAAA0C,eAAe,GAAf;IACE,OAAO9F,MAAA,CAAAoD,SAAA,CAAM0C,eAAe,CAACF,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;EACrD,CAAC;EAED9F,gBAAA,CAAAqD,SAAA,CAAA2C,QAAQ,GAAR;IACE,OAAO,wBAAsB,IAAI,CAACC,WAAW,UAAK,IAAI,CAAC9F,GAAG,MAAG;EAC/D,CAAC;EAED;;;;;;;;EAQAH,gBAAA,CAAAqD,SAAA,CAAA9C,WAAW,GAAX,UAAY2F,QAAQ;IAClB,OAAOjG,MAAA,CAAAoD,SAAA,CAAM9C,WAAW,CAAAW,IAAA,OAACgF,QAAQ,CAAC;EACpC,CAAC;EACH,OAAAlG,gBAAC;AAAD,CAAC,CAxT8BF,qBAAqB;AA0TpD,SAASqF,8BAA8BA,CAACgB,gBAAgB;EACtD,SAASC,mBAAmBA,CAAA;IAC1BjD,sBAAsB,CAACgD,gBAAgB,CAAC;EAC1C;EAEAxG,yBAAyB,CAAC0G,kBAAkB,CAAC,CAAC,EAAED,mBAAmB,CAAC;EACpE,OAAO;IACLzG,yBAAyB,CAAC2G,mBAAmB,CAAC,CAAC,EAAEF,mBAAmB,CAAC;EACvE,CAAC;AACH;AAEA,SAASjD,sBAAsBA,CAACoD,gBAAgB;EAC9C,IAAIA,gBAAgB,CAAC/E,4BAA4B,KAAK,MAAM,EAAE;IAC5D;;EAGF,IAAMgF,eAAe,GAAGD,gBAAgB,CAACE,uBAAuB,EAAE,CAACC,MAAM,CAAC,UAAA1C,EAAE;IAAI,QAACuC,gBAAgB,CAAC7E,kBAAkB,CAACa,GAAG,CAACyB,EAAE,CAAC;EAA5C,CAA4C,CAAC;EAC7H,IAAM2C,UAAU,GAAGJ,gBAAgB,CAACE,uBAAuB,EAAE,CAACC,MAAM,CAAC,UAAA1C,EAAE;IAAI,OAAAuC,gBAAgB,CAACzE,eAAe,CAACS,GAAG,CAACyB,EAAE,CAAC;EAAxC,CAAwC,CAAC;EAEpH;EACA,IAAM/B,OAAO,GAAG0E,UAAU,CAACC,MAAM,GAAG,CAAC,IAAKC,QAAQ,CAACC,eAAe,KAAK,SAAS,IAAIN,eAAe,CAACI,MAAM,GAAG,CAAE;EAE/G,IAAI3E,OAAO,KAAK,IAAI,EAAE;IACpBsE,gBAAgB,CAACxE,aAAa,CAACgF,KAAK,EAAE;IACtCR,gBAAgB,CAACvE,cAAc,CAAC;MAAEC,OAAO,EAAE;IAAI,CAAE,CAAC;GACnD,MAAM,IAAI,CAACsE,gBAAgB,CAACxE,aAAa,CAACiF,KAAK,EAAE;IAChD;IACAT,gBAAgB,CAACxE,aAAa,CAACkF,KAAK,EAAE;;AAE1C;AAEA,SAASxE,wBAAwBA,CAAC8D,gBAAgB;EAChD,IAAIA,gBAAgB,CAAC9E,uBAAuB,KAAK,MAAM,EAAE;IACvD;;EAGF,IAAM+E,eAAe,GAAGD,gBAAgB,CAACE,uBAAuB,EAAE,CAACC,MAAM,CAAC,UAAA1C,EAAE;IAAI,QAACuC,gBAAgB,CAAC7E,kBAAkB,CAACa,GAAG,CAACyB,EAAE,CAAC;EAA5C,CAA4C,CAAC;EAC7H,IAAMkD,WAAW,GAAGX,gBAAgB,CAACE,uBAAuB,EAAE,CAACU,GAAG,CAAC,UAAAnD,EAAE;IACnE,IAAMe,SAAS,GAAGwB,gBAAgB,CAACzE,eAAe,CAACoC,GAAG,CAACF,EAAE,CAAC;IAC1D,OAAOe,SAAS,GAAG;MAAEqC,YAAY,EAAErC,SAAS,CAACsC,MAAM;MAAEC,WAAW,EAAEvC,SAAS,CAACwC;IAAK,CAAE,GAAG;MAAEH,YAAY,EAAE,CAAC;MAAEE,WAAW,EAAE;IAAC,CAAE;EAC3H,CAAC,CAAC;EACF,IAAME,aAAa,GAAGhB,eAAe,CAACiB,MAAM,CAACP,WAAW,CAAC;EACzD,IAAIM,aAAa,CAACZ,MAAM,GAAG,CAAC,EAAE;IACtB,IAAAc,EAAA,GAAAC,MAAA,CAAkCH,aAAa,CAACI,IAAI,CAAC,UAACC,GAAG,EAAEC,GAAG;QAClE,OAAAA,GAAG,CAACV,YAAY,GAAGU,GAAG,CAACR,WAAW,GAAGO,GAAG,CAACT,YAAY,GAAGS,GAAG,CAACP,WAAW,GAAG,CAAC;MAA3E,CAA2E,CAAC;MADvES,EAAA,GAAAL,EAAA,GAA6B;MAA3BN,YAAY,GAAAW,EAAA,CAAAX,YAAA;MAAEE,WAAW,GAAAS,EAAA,CAAAT,WAC4C;IAC9E,IAAMxD,gBAAgB,GAAG;MAAEuD,MAAM,EAAED,YAAY;MAAEG,KAAK,EAAED;IAAW,CAAE;IACrEf,gBAAgB,CAACvE,cAAc,CAAC;MAAE8B,gBAAgB,EAAAA;IAAA,CAAE,CAAC;;AAEzD;AAEA;;;;AAKA;;;;;;AAOA;;;;;;AAOA;;;;;;AAOA;;;;;;AAOA;;;;;;AAOA;;;;;;AAOAkE,MAAM,CAACC,OAAO,GAAGjI,gBAAgB"},"metadata":{},"sourceType":"script","externalDependencies":[]}