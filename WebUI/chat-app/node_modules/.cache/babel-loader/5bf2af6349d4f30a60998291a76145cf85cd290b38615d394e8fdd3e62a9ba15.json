{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nvar DefaultBackoff = require('../../util/backoff');\nvar _a = require('../../webrtc'),\n  DefaultRTCIceCandidate = _a.RTCIceCandidate,\n  DefaultRTCPeerConnection = _a.RTCPeerConnection,\n  DefaultRTCSessionDescription = _a.RTCSessionDescription,\n  getStatistics = _a.getStats;\nvar util = require('../../webrtc/util');\nvar _b = require('../../util/constants'),\n  DEFAULT_ICE_GATHERING_TIMEOUT_MS = _b.DEFAULT_ICE_GATHERING_TIMEOUT_MS,\n  DEFAULT_LOG_LEVEL = _b.DEFAULT_LOG_LEVEL,\n  DEFAULT_SESSION_TIMEOUT_SEC = _b.DEFAULT_SESSION_TIMEOUT_SEC,\n  iceRestartBackoffConfig = _b.iceRestartBackoffConfig;\nvar _c = require('../../util/sdp'),\n  addOrRewriteNewTrackIds = _c.addOrRewriteNewTrackIds,\n  addOrRewriteTrackIds = _c.addOrRewriteTrackIds,\n  createCodecMapForMediaSection = _c.createCodecMapForMediaSection,\n  disableRtx = _c.disableRtx,\n  enableDtxForOpus = _c.enableDtxForOpus,\n  filterLocalCodecs = _c.filterLocalCodecs,\n  getMediaSections = _c.getMediaSections,\n  removeSSRCAttributes = _c.removeSSRCAttributes,\n  revertSimulcast = _c.revertSimulcast,\n  setCodecPreferences = _c.setCodecPreferences,\n  setSimulcast = _c.setSimulcast;\nvar DefaultTimeout = require('../../util/timeout');\nvar _d = require('../../util/twilio-video-errors'),\n  MediaClientLocalDescFailedError = _d.MediaClientLocalDescFailedError,\n  MediaClientRemoteDescFailedError = _d.MediaClientRemoteDescFailedError;\nvar _e = require('../../util'),\n  buildLogLevels = _e.buildLogLevels,\n  getPlatform = _e.getPlatform,\n  isChromeScreenShareTrack = _e.isChromeScreenShareTrack,\n  oncePerTick = _e.oncePerTick,\n  defer = _e.defer;\nvar IceBox = require('./icebox');\nvar DefaultIceConnectionMonitor = require('./iceconnectionmonitor.js');\nvar DataTrackReceiver = require('../../data/receiver');\nvar MediaTrackReceiver = require('../../media/track/receiver');\nvar StateMachine = require('../../statemachine');\nvar Log = require('../../util/log');\nvar TrackMatcher = require('../../util/sdp/trackmatcher');\nvar workaroundIssue8329 = require('../../util/sdp/issue8329');\nvar guess = util.guessBrowser();\nvar platform = getPlatform();\nvar isAndroid = /android/.test(platform);\nvar isChrome = guess === 'chrome';\nvar isFirefox = guess === 'firefox';\nvar isSafari = guess === 'safari';\nvar nInstances = 0;\n/*\nPeerConnectionV2 States\n-----------------------\n\n    +------+    +--------+\n    |      |    |        |\n    | open |--->| closed |\n    |      |    |        |\n    +------+    +--------+\n      |  ^          ^\n      |  |          |\n      |  |          |\n      v  |          |\n  +----------+      |\n  |          |      |\n  | updating |------+\n  |          |\n  +----------+\n\n*/\nvar states = {\n  open: ['closed', 'updating'],\n  updating: ['closed', 'open'],\n  closed: []\n};\n/**\n * @extends StateMachine\n * @property {id}\n * @emits PeerConnectionV2#connectionStateChanged\n * @emits PeerConnectionV2#iceConnectionStateChanged\n * @emits PeerConnectionV2#candidates\n * @emits PeerConnectionV2#description\n */\nvar PeerConnectionV2 = /** @class */function (_super) {\n  __extends(PeerConnectionV2, _super);\n  /**\n   * Construct a {@link PeerConnectionV2}.\n   * @param {string} id\n   * @param {EncodingParametersImpl} encodingParameters\n   * @param {PreferredCodecs} preferredCodecs\n   * @param {object} [options]\n   */\n  function PeerConnectionV2(id, encodingParameters, preferredCodecs, options) {\n    var _this = _super.call(this, 'open', states) || this;\n    options = Object.assign({\n      enableDscp: false,\n      dummyAudioMediaStreamTrack: null,\n      isChromeScreenShareTrack: isChromeScreenShareTrack,\n      iceServers: [],\n      logLevel: DEFAULT_LOG_LEVEL,\n      offerOptions: {},\n      revertSimulcast: revertSimulcast,\n      sessionTimeout: DEFAULT_SESSION_TIMEOUT_SEC * 1000,\n      setCodecPreferences: setCodecPreferences,\n      setSimulcast: setSimulcast,\n      Backoff: DefaultBackoff,\n      IceConnectionMonitor: DefaultIceConnectionMonitor,\n      RTCIceCandidate: DefaultRTCIceCandidate,\n      RTCPeerConnection: DefaultRTCPeerConnection,\n      RTCSessionDescription: DefaultRTCSessionDescription,\n      Timeout: DefaultTimeout\n    }, options);\n    var configuration = getConfiguration(options);\n    var logLevels = buildLogLevels(options.logLevel);\n    var RTCPeerConnection = options.RTCPeerConnection;\n    if (options.enableDscp === true) {\n      options.chromeSpecificConstraints = options.chromeSpecificConstraints || {};\n      options.chromeSpecificConstraints.optional = options.chromeSpecificConstraints.optional || [];\n      options.chromeSpecificConstraints.optional.push({\n        googDscp: true\n      });\n    }\n    var log = options.log ? options.log.createLog('webrtc', _this) : new Log('webrtc', _this, logLevels, options.loggerName);\n    var peerConnection = new RTCPeerConnection(configuration, options.chromeSpecificConstraints);\n    if (options.dummyAudioMediaStreamTrack) {\n      peerConnection.addTrack(options.dummyAudioMediaStreamTrack);\n    }\n    Object.defineProperties(_this, {\n      _appliedTrackIdsToAttributes: {\n        value: new Map(),\n        writable: true\n      },\n      _dataChannels: {\n        value: new Map()\n      },\n      _dataTrackReceivers: {\n        value: new Set()\n      },\n      _descriptionRevision: {\n        writable: true,\n        value: 0\n      },\n      _didGenerateLocalCandidates: {\n        writable: true,\n        value: false\n      },\n      _enableDscp: {\n        value: options.enableDscp\n      },\n      _encodingParameters: {\n        value: encodingParameters\n      },\n      _isChromeScreenShareTrack: {\n        value: options.isChromeScreenShareTrack\n      },\n      _iceGatheringFailed: {\n        value: false,\n        writable: true\n      },\n      _iceGatheringTimeout: {\n        value: new options.Timeout(function () {\n          return _this._handleIceGatheringTimeout();\n        }, DEFAULT_ICE_GATHERING_TIMEOUT_MS, false)\n      },\n      _iceRestartBackoff: {\n        // eslint-disable-next-line new-cap\n        value: new options.Backoff(iceRestartBackoffConfig)\n      },\n      _instanceId: {\n        value: ++nInstances\n      },\n      _isIceConnectionInactive: {\n        writable: true,\n        value: false\n      },\n      _isIceLite: {\n        writable: true,\n        value: false\n      },\n      _isIceRestartBackoffInProgress: {\n        writable: true,\n        value: false\n      },\n      _isRestartingIce: {\n        writable: true,\n        value: false\n      },\n      _lastIceConnectionState: {\n        writable: true,\n        value: null\n      },\n      _lastStableDescriptionRevision: {\n        writable: true,\n        value: 0\n      },\n      _localCandidates: {\n        writable: true,\n        value: []\n      },\n      _localCodecs: {\n        value: new Set()\n      },\n      _localCandidatesRevision: {\n        writable: true,\n        value: 1\n      },\n      _localDescriptionWithoutSimulcast: {\n        writable: true,\n        value: null\n      },\n      _localDescription: {\n        writable: true,\n        value: null\n      },\n      _localUfrag: {\n        writable: true,\n        value: null\n      },\n      _log: {\n        value: log\n      },\n      _eventObserver: {\n        value: options.eventObserver\n      },\n      _remoteCodecMaps: {\n        value: new Map()\n      },\n      _rtpSenders: {\n        value: new Map()\n      },\n      _rtpNewSenders: {\n        value: new Set()\n      },\n      _iceConnectionMonitor: {\n        value: new options.IceConnectionMonitor(peerConnection)\n      },\n      _mediaTrackReceivers: {\n        value: new Set()\n      },\n      _needsAnswer: {\n        writable: true,\n        value: false\n      },\n      _negotiationRole: {\n        writable: true,\n        value: null\n      },\n      _offerOptions: {\n        writable: true,\n        value: options.offerOptions\n      },\n      _onEncodingParametersChanged: {\n        value: oncePerTick(function () {\n          if (!_this._needsAnswer) {\n            updateEncodingParameters(_this);\n          }\n        })\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _preferredAudioCodecs: {\n        value: preferredCodecs.audio\n      },\n      _preferredVideoCodecs: {\n        value: preferredCodecs.video\n      },\n      _shouldApplyDtx: {\n        value: preferredCodecs.audio.every(function (_a) {\n          var codec = _a.codec;\n          return codec !== 'opus';\n        }) || preferredCodecs.audio.some(function (_a) {\n          var codec = _a.codec,\n            dtx = _a.dtx;\n          return codec === 'opus' && dtx;\n        })\n      },\n      _queuedDescription: {\n        writable: true,\n        value: null\n      },\n      _iceReconnectTimeout: {\n        value: new options.Timeout(function () {\n          log.debug('ICE reconnect timed out');\n          _this.close();\n        }, options.sessionTimeout, false)\n      },\n      _recycledTransceivers: {\n        value: {\n          audio: [],\n          video: []\n        }\n      },\n      _replaceTrackPromises: {\n        value: new Map()\n      },\n      _remoteCandidates: {\n        writable: true,\n        value: new IceBox()\n      },\n      _setCodecPreferences: {\n        // NOTE(mmalavalli): Re-ordering payload types in order to make sure a non-H264\n        // preferred codec is selected does not work on Android Firefox due to this behavior:\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1683258. So, we work around this by\n        // not applying any non-H264 preferred video codec.\n        value: isFirefox && isAndroid && preferredCodecs.video[0] && preferredCodecs.video[0].codec.toLowerCase() !== 'h264' ? function (sdp) {\n          return sdp;\n        } : options.setCodecPreferences\n      },\n      _setSimulcast: {\n        value: options.setSimulcast\n      },\n      _revertSimulcast: {\n        value: options.revertSimulcast\n      },\n      _RTCIceCandidate: {\n        value: options.RTCIceCandidate\n      },\n      _RTCPeerConnection: {\n        value: options.RTCPeerConnection\n      },\n      _RTCSessionDescription: {\n        value: options.RTCSessionDescription\n      },\n      _shouldOffer: {\n        writable: true,\n        value: false\n      },\n      _shouldRestartIce: {\n        writable: true,\n        value: false\n      },\n      _trackIdsToAttributes: {\n        value: new Map(),\n        writable: true\n      },\n      _trackMatcher: {\n        writable: true,\n        value: null\n      },\n      _mediaTrackSenderToPublisherHints: {\n        value: new Map()\n      },\n      id: {\n        enumerable: true,\n        value: id\n      }\n    });\n    encodingParameters.on('changed', _this._onEncodingParametersChanged);\n    peerConnection.addEventListener('connectionstatechange', _this._handleConnectionStateChange.bind(_this));\n    peerConnection.addEventListener('datachannel', _this._handleDataChannelEvent.bind(_this));\n    peerConnection.addEventListener('icecandidate', _this._handleIceCandidateEvent.bind(_this));\n    peerConnection.addEventListener('iceconnectionstatechange', _this._handleIceConnectionStateChange.bind(_this));\n    peerConnection.addEventListener('icegatheringstatechange', _this._handleIceGatheringStateChange.bind(_this));\n    peerConnection.addEventListener('signalingstatechange', _this._handleSignalingStateChange.bind(_this));\n    peerConnection.addEventListener('track', _this._handleTrackEvent.bind(_this));\n    var self = _this;\n    _this.on('stateChanged', function stateChanged(state) {\n      if (state !== 'closed') {\n        return;\n      }\n      self.removeListener('stateChanged', stateChanged);\n      self._dataChannels.forEach(function (dataChannel, dataTrackSender) {\n        self.removeDataTrackSender(dataTrackSender);\n      });\n    });\n    return _this;\n  }\n  PeerConnectionV2.prototype.toString = function () {\n    return \"[PeerConnectionV2 #\" + this._instanceId + \": \" + this.id + \"]\";\n  };\n  PeerConnectionV2.prototype.setEffectiveAdaptiveSimulcast = function (effectiveAdaptiveSimulcast) {\n    this._log.debug('Setting setEffectiveAdaptiveSimulcast: ', effectiveAdaptiveSimulcast);\n    // clear adaptive simulcast from codec preferences if it was set.\n    this._preferredVideoCodecs.forEach(function (cs) {\n      if ('adaptiveSimulcast' in cs) {\n        cs.adaptiveSimulcast = effectiveAdaptiveSimulcast;\n      }\n    });\n  };\n  Object.defineProperty(PeerConnectionV2.prototype, \"_shouldApplySimulcast\", {\n    get: function () {\n      if (!isChrome && !isSafari) {\n        return false;\n      }\n      // adaptiveSimulcast is set to false after connected message is received if other party does not support it.\n      var simulcast = this._preferredVideoCodecs.some(function (cs) {\n        return cs.codec.toLowerCase() === 'vp8' && cs.simulcast && cs.adaptiveSimulcast !== false;\n      });\n      return simulcast;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PeerConnectionV2.prototype, \"connectionState\", {\n    /**\n     * The {@link PeerConnectionV2}'s underlying RTCPeerConnection's RTCPeerConnectionState\n     * if supported by the browser, its RTCIceConnectionState otherwise.\n     * @property {RTCPeerConnectionState}\n     */\n    get: function () {\n      return this.iceConnectionState === 'failed' ? 'failed' : this._peerConnection.connectionState || this.iceConnectionState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PeerConnectionV2.prototype, \"iceConnectionState\", {\n    /**\n     * The {@link PeerConnectionV2}'s underlying RTCPeerConnection's\n     * RTCIceConnectionState.\n     * @property {RTCIceConnectionState}\n     */\n    get: function () {\n      return this._isIceConnectionInactive && this._peerConnection.iceConnectionState === 'disconnected' || this._iceGatheringFailed ? 'failed' : this._peerConnection.iceConnectionState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PeerConnectionV2.prototype, \"isApplicationSectionNegotiated\", {\n    /**\n     * Whether the {@link PeerConnectionV2} has negotiated or is in the process\n     * of negotiating the application m= section.\n     * @returns {boolean}\n     */\n    get: function () {\n      if (this._peerConnection.signalingState !== 'closed') {\n        // accessing .localDescription in 'closed' state causes it throw exceptions.\n        return this._peerConnection.localDescription ? getMediaSections(this._peerConnection.localDescription.sdp, 'application').length > 0 : false;\n      }\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PeerConnectionV2.prototype, \"_isAdaptiveSimulcastEnabled\", {\n    /**\n     * Whether adaptive simulcast is enabled.\n     * @returns {boolean}\n     */\n    get: function () {\n      var adaptiveSimulcastEntry = this._preferredVideoCodecs.find(function (cs) {\n        return 'adaptiveSimulcast' in cs;\n      });\n      return adaptiveSimulcastEntry && adaptiveSimulcastEntry.adaptiveSimulcast === true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * @param {MediaStreamTrack} track\n   * @param {Array<RTCRtpEncodingParameters>} encodings\n   * @param {boolean} trackReplaced\n   * @returns {boolean} true if encodings were updated.\n   */\n  PeerConnectionV2.prototype._maybeUpdateEncodings = function (track, encodings, trackReplaced) {\n    if (trackReplaced === void 0) {\n      trackReplaced = false;\n    }\n    if (track.kind !== 'video' || track.readyState === 'ended') {\n      return false;\n    }\n    // NOTE(mmalavalli): There is no guarantee that CanvasCaptureMediaStreamTracks will always have \"width\" and \"height\"\n    // in their settings. So, we don't update the encodings if they are not present.\n    // Chromium bug: https://bugs.chromium.org/p/chromium/issues/detail?id=1367082\n    var _a = track.getSettings(),\n      height = _a.height,\n      width = _a.width;\n    if (typeof height !== 'number' || typeof width !== 'number') {\n      return false;\n    }\n    // Note(mpatwardhan): always configure encodings for safari.\n    // for chrome only when adaptive simulcast enabled.\n    var browser = util.guessBrowser();\n    if (browser === 'safari' || browser === 'chrome' && this._isAdaptiveSimulcastEnabled) {\n      this._updateEncodings(track, encodings, trackReplaced);\n      return true;\n    }\n    return false;\n  };\n  /**\n   * Configures with default encodings depending on track type and resolution.\n   * Default configuration sets some encodings to disabled, and for others set scaleResolutionDownBy\n   * values. When trackReplaced is set to true, it will clear 'active' for any encodings that\n   * needs to be enabled.\n   * @param {MediaStreamTrack} track\n   * @param {Array<RTCRtpEncodingParameters>} encodings\n   * @param {boolean} trackReplaced\n   */\n  PeerConnectionV2.prototype._updateEncodings = function (track, encodings, trackReplaced) {\n    if (this._isChromeScreenShareTrack(track)) {\n      var screenShareActiveLayerConfig_1 = [{\n        scaleResolutionDownBy: 1\n      }, {\n        scaleResolutionDownBy: 1\n      }];\n      encodings.forEach(function (encoding, i) {\n        var activeLayerConfig = screenShareActiveLayerConfig_1[i];\n        if (activeLayerConfig) {\n          encoding.scaleResolutionDownBy = activeLayerConfig.scaleResolutionDownBy;\n          if (trackReplaced) {\n            delete encoding.active;\n          }\n        } else {\n          encoding.active = false;\n          delete encoding.scaleResolutionDownBy;\n        }\n      });\n    } else {\n      var _a = track.getSettings(),\n        width = _a.width,\n        height = _a.height;\n      // NOTE(mpatwardhan): for non-screen share tracks\n      // enable layers depending on track resolutions\n      var pixelsToMaxActiveLayers = [{\n        pixels: 960 * 540,\n        maxActiveLayers: 3\n      }, {\n        pixels: 480 * 270,\n        maxActiveLayers: 2\n      }, {\n        pixels: 0,\n        maxActiveLayers: 1\n      }];\n      var trackPixels_1 = width * height;\n      var activeLayersInfo = pixelsToMaxActiveLayers.find(function (layer) {\n        return trackPixels_1 >= layer.pixels;\n      });\n      var activeLayers_1 = Math.min(encodings.length, activeLayersInfo.maxActiveLayers);\n      encodings.forEach(function (encoding, i) {\n        var enabled = i < activeLayers_1;\n        if (enabled) {\n          encoding.scaleResolutionDownBy = 1 << activeLayers_1 - i - 1;\n          if (trackReplaced) {\n            encoding.active = true;\n          }\n        } else {\n          encoding.active = false;\n          delete encoding.scaleResolutionDownBy;\n        }\n      });\n    }\n    this._log.debug('_updateEncodings:', encodings.map(function (_a, i) {\n      var active = _a.active,\n        scaleResolutionDownBy = _a.scaleResolutionDownBy;\n      return \"[\" + i + \": \" + active + \", \" + (scaleResolutionDownBy || 0) + \"]\";\n    }).join(', '));\n  };\n  /**\n   * Add an ICE candidate to the {@link PeerConnectionV2}.\n   * @private\n   * @param {object} candidate\n   * @returns {Promise<void>}\n   */\n  PeerConnectionV2.prototype._addIceCandidate = function (candidate) {\n    var _this = this;\n    return Promise.resolve().then(function () {\n      candidate = new _this._RTCIceCandidate(candidate);\n      return _this._peerConnection.addIceCandidate(candidate);\n    }).catch(function (error) {\n      // NOTE(mmalavalli): Firefox 68+ now generates an RTCIceCandidate with an\n      // empty candidate string to signal end-of-candidates, followed by a null\n      // candidate. As of now, Chrome and Safari reject this RTCIceCandidate. Since\n      // this does not affect the media connection between Firefox 68+ and Chrome/Safari\n      // in Peer-to-Peer Rooms, we suppress the Error and log a warning message.\n      //\n      // Chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=978582\n      //\n      _this._log.warn(\"Failed to add RTCIceCandidate \" + (candidate ? \"\\\"\" + candidate.candidate + \"\\\"\" : 'null') + \": \" + error.message);\n    });\n  };\n  /**\n   * Add ICE candidates to the {@link PeerConnectionV2}.\n   * @private\n   * @param {Array<object>} candidates\n   * @returns {Promise<void>}\n   */\n  PeerConnectionV2.prototype._addIceCandidates = function (candidates) {\n    return Promise.all(candidates.map(this._addIceCandidate, this)).then(function () {});\n  };\n  /**\n   * Add a new RTCRtpTransceiver or update an existing RTCRtpTransceiver for the\n   * given MediaStreamTrack.\n   * @private\n   * @param {MediaStreamTrack} track\n   * @returns {RTCRtpTransceiver}\n   */\n  PeerConnectionV2.prototype._addOrUpdateTransceiver = function (track) {\n    var _this = this;\n    var transceiver = takeRecycledTransceiver(this, track.kind);\n    if (transceiver && transceiver.sender) {\n      var oldTrackId = transceiver.sender.track ? transceiver.sender.track.id : null;\n      if (oldTrackId) {\n        this._log.warn(\"Reusing transceiver: \" + transceiver.mid + \"] \" + oldTrackId + \" => \" + track.id);\n      }\n      // NOTE(mpatwardhan):remember this transceiver while we replace track.\n      // we recycle transceivers that are not in use after 'negotiationCompleted', but we want to prevent\n      // this one from getting recycled while replaceTrack is pending.\n      this._replaceTrackPromises.set(transceiver, transceiver.sender.replaceTrack(track).then(function () {\n        transceiver.direction = 'sendrecv';\n      }, function () {\n        // Do nothing.\n      }).finally(function () {\n        _this._replaceTrackPromises.delete(transceiver);\n      }));\n      return transceiver;\n    }\n    return this._peerConnection.addTransceiver(track);\n  };\n  /**\n   * Check the {@link IceBox}.\n   * @private\n   * @param {RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n  PeerConnectionV2.prototype._checkIceBox = function (description) {\n    var ufrag = getUfrag(description);\n    if (!ufrag) {\n      return Promise.resolve();\n    }\n    var candidates = this._remoteCandidates.setUfrag(ufrag);\n    return this._addIceCandidates(candidates);\n  };\n  /**\n   * Create an answer and set it on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescriptionInit} offer\n   * @returns {Promise<boolean>}\n   */\n  PeerConnectionV2.prototype._answer = function (offer) {\n    var _this = this;\n    return Promise.resolve().then(function () {\n      if (!_this._negotiationRole) {\n        _this._negotiationRole = 'answerer';\n      }\n      return _this._setRemoteDescription(offer);\n    }).catch(function () {\n      throw new MediaClientRemoteDescFailedError();\n    }).then(function () {\n      return _this._peerConnection.createAnswer();\n    }).then(function (answer) {\n      if (isFirefox) {\n        // NOTE(mmalavalli): We work around Chromium bug 1106157 by disabling\n        // RTX in Firefox 79+. For more details about the bug, please go here:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1106157\n        answer = new _this._RTCSessionDescription({\n          sdp: disableRtx(answer.sdp),\n          type: answer.type\n        });\n      } else {\n        answer = workaroundIssue8329(answer);\n      }\n      // NOTE(mpatwardhan): Upcoming chrome versions are going to remove ssrc attributes\n      // mslabel and label. See this bug https://bugs.chromium.org/p/webrtc/issues/detail?id=7110\n      // and PSA: https://groups.google.com/forum/#!searchin/discuss-webrtc/PSA%7Csort:date/discuss-webrtc/jcZO-Wj0Wus/k2XvPCvoAwAJ\n      // We are not referencing those attributes, but this changes goes ahead and removes them to see if it works.\n      // this also helps reduce bytes on wires\n      var updatedSdp = removeSSRCAttributes(answer.sdp, ['mslabel', 'label']);\n      if (_this._shouldApplySimulcast) {\n        var sdpWithoutSimulcast = updatedSdp;\n        updatedSdp = _this._setSimulcast(sdpWithoutSimulcast, _this._trackIdsToAttributes);\n        // NOTE(syerrapragada): VMS does not support H264 simulcast. So,\n        // unset simulcast for sections in local offer where corresponding\n        // sections in answer doesn't have vp8 as preferred codec and reapply offer.\n        updatedSdp = _this._revertSimulcast(updatedSdp, sdpWithoutSimulcast, offer.sdp);\n      }\n      // NOTE(mmalavalli): Work around Chromium bug 1074421.\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=1074421\n      updatedSdp = updatedSdp.replace(/42e015/g, '42e01f');\n      return _this._setLocalDescription({\n        type: answer.type,\n        sdp: updatedSdp\n      });\n    }).then(function () {\n      return _this._checkIceBox(offer);\n    }).then(function () {\n      return _this._queuedDescription && _this._updateDescription(_this._queuedDescription);\n    }).then(function () {\n      _this._queuedDescription = null;\n      return _this._maybeReoffer(_this._peerConnection.localDescription);\n    }).catch(function (error) {\n      var errorToThrow = error instanceof MediaClientRemoteDescFailedError ? error : new MediaClientLocalDescFailedError();\n      _this._publishMediaWarning({\n        message: 'Failed to _answer',\n        code: errorToThrow.code,\n        error: error\n      });\n      throw errorToThrow;\n    });\n  };\n  /**\n   * Close the underlying RTCPeerConnection. Returns false if the\n   * RTCPeerConnection was already closed.\n   * @private\n   * @returns {boolean}\n   */\n  PeerConnectionV2.prototype._close = function () {\n    this._iceConnectionMonitor.stop();\n    if (this._peerConnection.signalingState !== 'closed') {\n      this._peerConnection.close();\n      this.preempt('closed');\n      this._encodingParameters.removeListener('changed', this._onEncodingParametersChanged);\n      return true;\n    }\n    return false;\n  };\n  /**\n   * Handle a \"connectionstatechange\" event.\n   * @private\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype._handleConnectionStateChange = function () {\n    this.emit('connectionStateChanged');\n  };\n  /**\n   * Handle a \"datachannel\" event.\n   * @private\n   * @param {RTCDataChannelEvent} event\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype._handleDataChannelEvent = function (event) {\n    var _this = this;\n    var dataChannel = event.channel;\n    var dataTrackReceiver = new DataTrackReceiver(dataChannel);\n    this._dataTrackReceivers.add(dataTrackReceiver);\n    dataChannel.addEventListener('close', function () {\n      _this._dataTrackReceivers.delete(dataTrackReceiver);\n    });\n    this.emit('trackAdded', dataTrackReceiver);\n  };\n  /**\n   * Handle a glare scenario on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescriptionInit} offer\n   * @returns {Promise<void>}\n   */\n  PeerConnectionV2.prototype._handleGlare = function (offer) {\n    var _this = this;\n    this._log.debug('Glare detected; rolling back');\n    if (this._isRestartingIce) {\n      this._log.debug('An ICE restart was in progress; we\\'ll need to restart ICE again after rolling back');\n      this._isRestartingIce = false;\n      this._shouldRestartIce = true;\n    }\n    return Promise.resolve().then(function () {\n      _this._trackIdsToAttributes = new Map(_this._appliedTrackIdsToAttributes);\n      return _this._setLocalDescription({\n        type: 'rollback'\n      });\n    }).then(function () {\n      _this._needsAnswer = false;\n      return _this._answer(offer);\n    }).then(function (didReoffer) {\n      return didReoffer ? Promise.resolve() : _this._offer();\n    });\n  };\n  PeerConnectionV2.prototype._publishMediaWarning = function (_a) {\n    var message = _a.message,\n      code = _a.code,\n      error = _a.error,\n      sdp = _a.sdp;\n    this._eventObserver.emit('event', {\n      level: 'warning',\n      name: 'error',\n      group: 'media',\n      payload: {\n        message: message,\n        code: code,\n        context: JSON.stringify({\n          error: error.message,\n          sdp: sdp\n        })\n      }\n    });\n  };\n  /**\n   * Handle an ICE candidate event.\n   * @private\n   * @param {Event} event\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype._handleIceCandidateEvent = function (event) {\n    if (event.candidate) {\n      this._log.debug('Clearing ICE gathering timeout');\n      this._didGenerateLocalCandidates = true;\n      this._iceGatheringTimeout.clear();\n      this._localCandidates.push(event.candidate);\n    }\n    var peerConnectionState = {\n      ice: {\n        candidates: this._isIceLite ? [] : this._localCandidates.slice(),\n        ufrag: this._localUfrag\n      },\n      id: this.id\n    };\n    if (!event.candidate) {\n      peerConnectionState.ice.complete = true;\n    }\n    if (!(this._isIceLite && event.candidate)) {\n      peerConnectionState.ice.revision = this._localCandidatesRevision++;\n      this.emit('candidates', peerConnectionState);\n    }\n  };\n  /**\n   * Handle an ICE connection state change event.\n   * @private\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype._handleIceConnectionStateChange = function () {\n    var _this = this;\n    var iceConnectionState = this._peerConnection.iceConnectionState;\n    var isIceConnectedOrComplete = ['connected', 'completed'].includes(iceConnectionState);\n    var log = this._log;\n    log.debug(\"ICE connection state is \\\"\" + iceConnectionState + \"\\\"\");\n    if (isIceConnectedOrComplete) {\n      this._iceReconnectTimeout.clear();\n      this._iceRestartBackoff.reset();\n    }\n    if (this._lastIceConnectionState !== 'failed' && iceConnectionState === 'failed' && !this._shouldRestartIce && !this._isRestartingIce) {\n      // Case 1: Transition to \"failed\".\n      log.warn('ICE failed');\n      this._initiateIceRestartBackoff();\n    } else if (['disconnected', 'failed'].includes(this._lastIceConnectionState) && isIceConnectedOrComplete) {\n      // Case 2: Transition from \"disconnected\" or \"failed\".\n      log.debug('ICE reconnected');\n    }\n    // start monitor media when connected, and continue to monitor while state is complete-disconnected-connected.\n    if (iceConnectionState === 'connected') {\n      this._isIceConnectionInactive = false;\n      this._iceConnectionMonitor.start(function () {\n        // note: iceConnection monitor waits for iceConnectionState=disconnected for\n        // detecting inactivity. Its possible that it may know about disconnected before _handleIceConnectionStateChange\n        _this._iceConnectionMonitor.stop();\n        if (!_this._shouldRestartIce && !_this._isRestartingIce) {\n          log.warn('ICE Connection Monitor detected inactivity');\n          _this._isIceConnectionInactive = true;\n          _this._initiateIceRestartBackoff();\n          _this.emit('iceConnectionStateChanged');\n          _this.emit('connectionStateChanged');\n        }\n      });\n    } else if (!['disconnected', 'completed'].includes(iceConnectionState)) {\n      // don't stop monitoring for disconnected or completed.\n      this._iceConnectionMonitor.stop();\n      this._isIceConnectionInactive = false;\n    }\n    this._lastIceConnectionState = iceConnectionState;\n    this.emit('iceConnectionStateChanged');\n  };\n  /**\n   * Handle ICE gathering timeout.\n   * @private\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype._handleIceGatheringTimeout = function () {\n    this._log.warn('ICE failed to gather any local candidates');\n    this._iceGatheringFailed = true;\n    this._initiateIceRestartBackoff();\n    this.emit('iceConnectionStateChanged');\n    this.emit('connectionStateChanged');\n  };\n  /**\n   * Handle an ICE gathering state change event.\n   * @private\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype._handleIceGatheringStateChange = function () {\n    var iceGatheringState = this._peerConnection.iceGatheringState;\n    var log = this._log;\n    log.debug(\"ICE gathering state is \\\"\" + iceGatheringState + \"\\\"\");\n    // NOTE(mmalavalli): Start the ICE gathering timeout only if the RTCPeerConnection\n    // has started gathering candidates for the first time since the initial offer/answer\n    // or an offer/answer with ICE restart.\n    var _a = this._iceGatheringTimeout,\n      delay = _a.delay,\n      isSet = _a.isSet;\n    if (iceGatheringState === 'gathering' && !this._didGenerateLocalCandidates && !isSet) {\n      log.debug(\"Starting ICE gathering timeout: \" + delay);\n      this._iceGatheringFailed = false;\n      this._iceGatheringTimeout.start();\n    }\n  };\n  /**\n   * Handle a signaling state change event.\n   * @private\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype._handleSignalingStateChange = function () {\n    if (this._peerConnection.signalingState === 'stable') {\n      this._appliedTrackIdsToAttributes = new Map(this._trackIdsToAttributes);\n    }\n  };\n  /**\n   * Handle a track event.\n   * @private\n   * @param {RTCTrackEvent} event\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype._handleTrackEvent = function (event) {\n    var _this = this;\n    var sdp = this._peerConnection.remoteDescription ? this._peerConnection.remoteDescription.sdp : null;\n    this._trackMatcher = this._trackMatcher || new TrackMatcher();\n    this._trackMatcher.update(sdp);\n    var mediaStreamTrack = event.track;\n    var signaledTrackId = this._trackMatcher.match(event) || mediaStreamTrack.id;\n    var mediaTrackReceiver = new MediaTrackReceiver(signaledTrackId, mediaStreamTrack);\n    // NOTE(mmalavalli): \"ended\" is not fired on the remote MediaStreamTrack when\n    // the remote peer removes a track. So, when this MediaStreamTrack is re-used\n    // for a different track due to the remote peer calling RTCRtpSender.replaceTrack(),\n    // we delete the previous MediaTrackReceiver that owned this MediaStreamTrack\n    // before adding the new MediaTrackReceiver.\n    this._mediaTrackReceivers.forEach(function (trackReceiver) {\n      if (trackReceiver.track.id === mediaTrackReceiver.track.id) {\n        _this._mediaTrackReceivers.delete(trackReceiver);\n      }\n    });\n    this._mediaTrackReceivers.add(mediaTrackReceiver);\n    mediaStreamTrack.addEventListener('ended', function () {\n      return _this._mediaTrackReceivers.delete(mediaTrackReceiver);\n    });\n    this.emit('trackAdded', mediaTrackReceiver);\n  };\n  /**\n   * Initiate ICE Restart.\n   * @private\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype._initiateIceRestart = function () {\n    if (this._peerConnection.signalingState === 'closed') {\n      return;\n    }\n    var log = this._log;\n    log.warn('Attempting to restart ICE');\n    this._didGenerateLocalCandidates = false;\n    this._isIceRestartBackoffInProgress = false;\n    this._shouldRestartIce = true;\n    var _a = this._iceReconnectTimeout,\n      delay = _a.delay,\n      isSet = _a.isSet;\n    if (!isSet) {\n      log.debug(\"Starting ICE reconnect timeout: \" + delay);\n      this._iceReconnectTimeout.start();\n    }\n    this.offer().catch(function (ex) {\n      log.error(\"offer failed in _initiateIceRestart with: \" + ex.message);\n    });\n  };\n  /**\n   * Schedule an ICE Restart.\n   * @private\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype._initiateIceRestartBackoff = function () {\n    var _this = this;\n    if (this._peerConnection.signalingState === 'closed' || this._isIceRestartBackoffInProgress) {\n      return;\n    }\n    this._log.warn('An ICE restart has been scheduled');\n    this._isIceRestartBackoffInProgress = true;\n    this._iceRestartBackoff.backoff(function () {\n      return _this._initiateIceRestart();\n    });\n  };\n  /**\n   * Conditionally re-offer.\n   * @private\n   * @param {?RTCSessionDescriptionInit} localDescription\n   * @returns {Promise<boolean>}\n   */\n  PeerConnectionV2.prototype._maybeReoffer = function (localDescription) {\n    var shouldReoffer = this._shouldOffer;\n    if (localDescription && localDescription.sdp) {\n      // NOTE(mmalavalli): If the local RTCSessionDescription has fewer audio and/or\n      // video send* m= lines than the corresponding RTCRtpSenders with non-null\n      // MediaStreamTracks, it means that the newly added RTCRtpSenders require\n      // renegotiation.\n      var senders_1 = this._peerConnection.getSenders().filter(function (sender) {\n        return sender.track;\n      });\n      shouldReoffer = ['audio', 'video'].reduce(function (shouldOffer, kind) {\n        var mediaSections = getMediaSections(localDescription.sdp, kind, '(sendrecv|sendonly)');\n        var sendersOfKind = senders_1.filter(isSenderOfKind.bind(null, kind));\n        return shouldOffer || mediaSections.length < sendersOfKind.length;\n      }, shouldReoffer);\n      // NOTE(mroberts): We also need to re-offer if we have a DataTrack to share\n      // but no m= application section.\n      var hasDataTrack = this._dataChannels.size > 0;\n      var hasApplicationMediaSection = getMediaSections(localDescription.sdp, 'application').length > 0;\n      var needsApplicationMediaSection = hasDataTrack && !hasApplicationMediaSection;\n      shouldReoffer = shouldReoffer || needsApplicationMediaSection;\n    }\n    var promise = shouldReoffer ? this._offer() : Promise.resolve();\n    return promise.then(function () {\n      return shouldReoffer;\n    });\n  };\n  /**\n   * Create an offer and set it on the {@link PeerConnectionV2}.\n   * @private\n   * @returns {Promise<void>}\n   */\n  PeerConnectionV2.prototype._offer = function () {\n    var _this = this;\n    var offerOptions = Object.assign({}, this._offerOptions);\n    this._needsAnswer = true;\n    if (this._shouldRestartIce) {\n      this._shouldRestartIce = false;\n      this._isRestartingIce = true;\n      offerOptions.iceRestart = true;\n    }\n    return Promise.all(this._replaceTrackPromises.values()).then(function () {\n      return _this._peerConnection.createOffer(offerOptions);\n    }).catch(function (error) {\n      var errorToThrow = new MediaClientLocalDescFailedError();\n      _this._publishMediaWarning({\n        message: 'Failed to create offer',\n        code: errorToThrow.code,\n        error: error\n      });\n      throw errorToThrow;\n    }).then(function (offer) {\n      if (isFirefox) {\n        // NOTE(mmalavalli): We work around Chromium bug 1106157 by disabling\n        // RTX in Firefox 79+. For more details about the bug, please go here:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1106157\n        offer = new _this._RTCSessionDescription({\n          sdp: disableRtx(offer.sdp),\n          type: offer.type\n        });\n      } else {\n        offer = workaroundIssue8329(offer);\n      }\n      // NOTE(mpatwardhan): upcoming chrome versions are going to remove ssrc attributes\n      // mslabel and label. See this bug https://bugs.chromium.org/p/webrtc/issues/detail?id=7110\n      // and PSA: https://groups.google.com/forum/#!searchin/discuss-webrtc/PSA%7Csort:date/discuss-webrtc/jcZO-Wj0Wus/k2XvPCvoAwAJ\n      // Looks like we are not referencing those attributes, but this changes goes ahead and removes them to see if it works.\n      // this also helps reduce bytes on wires\n      var sdp = removeSSRCAttributes(offer.sdp, ['mslabel', 'label']);\n      sdp = _this._peerConnection.remoteDescription ? filterLocalCodecs(sdp, _this._peerConnection.remoteDescription.sdp) : sdp;\n      var updatedSdp = _this._setCodecPreferences(sdp, _this._preferredAudioCodecs, _this._preferredVideoCodecs);\n      _this._shouldOffer = false;\n      if (!_this._negotiationRole) {\n        _this._negotiationRole = 'offerer';\n      }\n      if (_this._shouldApplySimulcast) {\n        _this._localDescriptionWithoutSimulcast = {\n          type: 'offer',\n          sdp: updatedSdp\n        };\n        updatedSdp = _this._setSimulcast(updatedSdp, _this._trackIdsToAttributes);\n      }\n      return _this._setLocalDescription({\n        type: 'offer',\n        sdp: updatedSdp\n      });\n    });\n  };\n  /**\n   * Get the MediaTrackSender ID of the given MediaStreamTrack ID.\n   * Since a MediaTrackSender's underlying MediaStreamTrack can be\n   * replaced, the corresponding IDs can mismatch.\n   * @private\n   * @param {Track.ID} id\n   * @returns {Track.ID}\n   */\n  PeerConnectionV2.prototype._getMediaTrackSenderId = function (trackId) {\n    var mediaTrackSender = Array.from(this._rtpSenders.keys()).find(function (_a) {\n      var id = _a.track.id;\n      return id === trackId;\n    });\n    return mediaTrackSender ? mediaTrackSender.id : trackId;\n  };\n  /**\n   * Add or rewrite local MediaStreamTrack IDs in the given RTCSessionDescription.\n   * @private\n   * @param {RTCSessionDescription} description\n   * @return {RTCSessionDescription}\n   */\n  PeerConnectionV2.prototype._addOrRewriteLocalTrackIds = function (description) {\n    var _this = this;\n    var transceivers = this._peerConnection.getTransceivers();\n    var activeTransceivers = transceivers.filter(function (_a) {\n      var sender = _a.sender,\n        stopped = _a.stopped;\n      return !stopped && sender && sender.track;\n    });\n    // NOTE(mmalavalli): There is no guarantee that MediaStreamTrack IDs will be present in\n    // SDPs, and even if they are, there is no guarantee that they will be the same as the\n    // actual MediaStreamTrack IDs. So, we add or re-write the actual MediaStreamTrack IDs\n    // to the assigned m= sections here.\n    var assignedTransceivers = activeTransceivers.filter(function (_a) {\n      var mid = _a.mid;\n      return mid;\n    });\n    var midsToTrackIds = new Map(assignedTransceivers.map(function (_a) {\n      var mid = _a.mid,\n        sender = _a.sender;\n      return [mid, _this._getMediaTrackSenderId(sender.track.id)];\n    }));\n    var sdp1 = addOrRewriteTrackIds(description.sdp, midsToTrackIds);\n    // NOTE(mmalavalli): Chrome and Safari do not apply the offer until they get an answer.\n    // So, we add or re-write the actual MediaStreamTrack IDs to the unassigned m= sections here.\n    var unassignedTransceivers = activeTransceivers.filter(function (_a) {\n      var mid = _a.mid;\n      return !mid;\n    });\n    var newTrackIdsByKind = new Map(['audio', 'video'].map(function (kind) {\n      return [kind, unassignedTransceivers.filter(function (_a) {\n        var sender = _a.sender;\n        return sender.track.kind === kind;\n      }).map(function (_a) {\n        var sender = _a.sender;\n        return _this._getMediaTrackSenderId(sender.track.id);\n      })];\n    }));\n    var sdp2 = addOrRewriteNewTrackIds(sdp1, midsToTrackIds, newTrackIdsByKind);\n    return new this._RTCSessionDescription({\n      sdp: sdp2,\n      type: description.type\n    });\n  };\n  /**\n   * Rollback and apply the given offer.\n   * @private\n   * @param {RTCSessionDescriptionInit} offer\n   * @returns {Promise<void>}\n   */\n  PeerConnectionV2.prototype._rollbackAndApplyOffer = function (offer) {\n    var _this = this;\n    return this._setLocalDescription({\n      type: 'rollback'\n    }).then(function () {\n      return _this._setLocalDescription(offer);\n    });\n  };\n  /**\n   * Set a local description on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescription|RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n  PeerConnectionV2.prototype._setLocalDescription = function (description) {\n    var _this = this;\n    if (description.type !== 'rollback' && this._shouldApplyDtx) {\n      description = new this._RTCSessionDescription({\n        sdp: enableDtxForOpus(description.sdp),\n        type: description.type\n      });\n    }\n    return this._peerConnection.setLocalDescription(description).catch(function (error) {\n      _this._log.warn(\"Calling setLocalDescription with an RTCSessionDescription of type \\\"\" + description.type + \"\\\" failed with the error \\\"\" + error.message + \"\\\".\", error);\n      var errorToThrow = new MediaClientLocalDescFailedError();\n      var publishWarning = {\n        message: \"Calling setLocalDescription with an RTCSessionDescription of type \\\"\" + description.type + \"\\\" failed\",\n        code: errorToThrow.code,\n        error: error\n      };\n      if (description.sdp) {\n        _this._log.warn(\"The SDP was \" + description.sdp);\n        publishWarning.sdp = description.sdp;\n      }\n      _this._publishMediaWarning(publishWarning);\n      throw errorToThrow;\n    }).then(function () {\n      if (description.type !== 'rollback') {\n        _this._localDescription = _this._addOrRewriteLocalTrackIds(description);\n        // NOTE(mmalavalli): In order for this feature to be backward compatible with older\n        // SDK versions which to not support opus DTX, we append \"usedtx=1\" to the local SDP\n        // only while applying it. We will not send it over the wire to prevent inadvertent\n        // enabling of opus DTX in older SDKs. Newer SDKs will append \"usedtx=1\" by themselves\n        // if the developer has requested opus DTX to be enabled. (JSDK-3063)\n        if (_this._shouldApplyDtx) {\n          _this._localDescription = new _this._RTCSessionDescription({\n            sdp: enableDtxForOpus(_this._localDescription.sdp, []),\n            type: _this._localDescription.type\n          });\n        }\n        _this._localCandidates = [];\n        if (description.type === 'offer') {\n          _this._descriptionRevision++;\n        } else if (description.type === 'answer') {\n          _this._lastStableDescriptionRevision = _this._descriptionRevision;\n          negotiationCompleted(_this);\n        }\n        _this._localUfrag = getUfrag(description);\n        _this.emit('description', _this.getState());\n      }\n    });\n  };\n  /**\n   * Set a remote RTCSessionDescription on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n  PeerConnectionV2.prototype._setRemoteDescription = function (description) {\n    var _this = this;\n    if (description.sdp) {\n      description.sdp = this._setCodecPreferences(description.sdp, this._preferredAudioCodecs, this._preferredVideoCodecs);\n      if (this._shouldApplyDtx) {\n        description.sdp = enableDtxForOpus(description.sdp);\n      } else {\n        // NOTE(mmalavalli): Remove \"usedtx=1\" from opus's fmtp line if present\n        // since DTX is disabled.\n        description.sdp = enableDtxForOpus(description.sdp, []);\n      }\n      if (isFirefox) {\n        // NOTE(mroberts): Do this to reduce our MediaStream count in Firefox. By\n        // mapping MediaStream IDs in the SDP to \"-\", we ensure the \"track\" event\n        // doesn't include any new MediaStreams in Firefox. Its `streams` member\n        // will always be the empty Array.\n        description.sdp = filterOutMediaStreamIds(description.sdp);\n      }\n      if (!this._peerConnection.remoteDescription) {\n        this._isIceLite = /a=ice-lite/.test(description.sdp);\n      }\n    }\n    description = new this._RTCSessionDescription(description);\n    // eslint-disable-next-line consistent-return\n    return Promise.resolve().then(function () {\n      // NOTE(syerrapragada): VMS does not support H264 simulcast. So,\n      // unset simulcast for sections in local offer where corresponding\n      // sections in answer doesn't have vp8 as preferred codec and reapply offer.\n      if (description.type === 'answer' && _this._localDescriptionWithoutSimulcast) {\n        // NOTE(mpatwardhan):if we were using adaptive simulcast, and if its not supported by server\n        // revert simulcast even for vp8.\n        var adaptiveSimulcastEntry = _this._preferredVideoCodecs.find(function (cs) {\n          return 'adaptiveSimulcast' in cs;\n        });\n        var revertForAll = !!adaptiveSimulcastEntry && adaptiveSimulcastEntry.adaptiveSimulcast === false;\n        var sdpWithoutSimulcastForNonVP8MediaSections = _this._revertSimulcast(_this._localDescription.sdp, _this._localDescriptionWithoutSimulcast.sdp, description.sdp, revertForAll);\n        _this._localDescriptionWithoutSimulcast = null;\n        if (sdpWithoutSimulcastForNonVP8MediaSections !== _this._localDescription.sdp) {\n          return _this._rollbackAndApplyOffer({\n            type: _this._localDescription.type,\n            sdp: sdpWithoutSimulcastForNonVP8MediaSections\n          });\n        }\n      }\n    }).then(function () {\n      return _this._peerConnection.setRemoteDescription(description);\n    }).then(function () {\n      if (description.type === 'answer') {\n        if (_this._isRestartingIce) {\n          _this._log.debug('An ICE restart was in-progress and is now completed');\n          _this._isRestartingIce = false;\n        }\n        negotiationCompleted(_this);\n      }\n    }, function (error) {\n      _this._log.warn(\"Calling setRemoteDescription with an RTCSessionDescription of type \\\"\" + description.type + \"\\\" failed with the error \\\"\" + error.message + \"\\\".\", error);\n      if (description.sdp) {\n        _this._log.warn(\"The SDP was \" + description.sdp);\n      }\n      throw error;\n    });\n  };\n  /**\n   * Update the {@link PeerConnectionV2}'s description.\n   * @private\n   * @param {RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n  PeerConnectionV2.prototype._updateDescription = function (description) {\n    var _this = this;\n    switch (description.type) {\n      case 'answer':\n      case 'pranswer':\n        if (description.revision !== this._descriptionRevision || this._peerConnection.signalingState !== 'have-local-offer') {\n          return Promise.resolve();\n        }\n        this._descriptionRevision = description.revision;\n        break;\n      case 'close':\n        return this._close();\n      case 'create-offer':\n        if (description.revision <= this._lastStableDescriptionRevision) {\n          return Promise.resolve();\n        } else if (this._needsAnswer) {\n          this._queuedDescription = description;\n          return Promise.resolve();\n        }\n        this._descriptionRevision = description.revision;\n        return this._offer();\n      case 'offer':\n        if (description.revision <= this._lastStableDescriptionRevision || this._peerConnection.signalingState === 'closed') {\n          return Promise.resolve();\n        }\n        if (this._peerConnection.signalingState === 'have-local-offer') {\n          // NOTE(mpatwardhan): For a peer connection\n          // 1) createOffer always generate SDP with `setup:actpass`\n          // 2) when remote description is set `setup:active`  - the answer generated selects the dtls role of setup:passive\n          // 3) when remote description is set `setup:passive` - the answer generated selects the dtls role of setup:active\n          // 4) when remote description is set `setup:actpass` - the answer generated uses the previously negotiated role (if not negotiated previously setup:active is used)\n          // This test shows the  behavior: https://github.com/twilio/twilio-webrtc.js/blob/master/test/integration/spec/rtcpeerconnection.js#L936\n          // with glare handling (if dtls role was not negotiated before ) the generated answer will set setup:active.\n          // we do not want that. lets wait for \"initial negotiation\" before attempting glare handling.\n          if (this._needsAnswer && this._lastStableDescriptionRevision === 0) {\n            this._queuedDescription = description;\n            return Promise.resolve();\n          }\n          this._descriptionRevision = description.revision;\n          return this._handleGlare(description);\n        }\n        this._descriptionRevision = description.revision;\n        return this._answer(description).then(function () {});\n      default:\n      // Do nothing.\n    }\n    // Handle answer or pranswer.\n    var revision = description.revision;\n    return Promise.resolve().then(function () {\n      return _this._setRemoteDescription(description);\n    }).catch(function (error) {\n      var errorToThrow = new MediaClientRemoteDescFailedError();\n      _this._publishMediaWarning({\n        message: \"Calling setRemoteDescription with an RTCSessionDescription of type \\\"\" + description.type + \"\\\" failed\",\n        code: errorToThrow.code,\n        error: error,\n        sdp: description.sdp\n      });\n      throw errorToThrow;\n    }).then(function () {\n      _this._lastStableDescriptionRevision = revision;\n      _this._needsAnswer = false;\n      return _this._checkIceBox(description);\n    }).then(function () {\n      return _this._queuedDescription && _this._updateDescription(_this._queuedDescription);\n    }).then(function () {\n      _this._queuedDescription = null;\n      return _this._maybeReoffer(_this._peerConnection.localDescription).then(function () {});\n    });\n  };\n  /**\n   * Update the {@link PeerConnectionV2}'s ICE candidates.\n   * @private\n   * @param {object} iceState\n   * @returns {Promise<void>}\n   */\n  PeerConnectionV2.prototype._updateIce = function (iceState) {\n    var candidates = this._remoteCandidates.update(iceState);\n    return this._addIceCandidates(candidates);\n  };\n  /**\n   * Add a {@link DataTrackSender} to the {@link PeerConnectionV2}.\n   * @param {DataTrackSender} dataTrackSender\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype.addDataTrackSender = function (dataTrackSender) {\n    if (this._dataChannels.has(dataTrackSender)) {\n      return;\n    }\n    try {\n      var dataChannelDict = {\n        ordered: dataTrackSender.ordered\n      };\n      if (dataTrackSender.maxPacketLifeTime !== null) {\n        dataChannelDict.maxPacketLifeTime = dataTrackSender.maxPacketLifeTime;\n      }\n      if (dataTrackSender.maxRetransmits !== null) {\n        dataChannelDict.maxRetransmits = dataTrackSender.maxRetransmits;\n      }\n      var dataChannel = this._peerConnection.createDataChannel(dataTrackSender.id, dataChannelDict);\n      dataTrackSender.addDataChannel(dataChannel);\n      this._dataChannels.set(dataTrackSender, dataChannel);\n    } catch (error) {\n      this._log.warn(\"Error creating an RTCDataChannel for DataTrack \\\"\" + dataTrackSender.id + \"\\\": \" + error.message);\n    }\n  };\n  PeerConnectionV2.prototype._handleQueuedPublisherHints = function () {\n    var _this = this;\n    if (this._peerConnection.signalingState === 'stable') {\n      this._mediaTrackSenderToPublisherHints.forEach(function (_a, mediaTrackSender) {\n        var deferred = _a.deferred,\n          encodings = _a.encodings;\n        _this._mediaTrackSenderToPublisherHints.delete(mediaTrackSender);\n        _this._setPublisherHint(mediaTrackSender, encodings).then(function (result) {\n          return deferred.resolve(result);\n        }).catch(function (error) {\n          return deferred.reject(error);\n        });\n      });\n    }\n  };\n  /**\n   * updates encodings for simulcast layers of given sender.\n   * @param {RTCRtpSender} sender\n   * @param {Array<{enabled: boolean, layer_index: number}>|null} encodings\n   * @returns {Promise<string>} string indicating result of the operation. can be one of\n   *  \"OK\", \"INVALID_HINT\", \"COULD_NOT_APPLY_HINT\", \"UNKNOWN_TRACK\"\n   */\n  PeerConnectionV2.prototype._setPublisherHint = function (mediaTrackSender, encodings) {\n    var _this = this;\n    if (isFirefox) {\n      return Promise.resolve('COULD_NOT_APPLY_HINT');\n    }\n    if (this._mediaTrackSenderToPublisherHints.has(mediaTrackSender)) {\n      // skip any stale hint associated with the mediaTrackSender.\n      var queuedHint = this._mediaTrackSenderToPublisherHints.get(mediaTrackSender);\n      queuedHint.deferred.resolve('REQUEST_SKIPPED');\n      this._mediaTrackSenderToPublisherHints.delete(mediaTrackSender);\n    }\n    var sender = this._rtpSenders.get(mediaTrackSender);\n    if (!sender) {\n      this._log.warn('Could not apply publisher hint because RTCRtpSender was not found');\n      return Promise.resolve('UNKNOWN_TRACK');\n    }\n    if (this._peerConnection.signalingState === 'closed') {\n      this._log.warn('Could not apply publisher hint because signalingState was \"closed\"');\n      return Promise.resolve('COULD_NOT_APPLY_HINT');\n    }\n    if (this._peerConnection.signalingState !== 'stable') {\n      // enqueue this hint to be applied when pc becomes stable.\n      this._log.debug('Queuing up publisher hint because signalingState:', this._peerConnection.signalingState);\n      var deferred = defer();\n      this._mediaTrackSenderToPublisherHints.set(mediaTrackSender, {\n        deferred: deferred,\n        encodings: encodings\n      });\n      return deferred.promise;\n    }\n    var parameters = sender.getParameters();\n    if (encodings !== null) {\n      encodings.forEach(function (_a) {\n        var enabled = _a.enabled,\n          layerIndex = _a.layer_index;\n        if (parameters.encodings.length > layerIndex) {\n          _this._log.debug(\"layer:\" + layerIndex + \", active:\" + parameters.encodings[layerIndex].active + \" => \" + enabled);\n          parameters.encodings[layerIndex].active = enabled;\n        } else {\n          _this._log.warn(\"invalid layer:\" + layerIndex + \", active:\" + enabled);\n        }\n      });\n    }\n    // Note(mpatwardhan): after publisher hints are applied, overwrite with default encodings\n    // to disable any encoding that shouldn't have been enabled by publisher_hints.\n    // When encodings===null (that is we are asked to reset encodings for replaceTrack)\n    // along with disabling encodings, clear active flag for encodings that should not be disabled\n    this._maybeUpdateEncodings(sender.track, parameters.encodings, encodings === null /* trackReplaced */);\n    return sender.setParameters(parameters).then(function () {\n      return 'OK';\n    }).catch(function (error) {\n      _this._log.error('Failed to apply publisher hints:', error);\n      return 'COULD_NOT_APPLY_HINT';\n    });\n  };\n  /**\n   * Add the {@link MediaTrackSender} to the {@link PeerConnectionV2}.\n   * @param {MediaTrackSender} mediaTrackSender\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype.addMediaTrackSender = function (mediaTrackSender) {\n    var _this = this;\n    if (this._peerConnection.signalingState === 'closed' || this._rtpSenders.has(mediaTrackSender)) {\n      return;\n    }\n    var transceiver = this._addOrUpdateTransceiver(mediaTrackSender.track);\n    var sender = transceiver.sender;\n    mediaTrackSender.addSender(sender, function (encodings) {\n      return _this._setPublisherHint(mediaTrackSender, encodings);\n    });\n    this._rtpNewSenders.add(sender);\n    this._rtpSenders.set(mediaTrackSender, sender);\n  };\n  /**\n   * Close the {@link PeerConnectionV2}.\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype.close = function () {\n    if (this._close()) {\n      this._descriptionRevision++;\n      this._localDescription = {\n        type: 'close'\n      };\n      this.emit('description', this.getState());\n    }\n  };\n  /**\n   * Get the {@link DataTrackReceiver}s and the {@link MediaTrackReceiver}s on the\n   * {@link PeerConnectionV2}.\n   * @returns {Array<DataTrackReceiver|MediaTrackReceiver>} trackReceivers\n   */\n  PeerConnectionV2.prototype.getTrackReceivers = function () {\n    return Array.from(this._dataTrackReceivers).concat(Array.from(this._mediaTrackReceivers));\n  };\n  /**\n   * Get the {@link PeerConnectionV2}'s state (specifically, its description).\n   * @returns {?object}\n   */\n  PeerConnectionV2.prototype.getState = function () {\n    if (!this._localDescription) {\n      return null;\n    }\n    // NOTE(mpatwardhan): Return most recent localDescription. If the most recent local description is an\n    // answer, and this method is called for sending a \"sync\" message while the next remote offer is being processed,\n    // we need to send the most recent stable description revision instead of the current description revision,\n    // which is supposed to be for the next local answer.\n    var localDescriptionRevision = this._localDescription.type === 'answer' ? this._lastStableDescriptionRevision : this._descriptionRevision;\n    var localDescription = {\n      type: this._localDescription.type,\n      revision: localDescriptionRevision\n    };\n    if (this._localDescription.sdp) {\n      localDescription.sdp = this._localDescription.sdp;\n    }\n    return {\n      description: localDescription,\n      id: this.id\n    };\n  };\n  /**\n   * Create an offer and set it on the {@link PeerConnectionV2}.\n   * @returns {Promise<void>}\n   */\n  PeerConnectionV2.prototype.offer = function () {\n    var _this = this;\n    if (this._needsAnswer || this._isRestartingIce) {\n      this._shouldOffer = true;\n      return Promise.resolve();\n    }\n    return this.bracket('offering', function (key) {\n      _this.transition('updating', key);\n      var promise = _this._needsAnswer || _this._isRestartingIce ? Promise.resolve() : _this._offer();\n      return promise.then(function () {\n        _this.tryTransition('open', key);\n      }, function (error) {\n        _this.tryTransition('open', key);\n        throw error;\n      });\n    });\n  };\n  /**\n   * Remove a {@link DataTrackSender} from the {@link PeerConnectionV2}.\n   * @param {DataTrackSender} dataTrackSender\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype.removeDataTrackSender = function (dataTrackSender) {\n    var dataChannel = this._dataChannels.get(dataTrackSender);\n    if (dataChannel) {\n      dataTrackSender.removeDataChannel(dataChannel);\n      this._dataChannels.delete(dataTrackSender);\n      dataChannel.close();\n    }\n  };\n  /**\n   * Remove the {@link MediaTrackSender} from the {@link PeerConnectionV2}.\n   * @param {MediaTrackSender} mediaTrackSender\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype.removeMediaTrackSender = function (mediaTrackSender) {\n    var sender = this._rtpSenders.get(mediaTrackSender);\n    if (!sender) {\n      return;\n    }\n    if (this._peerConnection.signalingState !== 'closed') {\n      this._peerConnection.removeTrack(sender);\n    }\n    mediaTrackSender.removeSender(sender);\n    // clean up any pending publisher hints associated with this mediaTrackSender.\n    if (this._mediaTrackSenderToPublisherHints.has(mediaTrackSender)) {\n      var queuedHint = this._mediaTrackSenderToPublisherHints.get(mediaTrackSender);\n      queuedHint.deferred.resolve('UNKNOWN_TRACK');\n      this._mediaTrackSenderToPublisherHints.delete(mediaTrackSender);\n    }\n    this._rtpNewSenders.delete(sender);\n    this._rtpSenders.delete(mediaTrackSender);\n  };\n  /**\n   * Set the RTCConfiguration on the underlying RTCPeerConnection.\n   * @param {RTCConfiguration} configuration\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype.setConfiguration = function (configuration) {\n    if (typeof this._peerConnection.setConfiguration === 'function') {\n      this._peerConnection.setConfiguration(getConfiguration(configuration));\n    }\n  };\n  /**\n   * Set the ICE reconnect timeout period.\n   * @param {number} period - Period in milliseconds.\n   * @returns {this}\n   */\n  PeerConnectionV2.prototype.setIceReconnectTimeout = function (period) {\n    this._iceReconnectTimeout.setDelay(period);\n    this._log.debug('Updated ICE reconnection timeout period:', this._iceReconnectTimeout.delay);\n    return this;\n  };\n  /**\n   * Update the {@link PeerConnectionV2}.\n   * @param {object} peerConnectionState\n   * @returns {Promise<void>}\n   */\n  PeerConnectionV2.prototype.update = function (peerConnectionState) {\n    var _this = this;\n    return this.bracket('updating', function (key) {\n      if (_this.state === 'closed') {\n        return Promise.resolve();\n      }\n      _this.transition('updating', key);\n      var updates = [];\n      if (peerConnectionState.ice) {\n        updates.push(_this._updateIce(peerConnectionState.ice));\n      }\n      if (peerConnectionState.description) {\n        updates.push(_this._updateDescription(peerConnectionState.description));\n      }\n      return Promise.all(updates).then(function () {\n        _this.tryTransition('open', key);\n      }, function (error) {\n        _this.tryTransition('open', key);\n        throw error;\n      });\n    });\n  };\n  /**\n   * Get the {@link PeerConnectionV2}'s media statistics.\n   * @returns {Promise<StandardizedStatsResponse>}\n   */\n  PeerConnectionV2.prototype.getStats = function () {\n    var _this = this;\n    return getStatistics(this._peerConnection).then(function (response) {\n      return rewriteTrackIds(_this, response);\n    });\n  };\n  return PeerConnectionV2;\n}(StateMachine);\nfunction rewriteLocalTrackId(pcv2, stats) {\n  var trackId = pcv2._getMediaTrackSenderId(stats.trackId);\n  return Object.assign(stats, {\n    trackId: trackId\n  });\n}\nfunction rewriteTrackId(pcv2, stats) {\n  var receiver = __spreadArray([], __read(pcv2._mediaTrackReceivers)).find(function (receiver) {\n    return receiver.track.id === stats.trackId;\n  });\n  var trackId = receiver ? receiver.id : null;\n  return Object.assign(stats, {\n    trackId: trackId\n  });\n}\nfunction rewriteTrackIds(pcv2, response) {\n  return Object.assign(response, {\n    remoteAudioTrackStats: response.remoteAudioTrackStats.map(function (stats) {\n      return rewriteTrackId(pcv2, stats);\n    }),\n    remoteVideoTrackStats: response.remoteVideoTrackStats.map(function (stats) {\n      return rewriteTrackId(pcv2, stats);\n    }),\n    localAudioTrackStats: response.localAudioTrackStats.map(function (stats) {\n      return rewriteLocalTrackId(pcv2, stats);\n    }),\n    localVideoTrackStats: response.localVideoTrackStats.map(function (stats) {\n      return rewriteLocalTrackId(pcv2, stats);\n    })\n  });\n}\n/**\n * @event PeerConnectionV2#candidates\n * @param {object} candidates\n */\n/**\n * @event PeerConnectionV2#connectionStateChanged\n */\n/**\n * @event PeerConnectionV2#description\n * @param {object} description\n */\n/**\n * @event PeerConnectionV2#iceConnectionStateChanged\n */\n/**\n * @event PeerConnectionV2#trackAdded\n * @param {DataTrackReceiver|MediaTrackReceiver} trackReceiver\n */\nfunction getUfrag(description) {\n  if (description.sdp) {\n    var match = description.sdp.match(/^a=ice-ufrag:([a-zA-Z0-9+/]+)/m);\n    if (match) {\n      return match[1];\n    }\n  }\n  return null;\n}\nfunction getConfiguration(configuration) {\n  return Object.assign({\n    bundlePolicy: 'max-bundle',\n    rtcpMuxPolicy: 'require'\n  }, configuration);\n}\n/**\n * Whether the MediaStreamTrack of the given RTCRTPSender is a non-ended\n * MediaStreamTrack of a given kind.\n * @private\n * @param {string} kind\n * @param {RTCRtpSender} sender\n * @return {boolean}\n */\nfunction isSenderOfKind(kind, sender) {\n  var track = sender.track;\n  return track && track.kind === kind && track.readyState !== 'ended';\n}\n/**\n * Preferred codecs.\n * @typedef {object} PreferredCodecs\n * @property {Array<AudioCodec>} audio\n * @property {Array<VideoCodec>} video\n */\nfunction filterOutMediaStreamIds(sdp) {\n  return sdp.replace(/a=msid:[^ ]+ /g, 'a=msid:- ');\n}\n/**\n * Whether an RTCRtpTransceiver can be recycled.\n * @param {RTCRtpTransceiver} transceiver\n * @returns {boolean}\n */\nfunction shouldRecycleTransceiver(transceiver, pcv2) {\n  return !transceiver.stopped && !pcv2._replaceTrackPromises.has(transceiver) && ['inactive', 'recvonly'].includes(transceiver.direction);\n}\n/**\n * Take a recycled RTCRtpTransceiver if available.\n * @param {PeerConnectionV2} pcv2\n * @param {Track.Kind} kind\n * @returns {?RTCRtpTransceiver}\n */\nfunction takeRecycledTransceiver(pcv2, kind) {\n  var preferredCodecs = {\n    audio: pcv2._preferredAudioCodecs.map(function (_a) {\n      var codec = _a.codec;\n      return codec.toLowerCase();\n    }),\n    video: pcv2._preferredVideoCodecs.map(function (_a) {\n      var codec = _a.codec;\n      return codec.toLowerCase();\n    })\n  }[kind];\n  var recycledTransceivers = pcv2._recycledTransceivers[kind];\n  var localCodec = preferredCodecs.find(function (codec) {\n    return pcv2._localCodecs.has(codec);\n  });\n  if (!localCodec) {\n    return recycledTransceivers.shift();\n  }\n  var transceiver = recycledTransceivers.find(function (transceiver) {\n    var remoteCodecMap = pcv2._remoteCodecMaps.get(transceiver.mid);\n    return remoteCodecMap && remoteCodecMap.has(localCodec);\n  });\n  if (transceiver) {\n    recycledTransceivers.splice(recycledTransceivers.indexOf(transceiver), 1);\n  }\n  return transceiver;\n}\n/**\n * Update the set of locally supported {@link Codec}s.\n * @param pcv2\n * @returns {void}\n */\nfunction updateLocalCodecs(pcv2) {\n  var description = pcv2._peerConnection.localDescription;\n  if (!description || !description.sdp) {\n    return;\n  }\n  getMediaSections(description.sdp).forEach(function (section) {\n    var codecMap = createCodecMapForMediaSection(section);\n    codecMap.forEach(function (pts, codec) {\n      return pcv2._localCodecs.add(codec);\n    });\n  });\n}\n/**\n * Update the {@link Codec} maps for all m= sections in the remote {@link RTCSessionDescription}s.\n * @param {PeerConnectionV2} pcv2\n * @returns {void}\n */\nfunction updateRemoteCodecMaps(pcv2) {\n  var description = pcv2._peerConnection.remoteDescription;\n  if (!description || !description.sdp) {\n    return;\n  }\n  getMediaSections(description.sdp).forEach(function (section) {\n    var matched = section.match(/^a=mid:(.+)$/m);\n    if (!matched || !matched[1]) {\n      return;\n    }\n    var mid = matched[1];\n    var codecMap = createCodecMapForMediaSection(section);\n    pcv2._remoteCodecMaps.set(mid, codecMap);\n  });\n}\n/**\n * Update the list of recycled RTCRtpTransceivers.\n * @param {PeerConnectionV2} pcv2\n */\nfunction updateRecycledTransceivers(pcv2) {\n  pcv2._recycledTransceivers.audio = [];\n  pcv2._recycledTransceivers.video = [];\n  pcv2._peerConnection.getTransceivers().forEach(function (transceiver) {\n    if (shouldRecycleTransceiver(transceiver, pcv2)) {\n      var track = transceiver.receiver.track;\n      pcv2._recycledTransceivers[track.kind].push(transceiver);\n    }\n  });\n}\n/**\n * Perform certain updates after an SDP negotiation is completed.\n * @param {PeerConnectionV2} pcv2\n * @returns {void}\n */\nfunction negotiationCompleted(pcv2) {\n  updateRecycledTransceivers(pcv2);\n  updateLocalCodecs(pcv2);\n  updateRemoteCodecMaps(pcv2);\n  updateEncodingParameters(pcv2).then(function () {\n    // if there any any publisher hints queued, apply them now.\n    pcv2._handleQueuedPublisherHints();\n  });\n}\n/**\n * Update the RTCRtpEncodingParameters of all active RTCRtpSenders.\n * @param {PeerConnectionV2} pcv2\n * @returns {void}\n */\nfunction updateEncodingParameters(pcv2) {\n  var _a = pcv2._encodingParameters,\n    maxAudioBitrate = _a.maxAudioBitrate,\n    maxVideoBitrate = _a.maxVideoBitrate;\n  var maxBitrates = new Map([['audio', maxAudioBitrate], ['video', maxVideoBitrate]]);\n  var promises = [];\n  pcv2._peerConnection.getSenders().filter(function (sender) {\n    return sender.track;\n  }).forEach(function (sender) {\n    var maxBitrate = maxBitrates.get(sender.track.kind);\n    var params = sender.getParameters();\n    if (maxBitrate === null || maxBitrate === 0) {\n      removeMaxBitrate(params);\n    } else if (pcv2._isChromeScreenShareTrack(sender.track)) {\n      // NOTE(mpatwardhan): Sometimes (JSDK-2557) chrome does not send any bytes on screen track if MaxBitRate is set on it via setParameters,\n      // To workaround this issue we will not apply maxBitrate if the track appears to be a screen share track created by chrome\n      pcv2._log.warn(\"Not setting maxBitrate for \" + sender.track.kind + \" Track \" + sender.track.id + \" because it appears to be screen share track: \" + sender.track.label);\n    } else {\n      setMaxBitrate(params, maxBitrate);\n    }\n    if (!isFirefox && params.encodings.length > 0) {\n      if (sender.track.kind === 'audio') {\n        // NOTE(mmalavalli): \"priority\" is a per-sender property and not\n        // a per-encoding-layer property. So, we set the value only on the first\n        // encoding layer. Any attempt to set the value on subsequent encoding\n        // layers (in the case of simulcast) will result in the Promise returned\n        // by RTCRtpSender.setParameters() being rejected. With this, audio encoding\n        // is prioritized the most.\n        params.encodings[0].priority = 'high';\n      } else if (pcv2._isChromeScreenShareTrack(sender.track)) {\n        // NOTE(mmalavalli): Screen share encodings are prioritized more than those\n        // of the camera.\n        params.encodings[0].priority = 'medium';\n      }\n      if (pcv2._enableDscp) {\n        // NOTE(mmalavalli): \"networkPriority\" is a per-sender property and not\n        // a per-encoding-layer property. So, we set the value only on the first\n        // encoding layer. Any attempt to set the value on subsequent encoding\n        // layers (in the case of simulcast) will result in the Promise returned\n        // by RTCRtpSender.setParameters() being rejected.\n        params.encodings[0].networkPriority = 'high';\n      }\n    }\n    // when a sender is reused, delete any active encodings set by server.\n    var trackReplaced = pcv2._rtpNewSenders.has(sender);\n    pcv2._maybeUpdateEncodings(sender.track, params.encodings, trackReplaced);\n    pcv2._rtpNewSenders.delete(sender);\n    var promise = sender.setParameters(params).catch(function (error) {\n      pcv2._log.warn(\"Error while setting encodings parameters for \" + sender.track.kind + \" Track \" + sender.track.id + \": \" + (error.message || error.name));\n    });\n    promises.push(promise);\n  });\n  return Promise.all(promises);\n}\n/**\n * Remove maxBitrate from the RTCRtpSendParameters' encodings.\n * @param {RTCRtpSendParameters} params\n * @returns {void}\n */\nfunction removeMaxBitrate(params) {\n  if (Array.isArray(params.encodings)) {\n    params.encodings.forEach(function (encoding) {\n      return delete encoding.maxBitrate;\n    });\n  }\n}\n/**\n * Set the given maxBitrate in the RTCRtpSendParameters' encodings.\n * @param {RTCRtpSendParameters} params\n * @param {number} maxBitrate\n * @returns {void}\n */\nfunction setMaxBitrate(params, maxBitrate) {\n  if (isFirefox) {\n    params.encodings = [{\n      maxBitrate: maxBitrate\n    }];\n  } else {\n    params.encodings.forEach(function (encoding) {\n      encoding.maxBitrate = maxBitrate;\n    });\n  }\n}\nmodule.exports = PeerConnectionV2;","map":{"version":3,"names":["DefaultBackoff","require","_a","DefaultRTCIceCandidate","RTCIceCandidate","DefaultRTCPeerConnection","RTCPeerConnection","DefaultRTCSessionDescription","RTCSessionDescription","getStatistics","getStats","util","_b","DEFAULT_ICE_GATHERING_TIMEOUT_MS","DEFAULT_LOG_LEVEL","DEFAULT_SESSION_TIMEOUT_SEC","iceRestartBackoffConfig","_c","addOrRewriteNewTrackIds","addOrRewriteTrackIds","createCodecMapForMediaSection","disableRtx","enableDtxForOpus","filterLocalCodecs","getMediaSections","removeSSRCAttributes","revertSimulcast","setCodecPreferences","setSimulcast","DefaultTimeout","_d","MediaClientLocalDescFailedError","MediaClientRemoteDescFailedError","_e","buildLogLevels","getPlatform","isChromeScreenShareTrack","oncePerTick","defer","IceBox","DefaultIceConnectionMonitor","DataTrackReceiver","MediaTrackReceiver","StateMachine","Log","TrackMatcher","workaroundIssue8329","guess","guessBrowser","platform","isAndroid","test","isChrome","isFirefox","isSafari","nInstances","states","open","updating","closed","PeerConnectionV2","_super","__extends","id","encodingParameters","preferredCodecs","options","_this","call","Object","assign","enableDscp","dummyAudioMediaStreamTrack","iceServers","logLevel","offerOptions","sessionTimeout","Backoff","IceConnectionMonitor","Timeout","configuration","getConfiguration","logLevels","chromeSpecificConstraints","optional","push","googDscp","log","createLog","loggerName","peerConnection","addTrack","defineProperties","_appliedTrackIdsToAttributes","value","Map","writable","_dataChannels","_dataTrackReceivers","Set","_descriptionRevision","_didGenerateLocalCandidates","_enableDscp","_encodingParameters","_isChromeScreenShareTrack","_iceGatheringFailed","_iceGatheringTimeout","_handleIceGatheringTimeout","_iceRestartBackoff","_instanceId","_isIceConnectionInactive","_isIceLite","_isIceRestartBackoffInProgress","_isRestartingIce","_lastIceConnectionState","_lastStableDescriptionRevision","_localCandidates","_localCodecs","_localCandidatesRevision","_localDescriptionWithoutSimulcast","_localDescription","_localUfrag","_log","_eventObserver","eventObserver","_remoteCodecMaps","_rtpSenders","_rtpNewSenders","_iceConnectionMonitor","_mediaTrackReceivers","_needsAnswer","_negotiationRole","_offerOptions","_onEncodingParametersChanged","updateEncodingParameters","_peerConnection","_preferredAudioCodecs","audio","_preferredVideoCodecs","video","_shouldApplyDtx","every","codec","some","dtx","_queuedDescription","_iceReconnectTimeout","debug","close","_recycledTransceivers","_replaceTrackPromises","_remoteCandidates","_setCodecPreferences","toLowerCase","sdp","_setSimulcast","_revertSimulcast","_RTCIceCandidate","_RTCPeerConnection","_RTCSessionDescription","_shouldOffer","_shouldRestartIce","_trackIdsToAttributes","_trackMatcher","_mediaTrackSenderToPublisherHints","enumerable","on","addEventListener","_handleConnectionStateChange","bind","_handleDataChannelEvent","_handleIceCandidateEvent","_handleIceConnectionStateChange","_handleIceGatheringStateChange","_handleSignalingStateChange","_handleTrackEvent","self","stateChanged","state","removeListener","forEach","dataChannel","dataTrackSender","removeDataTrackSender","prototype","toString","setEffectiveAdaptiveSimulcast","effectiveAdaptiveSimulcast","cs","adaptiveSimulcast","defineProperty","get","simulcast","iceConnectionState","connectionState","signalingState","localDescription","length","adaptiveSimulcastEntry","find","_maybeUpdateEncodings","track","encodings","trackReplaced","kind","readyState","getSettings","height","width","browser","_isAdaptiveSimulcastEnabled","_updateEncodings","screenShareActiveLayerConfig_1","scaleResolutionDownBy","encoding","i","activeLayerConfig","active","pixelsToMaxActiveLayers","pixels","maxActiveLayers","trackPixels_1","activeLayersInfo","layer","activeLayers_1","Math","min","enabled","map","join","_addIceCandidate","candidate","Promise","resolve","then","addIceCandidate","catch","error","warn","message","_addIceCandidates","candidates","all","_addOrUpdateTransceiver","transceiver","takeRecycledTransceiver","sender","oldTrackId","mid","set","replaceTrack","direction","finally","delete","addTransceiver","_checkIceBox","description","ufrag","getUfrag","setUfrag","_answer","offer","_setRemoteDescription","createAnswer","answer","type","updatedSdp","_shouldApplySimulcast","sdpWithoutSimulcast","replace","_setLocalDescription","_updateDescription","_maybeReoffer","errorToThrow","_publishMediaWarning","code","_close","stop","preempt","emit","event","channel","dataTrackReceiver","add","_handleGlare","didReoffer","_offer","level","name","group","payload","context","JSON","stringify","clear","peerConnectionState","ice","slice","complete","revision","isIceConnectedOrComplete","includes","reset","_initiateIceRestartBackoff","start","iceGatheringState","delay","isSet","remoteDescription","update","mediaStreamTrack","signaledTrackId","match","mediaTrackReceiver","trackReceiver","_initiateIceRestart","ex","backoff","shouldReoffer","senders_1","getSenders","filter","reduce","shouldOffer","mediaSections","sendersOfKind","isSenderOfKind","hasDataTrack","size","hasApplicationMediaSection","needsApplicationMediaSection","promise","iceRestart","values","createOffer","_getMediaTrackSenderId","trackId","mediaTrackSender","Array","from","keys","_addOrRewriteLocalTrackIds","transceivers","getTransceivers","activeTransceivers","stopped","assignedTransceivers","midsToTrackIds","sdp1","unassignedTransceivers","newTrackIdsByKind","sdp2","_rollbackAndApplyOffer","setLocalDescription","publishWarning","negotiationCompleted","getState","filterOutMediaStreamIds","revertForAll","sdpWithoutSimulcastForNonVP8MediaSections","setRemoteDescription","_updateIce","iceState","addDataTrackSender","has","dataChannelDict","ordered","maxPacketLifeTime","maxRetransmits","createDataChannel","addDataChannel","_handleQueuedPublisherHints","deferred","_setPublisherHint","result","reject","queuedHint","parameters","getParameters","layerIndex","layer_index","setParameters","addMediaTrackSender","addSender","getTrackReceivers","concat","localDescriptionRevision","bracket","key","transition","tryTransition","removeDataChannel","removeMediaTrackSender","removeTrack","removeSender","setConfiguration","setIceReconnectTimeout","period","setDelay","updates","response","rewriteTrackIds","rewriteLocalTrackId","pcv2","stats","rewriteTrackId","receiver","__spreadArray","__read","remoteAudioTrackStats","remoteVideoTrackStats","localAudioTrackStats","localVideoTrackStats","bundlePolicy","rtcpMuxPolicy","shouldRecycleTransceiver","recycledTransceivers","localCodec","shift","remoteCodecMap","splice","indexOf","updateLocalCodecs","section","codecMap","pts","updateRemoteCodecMaps","matched","updateRecycledTransceivers","maxAudioBitrate","maxVideoBitrate","maxBitrates","promises","maxBitrate","params","removeMaxBitrate","label","setMaxBitrate","priority","networkPriority","isArray","module","exports"],"sources":["/home/denis/RiderProjects/ChatRoulette/WebUI/chat-app/node_modules/twilio-video/lib/signaling/v2/peerconnection.js"],"sourcesContent":["'use strict';\n\nconst DefaultBackoff = require('../../util/backoff');\nconst {\n  RTCIceCandidate: DefaultRTCIceCandidate,\n  RTCPeerConnection: DefaultRTCPeerConnection,\n  RTCSessionDescription: DefaultRTCSessionDescription,\n  getStats: getStatistics\n} = require('../../webrtc');\n\nconst util = require('../../webrtc/util');\n\nconst {\n  DEFAULT_ICE_GATHERING_TIMEOUT_MS,\n  DEFAULT_LOG_LEVEL,\n  DEFAULT_SESSION_TIMEOUT_SEC,\n  iceRestartBackoffConfig\n} = require('../../util/constants');\n\nconst {\n  addOrRewriteNewTrackIds,\n  addOrRewriteTrackIds,\n  createCodecMapForMediaSection,\n  disableRtx,\n  enableDtxForOpus,\n  filterLocalCodecs,\n  getMediaSections,\n  removeSSRCAttributes,\n  revertSimulcast,\n  setCodecPreferences,\n  setSimulcast\n} = require('../../util/sdp');\n\nconst DefaultTimeout = require('../../util/timeout');\n\nconst {\n  MediaClientLocalDescFailedError,\n  MediaClientRemoteDescFailedError\n} = require('../../util/twilio-video-errors');\n\nconst {\n  buildLogLevels,\n  getPlatform,\n  isChromeScreenShareTrack,\n  oncePerTick,\n  defer\n} = require('../../util');\n\nconst IceBox = require('./icebox');\nconst DefaultIceConnectionMonitor = require('./iceconnectionmonitor.js');\nconst DataTrackReceiver = require('../../data/receiver');\nconst MediaTrackReceiver = require('../../media/track/receiver');\nconst StateMachine = require('../../statemachine');\nconst Log = require('../../util/log');\nconst TrackMatcher = require('../../util/sdp/trackmatcher');\nconst workaroundIssue8329 = require('../../util/sdp/issue8329');\n\nconst guess = util.guessBrowser();\nconst platform = getPlatform();\nconst isAndroid = /android/.test(platform);\nconst isChrome = guess === 'chrome';\nconst isFirefox = guess === 'firefox';\nconst isSafari = guess === 'safari';\n\nlet nInstances = 0;\n\n/*\nPeerConnectionV2 States\n-----------------------\n\n    +------+    +--------+\n    |      |    |        |\n    | open |--->| closed |\n    |      |    |        |\n    +------+    +--------+\n      |  ^          ^\n      |  |          |\n      |  |          |\n      v  |          |\n  +----------+      |\n  |          |      |\n  | updating |------+\n  |          |\n  +----------+\n\n*/\n\nconst states = {\n  open: [\n    'closed',\n    'updating'\n  ],\n  updating: [\n    'closed',\n    'open'\n  ],\n  closed: []\n};\n\n/**\n * @extends StateMachine\n * @property {id}\n * @emits PeerConnectionV2#connectionStateChanged\n * @emits PeerConnectionV2#iceConnectionStateChanged\n * @emits PeerConnectionV2#candidates\n * @emits PeerConnectionV2#description\n */\nclass PeerConnectionV2 extends StateMachine {\n  /**\n   * Construct a {@link PeerConnectionV2}.\n   * @param {string} id\n   * @param {EncodingParametersImpl} encodingParameters\n   * @param {PreferredCodecs} preferredCodecs\n   * @param {object} [options]\n   */\n  constructor(id, encodingParameters, preferredCodecs, options) {\n    super('open', states);\n    options = Object.assign({\n      enableDscp: false,\n      dummyAudioMediaStreamTrack: null,\n      isChromeScreenShareTrack,\n      iceServers: [],\n      logLevel: DEFAULT_LOG_LEVEL,\n      offerOptions: {},\n      revertSimulcast,\n      sessionTimeout: DEFAULT_SESSION_TIMEOUT_SEC * 1000,\n      setCodecPreferences,\n      setSimulcast,\n      Backoff: DefaultBackoff,\n      IceConnectionMonitor: DefaultIceConnectionMonitor,\n      RTCIceCandidate: DefaultRTCIceCandidate,\n      RTCPeerConnection: DefaultRTCPeerConnection,\n      RTCSessionDescription: DefaultRTCSessionDescription,\n      Timeout: DefaultTimeout\n    }, options);\n\n    const configuration = getConfiguration(options);\n    const logLevels = buildLogLevels(options.logLevel);\n    const RTCPeerConnection = options.RTCPeerConnection;\n\n    if (options.enableDscp === true) {\n      options.chromeSpecificConstraints = options.chromeSpecificConstraints || {};\n      options.chromeSpecificConstraints.optional = options.chromeSpecificConstraints.optional || [];\n      options.chromeSpecificConstraints.optional.push({ googDscp: true });\n    }\n\n    const log = options.log ? options.log.createLog('webrtc', this) : new Log('webrtc', this, logLevels, options.loggerName);\n    const peerConnection = new RTCPeerConnection(configuration, options.chromeSpecificConstraints);\n\n    if (options.dummyAudioMediaStreamTrack) {\n      peerConnection.addTrack(options.dummyAudioMediaStreamTrack);\n    }\n\n    Object.defineProperties(this, {\n      _appliedTrackIdsToAttributes: {\n        value: new Map(),\n        writable: true\n      },\n      _dataChannels: {\n        value: new Map()\n      },\n      _dataTrackReceivers: {\n        value: new Set()\n      },\n      _descriptionRevision: {\n        writable: true,\n        value: 0\n      },\n      _didGenerateLocalCandidates: {\n        writable: true,\n        value: false\n      },\n      _enableDscp: {\n        value: options.enableDscp\n      },\n      _encodingParameters: {\n        value: encodingParameters\n      },\n      _isChromeScreenShareTrack: {\n        value: options.isChromeScreenShareTrack,\n      },\n      _iceGatheringFailed: {\n        value: false,\n        writable: true\n      },\n      _iceGatheringTimeout: {\n        value: new options.Timeout(\n          () => this._handleIceGatheringTimeout(),\n          DEFAULT_ICE_GATHERING_TIMEOUT_MS,\n          false)\n      },\n      _iceRestartBackoff: {\n        // eslint-disable-next-line new-cap\n        value: new options.Backoff(iceRestartBackoffConfig)\n      },\n      _instanceId: {\n        value: ++nInstances\n      },\n      _isIceConnectionInactive: {\n        writable: true,\n        value: false\n      },\n      _isIceLite: {\n        writable: true,\n        value: false\n      },\n      _isIceRestartBackoffInProgress: {\n        writable: true,\n        value: false\n      },\n      _isRestartingIce: {\n        writable: true,\n        value: false\n      },\n      _lastIceConnectionState: {\n        writable: true,\n        value: null\n      },\n      _lastStableDescriptionRevision: {\n        writable: true,\n        value: 0\n      },\n      _localCandidates: {\n        writable: true,\n        value: []\n      },\n      _localCodecs: {\n        value: new Set()\n      },\n      _localCandidatesRevision: {\n        writable: true,\n        value: 1\n      },\n      _localDescriptionWithoutSimulcast: {\n        writable: true,\n        value: null\n      },\n      _localDescription: {\n        writable: true,\n        value: null\n      },\n      _localUfrag: {\n        writable: true,\n        value: null\n      },\n      _log: {\n        value: log\n      },\n      _eventObserver: {\n        value: options.eventObserver\n      },\n      _remoteCodecMaps: {\n        value: new Map()\n      },\n      _rtpSenders: {\n        value: new Map()\n      },\n      _rtpNewSenders: {\n        value: new Set()\n      },\n      _iceConnectionMonitor: {\n        value: new options.IceConnectionMonitor(peerConnection)\n      },\n      _mediaTrackReceivers: {\n        value: new Set()\n      },\n      _needsAnswer: {\n        writable: true,\n        value: false\n      },\n      _negotiationRole: {\n        writable: true,\n        value: null\n      },\n      _offerOptions: {\n        writable: true,\n        value: options.offerOptions\n      },\n      _onEncodingParametersChanged: {\n        value: oncePerTick(() => {\n          if (!this._needsAnswer) {\n            updateEncodingParameters(this);\n          }\n        })\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _preferredAudioCodecs: {\n        value: preferredCodecs.audio\n      },\n      _preferredVideoCodecs: {\n        value: preferredCodecs.video\n      },\n      _shouldApplyDtx: {\n        value: preferredCodecs.audio.every(({ codec }) => codec !== 'opus')\n          || preferredCodecs.audio.some(({ codec, dtx }) => codec === 'opus' && dtx)\n      },\n      _queuedDescription: {\n        writable: true,\n        value: null\n      },\n      _iceReconnectTimeout: {\n        value: new options.Timeout(() => {\n          log.debug('ICE reconnect timed out');\n          this.close();\n        }, options.sessionTimeout, false)\n      },\n      _recycledTransceivers: {\n        value: {\n          audio: [],\n          video: []\n        }\n      },\n      _replaceTrackPromises: {\n        value: new Map()\n      },\n      _remoteCandidates: {\n        writable: true,\n        value: new IceBox()\n      },\n      _setCodecPreferences: {\n        // NOTE(mmalavalli): Re-ordering payload types in order to make sure a non-H264\n        // preferred codec is selected does not work on Android Firefox due to this behavior:\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1683258. So, we work around this by\n        // not applying any non-H264 preferred video codec.\n        value: isFirefox && isAndroid && preferredCodecs.video[0] && preferredCodecs.video[0].codec.toLowerCase() !== 'h264'\n          ? sdp => sdp\n          : options.setCodecPreferences\n      },\n      _setSimulcast: {\n        value: options.setSimulcast\n      },\n      _revertSimulcast: {\n        value: options.revertSimulcast\n      },\n      _RTCIceCandidate: {\n        value: options.RTCIceCandidate\n      },\n      _RTCPeerConnection: {\n        value: options.RTCPeerConnection\n      },\n      _RTCSessionDescription: {\n        value: options.RTCSessionDescription\n      },\n      _shouldOffer: {\n        writable: true,\n        value: false\n      },\n      _shouldRestartIce: {\n        writable: true,\n        value: false\n      },\n      _trackIdsToAttributes: {\n        value: new Map(),\n        writable: true\n      },\n      _trackMatcher: {\n        writable: true,\n        value: null\n      },\n      _mediaTrackSenderToPublisherHints: {\n        value: new Map()\n      },\n      id: {\n        enumerable: true,\n        value: id\n      }\n    });\n\n    encodingParameters.on('changed', this._onEncodingParametersChanged);\n\n    peerConnection.addEventListener('connectionstatechange', this._handleConnectionStateChange.bind(this));\n    peerConnection.addEventListener('datachannel', this._handleDataChannelEvent.bind(this));\n    peerConnection.addEventListener('icecandidate', this._handleIceCandidateEvent.bind(this));\n    peerConnection.addEventListener('iceconnectionstatechange', this._handleIceConnectionStateChange.bind(this));\n    peerConnection.addEventListener('icegatheringstatechange', this._handleIceGatheringStateChange.bind(this));\n    peerConnection.addEventListener('signalingstatechange', this._handleSignalingStateChange.bind(this));\n    peerConnection.addEventListener('track', this._handleTrackEvent.bind(this));\n\n    const self = this;\n    this.on('stateChanged', function stateChanged(state) {\n      if (state !== 'closed') {\n        return;\n      }\n      self.removeListener('stateChanged', stateChanged);\n      self._dataChannels.forEach((dataChannel, dataTrackSender) => {\n        self.removeDataTrackSender(dataTrackSender);\n      });\n    });\n  }\n\n  toString() {\n    return `[PeerConnectionV2 #${this._instanceId}: ${this.id}]`;\n  }\n\n  setEffectiveAdaptiveSimulcast(effectiveAdaptiveSimulcast) {\n    this._log.debug('Setting setEffectiveAdaptiveSimulcast: ', effectiveAdaptiveSimulcast);\n    // clear adaptive simulcast from codec preferences if it was set.\n    this._preferredVideoCodecs.forEach(cs => {\n      if ('adaptiveSimulcast' in cs) {\n        cs.adaptiveSimulcast = effectiveAdaptiveSimulcast;\n      }\n    });\n  }\n\n  get _shouldApplySimulcast() {\n    if (!isChrome && !isSafari) {\n      return false;\n    }\n\n    // adaptiveSimulcast is set to false after connected message is received if other party does not support it.\n    const simulcast = this._preferredVideoCodecs.some(cs => {\n      return cs.codec.toLowerCase() === 'vp8' && cs.simulcast && cs.adaptiveSimulcast !== false;\n    });\n\n    return simulcast;\n  }\n\n  /**\n   * The {@link PeerConnectionV2}'s underlying RTCPeerConnection's RTCPeerConnectionState\n   * if supported by the browser, its RTCIceConnectionState otherwise.\n   * @property {RTCPeerConnectionState}\n   */\n  get connectionState() {\n    return this.iceConnectionState === 'failed'\n      ? 'failed' : (this._peerConnection.connectionState || this.iceConnectionState);\n  }\n\n  /**\n   * The {@link PeerConnectionV2}'s underlying RTCPeerConnection's\n   * RTCIceConnectionState.\n   * @property {RTCIceConnectionState}\n   */\n  get iceConnectionState() {\n    return ((this._isIceConnectionInactive && this._peerConnection.iceConnectionState === 'disconnected') || this._iceGatheringFailed)\n      ? 'failed' : this._peerConnection.iceConnectionState;\n  }\n\n  /**\n   * Whether the {@link PeerConnectionV2} has negotiated or is in the process\n   * of negotiating the application m= section.\n   * @returns {boolean}\n   */\n  get isApplicationSectionNegotiated() {\n    if (this._peerConnection.signalingState !== 'closed') {\n      // accessing .localDescription in 'closed' state causes it throw exceptions.\n      return this._peerConnection.localDescription\n        ? getMediaSections(this._peerConnection.localDescription.sdp, 'application').length > 0\n        : false;\n    }\n    return true;\n  }\n\n  /**\n   * Whether adaptive simulcast is enabled.\n   * @returns {boolean}\n   */\n  get _isAdaptiveSimulcastEnabled() {\n    const adaptiveSimulcastEntry = this._preferredVideoCodecs.find(cs => 'adaptiveSimulcast' in cs);\n    return adaptiveSimulcastEntry && adaptiveSimulcastEntry.adaptiveSimulcast === true;\n  }\n\n  /**\n   * @param {MediaStreamTrack} track\n   * @param {Array<RTCRtpEncodingParameters>} encodings\n   * @param {boolean} trackReplaced\n   * @returns {boolean} true if encodings were updated.\n   */\n  _maybeUpdateEncodings(track, encodings, trackReplaced = false) {\n    if (track.kind !== 'video' || track.readyState === 'ended') {\n      return false;\n    }\n    // NOTE(mmalavalli): There is no guarantee that CanvasCaptureMediaStreamTracks will always have \"width\" and \"height\"\n    // in their settings. So, we don't update the encodings if they are not present.\n    // Chromium bug: https://bugs.chromium.org/p/chromium/issues/detail?id=1367082\n    const { height, width } = track.getSettings();\n    if (typeof height !== 'number' || typeof width !== 'number') {\n      return false;\n    }\n    // Note(mpatwardhan): always configure encodings for safari.\n    // for chrome only when adaptive simulcast enabled.\n    const browser = util.guessBrowser();\n    if (browser === 'safari' || (browser === 'chrome' && this._isAdaptiveSimulcastEnabled)) {\n      this._updateEncodings(track, encodings, trackReplaced);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Configures with default encodings depending on track type and resolution.\n   * Default configuration sets some encodings to disabled, and for others set scaleResolutionDownBy\n   * values. When trackReplaced is set to true, it will clear 'active' for any encodings that\n   * needs to be enabled.\n   * @param {MediaStreamTrack} track\n   * @param {Array<RTCRtpEncodingParameters>} encodings\n   * @param {boolean} trackReplaced\n   */\n  _updateEncodings(track, encodings, trackReplaced) {\n    if (this._isChromeScreenShareTrack(track)) {\n      const screenShareActiveLayerConfig = [\n        { scaleResolutionDownBy: 1 },\n        { scaleResolutionDownBy: 1 }\n      ];\n      encodings.forEach((encoding, i) => {\n        const activeLayerConfig = screenShareActiveLayerConfig[i];\n        if (activeLayerConfig) {\n          encoding.scaleResolutionDownBy = activeLayerConfig.scaleResolutionDownBy;\n          if (trackReplaced) {\n            delete encoding.active;\n          }\n        } else {\n          encoding.active = false;\n          delete encoding.scaleResolutionDownBy;\n        }\n      });\n    } else {\n      const { width, height }  = track.getSettings();\n      // NOTE(mpatwardhan): for non-screen share tracks\n      // enable layers depending on track resolutions\n      const pixelsToMaxActiveLayers = [\n        { pixels: 960 * 540, maxActiveLayers: 3 },\n        { pixels: 480 * 270, maxActiveLayers: 2 },\n        { pixels: 0, maxActiveLayers: 1 }\n      ];\n\n      const trackPixels =  width * height;\n      const activeLayersInfo = pixelsToMaxActiveLayers.find(layer => trackPixels >= layer.pixels);\n      const activeLayers = Math.min(encodings.length, activeLayersInfo.maxActiveLayers);\n      encodings.forEach((encoding, i) => {\n        const enabled  = i < activeLayers;\n        if (enabled) {\n          encoding.scaleResolutionDownBy = 1 << (activeLayers - i - 1);\n          if (trackReplaced) {\n            encoding.active = true;\n          }\n        } else {\n          encoding.active = false;\n          delete encoding.scaleResolutionDownBy;\n        }\n      });\n    }\n    this._log.debug('_updateEncodings:', encodings.map(({ active, scaleResolutionDownBy }, i) => `[${i}: ${active}, ${scaleResolutionDownBy || 0}]`).join(', '));\n  }\n\n  /**\n   * Add an ICE candidate to the {@link PeerConnectionV2}.\n   * @private\n   * @param {object} candidate\n   * @returns {Promise<void>}\n   */\n  _addIceCandidate(candidate) {\n    return Promise.resolve().then(() => {\n      candidate = new this._RTCIceCandidate(candidate);\n      return this._peerConnection.addIceCandidate(candidate);\n    }).catch(error => {\n      // NOTE(mmalavalli): Firefox 68+ now generates an RTCIceCandidate with an\n      // empty candidate string to signal end-of-candidates, followed by a null\n      // candidate. As of now, Chrome and Safari reject this RTCIceCandidate. Since\n      // this does not affect the media connection between Firefox 68+ and Chrome/Safari\n      // in Peer-to-Peer Rooms, we suppress the Error and log a warning message.\n      //\n      // Chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=978582\n      //\n      this._log.warn(`Failed to add RTCIceCandidate ${candidate ? `\"${candidate.candidate}\"` : 'null'}: `\n        + error.message);\n    });\n  }\n\n  /**\n   * Add ICE candidates to the {@link PeerConnectionV2}.\n   * @private\n   * @param {Array<object>} candidates\n   * @returns {Promise<void>}\n   */\n  _addIceCandidates(candidates) {\n    return Promise.all(candidates.map(this._addIceCandidate, this)).then(() => {});\n  }\n\n  /**\n   * Add a new RTCRtpTransceiver or update an existing RTCRtpTransceiver for the\n   * given MediaStreamTrack.\n   * @private\n   * @param {MediaStreamTrack} track\n   * @returns {RTCRtpTransceiver}\n   */\n  _addOrUpdateTransceiver(track) {\n    const transceiver = takeRecycledTransceiver(this, track.kind);\n    if (transceiver && transceiver.sender) {\n      const oldTrackId = transceiver.sender.track ? transceiver.sender.track.id : null;\n      if (oldTrackId) {\n        this._log.warn(`Reusing transceiver: ${transceiver.mid}] ${oldTrackId} => ${track.id}`);\n      }\n      // NOTE(mpatwardhan):remember this transceiver while we replace track.\n      // we recycle transceivers that are not in use after 'negotiationCompleted', but we want to prevent\n      // this one from getting recycled while replaceTrack is pending.\n      this._replaceTrackPromises.set(transceiver, transceiver.sender.replaceTrack(track).then(() => {\n        transceiver.direction = 'sendrecv';\n      }, () => {\n        // Do nothing.\n      }).finally(() => {\n        this._replaceTrackPromises.delete(transceiver);\n      }));\n      return transceiver;\n    }\n    return this._peerConnection.addTransceiver(track);\n  }\n\n  /**\n   * Check the {@link IceBox}.\n   * @private\n   * @param {RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n  _checkIceBox(description) {\n    const ufrag = getUfrag(description);\n    if (!ufrag) {\n      return Promise.resolve();\n    }\n    const candidates = this._remoteCandidates.setUfrag(ufrag);\n    return this._addIceCandidates(candidates);\n  }\n\n  /**\n   * Create an answer and set it on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescriptionInit} offer\n   * @returns {Promise<boolean>}\n   */\n  _answer(offer) {\n    return Promise.resolve().then(() => {\n      if (!this._negotiationRole) {\n        this._negotiationRole = 'answerer';\n      }\n      return this._setRemoteDescription(offer);\n    }).catch(() => {\n      throw new MediaClientRemoteDescFailedError();\n    }).then(() => {\n      return this._peerConnection.createAnswer();\n    }).then(answer => {\n      if (isFirefox) {\n        // NOTE(mmalavalli): We work around Chromium bug 1106157 by disabling\n        // RTX in Firefox 79+. For more details about the bug, please go here:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1106157\n        answer = new this._RTCSessionDescription({\n          sdp: disableRtx(answer.sdp),\n          type: answer.type\n        });\n      } else {\n        answer = workaroundIssue8329(answer);\n      }\n\n      // NOTE(mpatwardhan): Upcoming chrome versions are going to remove ssrc attributes\n      // mslabel and label. See this bug https://bugs.chromium.org/p/webrtc/issues/detail?id=7110\n      // and PSA: https://groups.google.com/forum/#!searchin/discuss-webrtc/PSA%7Csort:date/discuss-webrtc/jcZO-Wj0Wus/k2XvPCvoAwAJ\n      // We are not referencing those attributes, but this changes goes ahead and removes them to see if it works.\n      // this also helps reduce bytes on wires\n      let updatedSdp = removeSSRCAttributes(answer.sdp, ['mslabel', 'label']);\n\n      if (this._shouldApplySimulcast) {\n        let sdpWithoutSimulcast = updatedSdp;\n        updatedSdp = this._setSimulcast(sdpWithoutSimulcast, this._trackIdsToAttributes);\n        // NOTE(syerrapragada): VMS does not support H264 simulcast. So,\n        // unset simulcast for sections in local offer where corresponding\n        // sections in answer doesn't have vp8 as preferred codec and reapply offer.\n        updatedSdp = this._revertSimulcast(updatedSdp, sdpWithoutSimulcast, offer.sdp);\n      }\n\n      // NOTE(mmalavalli): Work around Chromium bug 1074421.\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=1074421\n      updatedSdp = updatedSdp.replace(/42e015/g, '42e01f');\n\n      return this._setLocalDescription({\n        type: answer.type,\n        sdp: updatedSdp\n      });\n    }).then(() => {\n      return this._checkIceBox(offer);\n    }).then(() => {\n      return this._queuedDescription\n        && this._updateDescription(this._queuedDescription);\n    }).then(() => {\n      this._queuedDescription = null;\n      return this._maybeReoffer(this._peerConnection.localDescription);\n    }).catch(error => {\n      const errorToThrow = error instanceof MediaClientRemoteDescFailedError ? error : new MediaClientLocalDescFailedError();\n      this._publishMediaWarning({\n        message: 'Failed to _answer',\n        code: errorToThrow.code,\n        error\n      });\n      throw errorToThrow;\n    });\n  }\n\n  /**\n   * Close the underlying RTCPeerConnection. Returns false if the\n   * RTCPeerConnection was already closed.\n   * @private\n   * @returns {boolean}\n   */\n  _close() {\n    this._iceConnectionMonitor.stop();\n    if (this._peerConnection.signalingState !== 'closed') {\n      this._peerConnection.close();\n      this.preempt('closed');\n      this._encodingParameters.removeListener('changed', this._onEncodingParametersChanged);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Handle a \"connectionstatechange\" event.\n   * @private\n   * @returns {void}\n   */\n  _handleConnectionStateChange() {\n    this.emit('connectionStateChanged');\n  }\n\n  /**\n   * Handle a \"datachannel\" event.\n   * @private\n   * @param {RTCDataChannelEvent} event\n   * @returns {void}\n   */\n  _handleDataChannelEvent(event) {\n    const dataChannel = event.channel;\n    const dataTrackReceiver = new DataTrackReceiver(dataChannel);\n    this._dataTrackReceivers.add(dataTrackReceiver);\n\n    dataChannel.addEventListener('close', () => {\n      this._dataTrackReceivers.delete(dataTrackReceiver);\n    });\n\n    this.emit('trackAdded', dataTrackReceiver);\n  }\n\n  /**\n   * Handle a glare scenario on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescriptionInit} offer\n   * @returns {Promise<void>}\n   */\n  _handleGlare(offer) {\n    this._log.debug('Glare detected; rolling back');\n    if (this._isRestartingIce) {\n      this._log.debug('An ICE restart was in progress; we\\'ll need to restart ICE again after rolling back');\n      this._isRestartingIce = false;\n      this._shouldRestartIce = true;\n    }\n    return Promise.resolve().then(() => {\n      this._trackIdsToAttributes = new Map(this._appliedTrackIdsToAttributes);\n      return this._setLocalDescription({ type: 'rollback' });\n    }).then(() => {\n      this._needsAnswer = false;\n      return this._answer(offer);\n    }).then(didReoffer => {\n      return didReoffer ? Promise.resolve() : this._offer();\n    });\n  }\n\n  _publishMediaWarning({ message, code, error, sdp }) {\n    this._eventObserver.emit('event', { level: 'warning', name: 'error', group: 'media', payload: {\n      message,\n      code,\n      context: JSON.stringify({ error: error.message, sdp })\n    } });\n  }\n\n  /**\n   * Handle an ICE candidate event.\n   * @private\n   * @param {Event} event\n   * @returns {void}\n   */\n  _handleIceCandidateEvent(event) {\n    if (event.candidate) {\n      this._log.debug('Clearing ICE gathering timeout');\n      this._didGenerateLocalCandidates = true;\n      this._iceGatheringTimeout.clear();\n      this._localCandidates.push(event.candidate);\n    }\n    const peerConnectionState = {\n      ice: {\n        candidates: this._isIceLite ? [] : this._localCandidates.slice(),\n        ufrag: this._localUfrag\n      },\n      id: this.id\n    };\n    if (!event.candidate) {\n      peerConnectionState.ice.complete = true;\n    }\n    if (!(this._isIceLite && event.candidate)) {\n      peerConnectionState.ice.revision = this._localCandidatesRevision++;\n      this.emit('candidates', peerConnectionState);\n    }\n  }\n\n  /**\n   * Handle an ICE connection state change event.\n   * @private\n   * @returns {void}\n   */\n  _handleIceConnectionStateChange() {\n    const { iceConnectionState } = this._peerConnection;\n    const isIceConnectedOrComplete = ['connected', 'completed'].includes(iceConnectionState);\n    const log = this._log;\n\n    log.debug(`ICE connection state is \"${iceConnectionState}\"`);\n    if (isIceConnectedOrComplete) {\n      this._iceReconnectTimeout.clear();\n      this._iceRestartBackoff.reset();\n    }\n\n    if (this._lastIceConnectionState !== 'failed' && iceConnectionState === 'failed' && !this._shouldRestartIce && !this._isRestartingIce) {\n      // Case 1: Transition to \"failed\".\n      log.warn('ICE failed');\n      this._initiateIceRestartBackoff();\n    } else if (['disconnected', 'failed'].includes(this._lastIceConnectionState) && isIceConnectedOrComplete) {\n      // Case 2: Transition from \"disconnected\" or \"failed\".\n      log.debug('ICE reconnected');\n    }\n\n    // start monitor media when connected, and continue to monitor while state is complete-disconnected-connected.\n    if (iceConnectionState === 'connected') {\n      this._isIceConnectionInactive = false;\n      this._iceConnectionMonitor.start(() => {\n        // note: iceConnection monitor waits for iceConnectionState=disconnected for\n        // detecting inactivity. Its possible that it may know about disconnected before _handleIceConnectionStateChange\n        this._iceConnectionMonitor.stop();\n        if (!this._shouldRestartIce && !this._isRestartingIce) {\n          log.warn('ICE Connection Monitor detected inactivity');\n          this._isIceConnectionInactive = true;\n          this._initiateIceRestartBackoff();\n          this.emit('iceConnectionStateChanged');\n          this.emit('connectionStateChanged');\n        }\n      });\n    } else if (!['disconnected', 'completed'].includes(iceConnectionState)) { // don't stop monitoring for disconnected or completed.\n      this._iceConnectionMonitor.stop();\n      this._isIceConnectionInactive = false;\n    }\n\n    this._lastIceConnectionState = iceConnectionState;\n    this.emit('iceConnectionStateChanged');\n  }\n\n  /**\n   * Handle ICE gathering timeout.\n   * @private\n   * @returns {void}\n   */\n  _handleIceGatheringTimeout() {\n    this._log.warn('ICE failed to gather any local candidates');\n    this._iceGatheringFailed = true;\n    this._initiateIceRestartBackoff();\n    this.emit('iceConnectionStateChanged');\n    this.emit('connectionStateChanged');\n  }\n\n  /**\n   * Handle an ICE gathering state change event.\n   * @private\n   * @returns {void}\n   */\n  _handleIceGatheringStateChange() {\n    const { iceGatheringState } = this._peerConnection;\n    const log = this._log;\n    log.debug(`ICE gathering state is \"${iceGatheringState}\"`);\n\n    // NOTE(mmalavalli): Start the ICE gathering timeout only if the RTCPeerConnection\n    // has started gathering candidates for the first time since the initial offer/answer\n    // or an offer/answer with ICE restart.\n    const { delay, isSet } = this._iceGatheringTimeout;\n    if (iceGatheringState === 'gathering' && !this._didGenerateLocalCandidates && !isSet) {\n      log.debug(`Starting ICE gathering timeout: ${delay}`);\n      this._iceGatheringFailed = false;\n      this._iceGatheringTimeout.start();\n    }\n  }\n\n  /**\n   * Handle a signaling state change event.\n   * @private\n   * @returns {void}\n   */\n  _handleSignalingStateChange() {\n    if (this._peerConnection.signalingState === 'stable') {\n      this._appliedTrackIdsToAttributes = new Map(this._trackIdsToAttributes);\n    }\n  }\n\n  /**\n   * Handle a track event.\n   * @private\n   * @param {RTCTrackEvent} event\n   * @returns {void}\n   */\n  _handleTrackEvent(event) {\n    const sdp = this._peerConnection.remoteDescription\n      ? this._peerConnection.remoteDescription.sdp\n      : null;\n\n    this._trackMatcher = this._trackMatcher || new TrackMatcher();\n    this._trackMatcher.update(sdp);\n\n    const mediaStreamTrack = event.track;\n    const signaledTrackId = this._trackMatcher.match(event) || mediaStreamTrack.id;\n    const mediaTrackReceiver = new MediaTrackReceiver(signaledTrackId, mediaStreamTrack);\n\n    // NOTE(mmalavalli): \"ended\" is not fired on the remote MediaStreamTrack when\n    // the remote peer removes a track. So, when this MediaStreamTrack is re-used\n    // for a different track due to the remote peer calling RTCRtpSender.replaceTrack(),\n    // we delete the previous MediaTrackReceiver that owned this MediaStreamTrack\n    // before adding the new MediaTrackReceiver.\n    this._mediaTrackReceivers.forEach(trackReceiver => {\n      if (trackReceiver.track.id === mediaTrackReceiver.track.id) {\n        this._mediaTrackReceivers.delete(trackReceiver);\n      }\n    });\n\n    this._mediaTrackReceivers.add(mediaTrackReceiver);\n    mediaStreamTrack.addEventListener('ended', () => this._mediaTrackReceivers.delete(mediaTrackReceiver));\n    this.emit('trackAdded', mediaTrackReceiver);\n  }\n\n  /**\n   * Initiate ICE Restart.\n   * @private\n   * @returns {void}\n   */\n  _initiateIceRestart() {\n    if (this._peerConnection.signalingState === 'closed') {\n      return;\n    }\n    const log = this._log;\n    log.warn('Attempting to restart ICE');\n    this._didGenerateLocalCandidates = false;\n    this._isIceRestartBackoffInProgress = false;\n    this._shouldRestartIce = true;\n\n    const { delay, isSet } = this._iceReconnectTimeout;\n    if (!isSet) {\n      log.debug(`Starting ICE reconnect timeout: ${delay}`);\n      this._iceReconnectTimeout.start();\n    }\n    this.offer().catch(ex => {\n      log.error(`offer failed in _initiateIceRestart with: ${ex.message}`);\n    });\n  }\n\n  /**\n   * Schedule an ICE Restart.\n   * @private\n   * @returns {void}\n   */\n  _initiateIceRestartBackoff() {\n    if (this._peerConnection.signalingState === 'closed' || this._isIceRestartBackoffInProgress) {\n      return;\n    }\n    this._log.warn('An ICE restart has been scheduled');\n    this._isIceRestartBackoffInProgress = true;\n    this._iceRestartBackoff.backoff(() => this._initiateIceRestart());\n  }\n\n  /**\n   * Conditionally re-offer.\n   * @private\n   * @param {?RTCSessionDescriptionInit} localDescription\n   * @returns {Promise<boolean>}\n   */\n  _maybeReoffer(localDescription) {\n    let shouldReoffer = this._shouldOffer;\n\n    if (localDescription && localDescription.sdp) {\n      // NOTE(mmalavalli): If the local RTCSessionDescription has fewer audio and/or\n      // video send* m= lines than the corresponding RTCRtpSenders with non-null\n      // MediaStreamTracks, it means that the newly added RTCRtpSenders require\n      // renegotiation.\n      const senders = this._peerConnection.getSenders().filter(sender => sender.track);\n      shouldReoffer = ['audio', 'video'].reduce((shouldOffer, kind) => {\n        const mediaSections = getMediaSections(localDescription.sdp, kind, '(sendrecv|sendonly)');\n        const sendersOfKind = senders.filter(isSenderOfKind.bind(null, kind));\n        return shouldOffer || (mediaSections.length < sendersOfKind.length);\n      }, shouldReoffer);\n\n      // NOTE(mroberts): We also need to re-offer if we have a DataTrack to share\n      // but no m= application section.\n      const hasDataTrack = this._dataChannels.size > 0;\n      const hasApplicationMediaSection = getMediaSections(localDescription.sdp, 'application').length > 0;\n      const needsApplicationMediaSection = hasDataTrack && !hasApplicationMediaSection;\n      shouldReoffer = shouldReoffer || needsApplicationMediaSection;\n    }\n\n    const promise = shouldReoffer ? this._offer() : Promise.resolve();\n    return promise.then(() => shouldReoffer);\n  }\n\n  /**\n   * Create an offer and set it on the {@link PeerConnectionV2}.\n   * @private\n   * @returns {Promise<void>}\n   */\n  _offer() {\n    const offerOptions = Object.assign({}, this._offerOptions);\n    this._needsAnswer = true;\n    if (this._shouldRestartIce) {\n      this._shouldRestartIce = false;\n      this._isRestartingIce = true;\n      offerOptions.iceRestart = true;\n    }\n\n    return Promise.all(this._replaceTrackPromises.values()).then(() => {\n      return this._peerConnection.createOffer(offerOptions);\n    }).catch(error => {\n      const errorToThrow = new MediaClientLocalDescFailedError();\n      this._publishMediaWarning({\n        message: 'Failed to create offer',\n        code: errorToThrow.code,\n        error\n      });\n      throw errorToThrow;\n    }).then(offer => {\n      if (isFirefox) {\n        // NOTE(mmalavalli): We work around Chromium bug 1106157 by disabling\n        // RTX in Firefox 79+. For more details about the bug, please go here:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1106157\n        offer = new this._RTCSessionDescription({\n          sdp: disableRtx(offer.sdp),\n          type: offer.type\n        });\n      } else {\n        offer = workaroundIssue8329(offer);\n      }\n\n      // NOTE(mpatwardhan): upcoming chrome versions are going to remove ssrc attributes\n      // mslabel and label. See this bug https://bugs.chromium.org/p/webrtc/issues/detail?id=7110\n      // and PSA: https://groups.google.com/forum/#!searchin/discuss-webrtc/PSA%7Csort:date/discuss-webrtc/jcZO-Wj0Wus/k2XvPCvoAwAJ\n      // Looks like we are not referencing those attributes, but this changes goes ahead and removes them to see if it works.\n      // this also helps reduce bytes on wires\n      let sdp = removeSSRCAttributes(offer.sdp, ['mslabel', 'label']);\n      sdp = this._peerConnection.remoteDescription\n        ? filterLocalCodecs(sdp, this._peerConnection.remoteDescription.sdp)\n        : sdp;\n\n      let updatedSdp = this._setCodecPreferences(\n        sdp,\n        this._preferredAudioCodecs,\n        this._preferredVideoCodecs);\n\n      this._shouldOffer = false;\n      if (!this._negotiationRole) {\n        this._negotiationRole = 'offerer';\n      }\n\n      if (this._shouldApplySimulcast) {\n        this._localDescriptionWithoutSimulcast = {\n          type: 'offer',\n          sdp: updatedSdp\n        };\n        updatedSdp = this._setSimulcast(updatedSdp, this._trackIdsToAttributes);\n      }\n      return this._setLocalDescription({\n        type: 'offer',\n        sdp: updatedSdp\n      });\n    });\n  }\n\n  /**\n   * Get the MediaTrackSender ID of the given MediaStreamTrack ID.\n   * Since a MediaTrackSender's underlying MediaStreamTrack can be\n   * replaced, the corresponding IDs can mismatch.\n   * @private\n   * @param {Track.ID} id\n   * @returns {Track.ID}\n   */\n  _getMediaTrackSenderId(trackId) {\n    const mediaTrackSender = Array.from(this._rtpSenders.keys()).find(({ track: { id } }) => id === trackId);\n    return mediaTrackSender ? mediaTrackSender.id : trackId;\n  }\n\n  /**\n   * Add or rewrite local MediaStreamTrack IDs in the given RTCSessionDescription.\n   * @private\n   * @param {RTCSessionDescription} description\n   * @return {RTCSessionDescription}\n   */\n  _addOrRewriteLocalTrackIds(description) {\n    const transceivers = this._peerConnection.getTransceivers();\n    const activeTransceivers = transceivers.filter(({ sender, stopped }) => !stopped && sender && sender.track);\n\n    // NOTE(mmalavalli): There is no guarantee that MediaStreamTrack IDs will be present in\n    // SDPs, and even if they are, there is no guarantee that they will be the same as the\n    // actual MediaStreamTrack IDs. So, we add or re-write the actual MediaStreamTrack IDs\n    // to the assigned m= sections here.\n    const assignedTransceivers = activeTransceivers.filter(({ mid }) => mid);\n    const midsToTrackIds = new Map(assignedTransceivers.map(({ mid, sender }) => [mid, this._getMediaTrackSenderId(sender.track.id)]));\n    const sdp1 = addOrRewriteTrackIds(description.sdp, midsToTrackIds);\n\n    // NOTE(mmalavalli): Chrome and Safari do not apply the offer until they get an answer.\n    // So, we add or re-write the actual MediaStreamTrack IDs to the unassigned m= sections here.\n    const unassignedTransceivers = activeTransceivers.filter(({ mid }) => !mid);\n    const newTrackIdsByKind = new Map(['audio', 'video'].map(kind => [\n      kind,\n      unassignedTransceivers.filter(({ sender }) => sender.track.kind === kind).map(({ sender }) => this._getMediaTrackSenderId(sender.track.id))\n    ]));\n    const sdp2 = addOrRewriteNewTrackIds(sdp1, midsToTrackIds, newTrackIdsByKind);\n\n    return new this._RTCSessionDescription({\n      sdp: sdp2,\n      type: description.type\n    });\n  }\n\n  /**\n   * Rollback and apply the given offer.\n   * @private\n   * @param {RTCSessionDescriptionInit} offer\n   * @returns {Promise<void>}\n   */\n  _rollbackAndApplyOffer(offer) {\n    return this._setLocalDescription({ type: 'rollback' }).then(() => this._setLocalDescription(offer));\n  }\n\n  /**\n   * Set a local description on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescription|RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n  _setLocalDescription(description) {\n    if (description.type !== 'rollback' && this._shouldApplyDtx) {\n      description = new this._RTCSessionDescription({\n        sdp: enableDtxForOpus(description.sdp),\n        type: description.type\n      });\n    }\n    return this._peerConnection.setLocalDescription(description).catch(error => {\n      this._log.warn(`Calling setLocalDescription with an RTCSessionDescription of type \"${description.type}\" failed with the error \"${error.message}\".`, error);\n\n      const errorToThrow = new MediaClientLocalDescFailedError();\n      const publishWarning = {\n        message: `Calling setLocalDescription with an RTCSessionDescription of type \"${description.type}\" failed`,\n        code: errorToThrow.code,\n        error\n      };\n\n      if (description.sdp) {\n        this._log.warn(`The SDP was ${description.sdp}`);\n        publishWarning.sdp = description.sdp;\n      }\n      this._publishMediaWarning(publishWarning);\n      throw errorToThrow;\n    }).then(() => {\n      if (description.type !== 'rollback') {\n        this._localDescription = this._addOrRewriteLocalTrackIds(description);\n\n        // NOTE(mmalavalli): In order for this feature to be backward compatible with older\n        // SDK versions which to not support opus DTX, we append \"usedtx=1\" to the local SDP\n        // only while applying it. We will not send it over the wire to prevent inadvertent\n        // enabling of opus DTX in older SDKs. Newer SDKs will append \"usedtx=1\" by themselves\n        // if the developer has requested opus DTX to be enabled. (JSDK-3063)\n        if (this._shouldApplyDtx) {\n          this._localDescription = new this._RTCSessionDescription({\n            sdp: enableDtxForOpus(this._localDescription.sdp, []),\n            type: this._localDescription.type\n          });\n        }\n\n        this._localCandidates = [];\n        if (description.type === 'offer') {\n          this._descriptionRevision++;\n        } else if (description.type === 'answer') {\n          this._lastStableDescriptionRevision = this._descriptionRevision;\n          negotiationCompleted(this);\n        }\n        this._localUfrag = getUfrag(description);\n        this.emit('description', this.getState());\n      }\n    });\n  }\n\n  /**\n   * Set a remote RTCSessionDescription on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n  _setRemoteDescription(description) {\n    if (description.sdp) {\n      description.sdp = this._setCodecPreferences(\n        description.sdp,\n        this._preferredAudioCodecs,\n        this._preferredVideoCodecs);\n\n      if (this._shouldApplyDtx) {\n        description.sdp = enableDtxForOpus(description.sdp);\n      } else {\n        // NOTE(mmalavalli): Remove \"usedtx=1\" from opus's fmtp line if present\n        // since DTX is disabled.\n        description.sdp = enableDtxForOpus(description.sdp, []);\n      }\n\n      if (isFirefox) {\n        // NOTE(mroberts): Do this to reduce our MediaStream count in Firefox. By\n        // mapping MediaStream IDs in the SDP to \"-\", we ensure the \"track\" event\n        // doesn't include any new MediaStreams in Firefox. Its `streams` member\n        // will always be the empty Array.\n        description.sdp = filterOutMediaStreamIds(description.sdp);\n      }\n      if (!this._peerConnection.remoteDescription) {\n        this._isIceLite = /a=ice-lite/.test(description.sdp);\n      }\n    }\n    description = new this._RTCSessionDescription(description);\n    // eslint-disable-next-line consistent-return\n    return Promise.resolve().then(() => {\n      // NOTE(syerrapragada): VMS does not support H264 simulcast. So,\n      // unset simulcast for sections in local offer where corresponding\n      // sections in answer doesn't have vp8 as preferred codec and reapply offer.\n      if (description.type === 'answer' && this._localDescriptionWithoutSimulcast) {\n        // NOTE(mpatwardhan):if we were using adaptive simulcast, and if its not supported by server\n        // revert simulcast even for vp8.\n        const adaptiveSimulcastEntry = this._preferredVideoCodecs.find(cs => 'adaptiveSimulcast' in cs);\n        const revertForAll = !!adaptiveSimulcastEntry && adaptiveSimulcastEntry.adaptiveSimulcast === false;\n        const sdpWithoutSimulcastForNonVP8MediaSections = this._revertSimulcast(\n          this._localDescription.sdp,\n          this._localDescriptionWithoutSimulcast.sdp,\n          description.sdp, revertForAll);\n        this._localDescriptionWithoutSimulcast = null;\n        if (sdpWithoutSimulcastForNonVP8MediaSections !== this._localDescription.sdp) {\n          return this._rollbackAndApplyOffer({\n            type: this._localDescription.type,\n            sdp: sdpWithoutSimulcastForNonVP8MediaSections\n          });\n        }\n      }\n    }).then(() => this._peerConnection.setRemoteDescription(description)).then(() => {\n      if (description.type === 'answer') {\n        if (this._isRestartingIce) {\n          this._log.debug('An ICE restart was in-progress and is now completed');\n          this._isRestartingIce = false;\n        }\n        negotiationCompleted(this);\n      }\n    }, error => {\n      this._log.warn(`Calling setRemoteDescription with an RTCSessionDescription of type \"${description.type}\" failed with the error \"${error.message}\".`, error);\n      if (description.sdp) {\n        this._log.warn(`The SDP was ${description.sdp}`);\n      }\n      throw error;\n    });\n  }\n\n  /**\n   * Update the {@link PeerConnectionV2}'s description.\n   * @private\n   * @param {RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n  _updateDescription(description) {\n    switch (description.type) {\n      case 'answer':\n      case 'pranswer':\n        if (description.revision !== this._descriptionRevision\n          || this._peerConnection.signalingState !== 'have-local-offer') {\n          return Promise.resolve();\n        }\n        this._descriptionRevision = description.revision;\n        break;\n      case 'close':\n        return this._close();\n      case 'create-offer':\n        if (description.revision <= this._lastStableDescriptionRevision) {\n          return Promise.resolve();\n        } else if (this._needsAnswer) {\n          this._queuedDescription = description;\n          return Promise.resolve();\n        }\n        this._descriptionRevision = description.revision;\n        return this._offer();\n      case 'offer':\n        if (description.revision <= this._lastStableDescriptionRevision\n          || this._peerConnection.signalingState === 'closed') {\n          return Promise.resolve();\n        }\n        if (this._peerConnection.signalingState === 'have-local-offer') {\n          // NOTE(mpatwardhan): For a peer connection\n          // 1) createOffer always generate SDP with `setup:actpass`\n          // 2) when remote description is set `setup:active`  - the answer generated selects the dtls role of setup:passive\n          // 3) when remote description is set `setup:passive` - the answer generated selects the dtls role of setup:active\n          // 4) when remote description is set `setup:actpass` - the answer generated uses the previously negotiated role (if not negotiated previously setup:active is used)\n          // This test shows the  behavior: https://github.com/twilio/twilio-webrtc.js/blob/master/test/integration/spec/rtcpeerconnection.js#L936\n          // with glare handling (if dtls role was not negotiated before ) the generated answer will set setup:active.\n          // we do not want that. lets wait for \"initial negotiation\" before attempting glare handling.\n          if (this._needsAnswer && this._lastStableDescriptionRevision === 0) {\n            this._queuedDescription = description;\n            return Promise.resolve();\n          }\n          this._descriptionRevision = description.revision;\n          return this._handleGlare(description);\n        }\n        this._descriptionRevision = description.revision;\n        return this._answer(description).then(() => {});\n      default:\n        // Do nothing.\n    }\n\n    // Handle answer or pranswer.\n    const revision = description.revision;\n    return Promise.resolve().then(() => {\n      return this._setRemoteDescription(description);\n    }).catch(error => {\n      const errorToThrow = new MediaClientRemoteDescFailedError();\n      this._publishMediaWarning({\n        message: `Calling setRemoteDescription with an RTCSessionDescription of type \"${description.type}\" failed`,\n        code: errorToThrow.code,\n        error,\n        sdp: description.sdp\n      });\n      throw errorToThrow;\n    }).then(() => {\n      this._lastStableDescriptionRevision = revision;\n      this._needsAnswer = false;\n      return this._checkIceBox(description);\n    }).then(() => {\n      return this._queuedDescription\n        && this._updateDescription(this._queuedDescription);\n    }).then(() => {\n      this._queuedDescription = null;\n      return this._maybeReoffer(this._peerConnection.localDescription).then(() => {});\n    });\n  }\n\n  /**\n   * Update the {@link PeerConnectionV2}'s ICE candidates.\n   * @private\n   * @param {object} iceState\n   * @returns {Promise<void>}\n   */\n  _updateIce(iceState) {\n    const candidates = this._remoteCandidates.update(iceState);\n    return this._addIceCandidates(candidates);\n  }\n\n  /**\n   * Add a {@link DataTrackSender} to the {@link PeerConnectionV2}.\n   * @param {DataTrackSender} dataTrackSender\n   * @returns {void}\n   */\n  addDataTrackSender(dataTrackSender) {\n    if (this._dataChannels.has(dataTrackSender)) {\n      return;\n    }\n    try {\n      const dataChannelDict = {\n        ordered: dataTrackSender.ordered\n      };\n      if (dataTrackSender.maxPacketLifeTime !== null) {\n        dataChannelDict.maxPacketLifeTime = dataTrackSender.maxPacketLifeTime;\n      }\n      if (dataTrackSender.maxRetransmits !== null) {\n        dataChannelDict.maxRetransmits = dataTrackSender.maxRetransmits;\n      }\n      const dataChannel = this._peerConnection.createDataChannel(dataTrackSender.id, dataChannelDict);\n      dataTrackSender.addDataChannel(dataChannel);\n      this._dataChannels.set(dataTrackSender, dataChannel);\n    } catch (error) {\n      this._log.warn(`Error creating an RTCDataChannel for DataTrack \"${dataTrackSender.id}\": ${error.message}`);\n    }\n  }\n\n  _handleQueuedPublisherHints() {\n    if (this._peerConnection.signalingState === 'stable') {\n      this._mediaTrackSenderToPublisherHints.forEach(({ deferred, encodings }, mediaTrackSender) => {\n        this._mediaTrackSenderToPublisherHints.delete(mediaTrackSender);\n        this._setPublisherHint(mediaTrackSender, encodings)\n          .then(result => deferred.resolve(result))\n          .catch(error => deferred.reject(error));\n      });\n    }\n  }\n\n  /**\n   * updates encodings for simulcast layers of given sender.\n   * @param {RTCRtpSender} sender\n   * @param {Array<{enabled: boolean, layer_index: number}>|null} encodings\n   * @returns {Promise<string>} string indicating result of the operation. can be one of\n   *  \"OK\", \"INVALID_HINT\", \"COULD_NOT_APPLY_HINT\", \"UNKNOWN_TRACK\"\n   */\n  _setPublisherHint(mediaTrackSender, encodings) {\n    if (isFirefox) {\n      return Promise.resolve('COULD_NOT_APPLY_HINT');\n    }\n\n    if (this._mediaTrackSenderToPublisherHints.has(mediaTrackSender)) {\n      // skip any stale hint associated with the mediaTrackSender.\n      const queuedHint = this._mediaTrackSenderToPublisherHints.get(mediaTrackSender);\n      queuedHint.deferred.resolve('REQUEST_SKIPPED');\n      this._mediaTrackSenderToPublisherHints.delete(mediaTrackSender);\n    }\n\n    const sender = this._rtpSenders.get(mediaTrackSender);\n    if (!sender) {\n      this._log.warn('Could not apply publisher hint because RTCRtpSender was not found');\n      return Promise.resolve('UNKNOWN_TRACK');\n    }\n\n    if (this._peerConnection.signalingState === 'closed') {\n      this._log.warn('Could not apply publisher hint because signalingState was \"closed\"');\n      return Promise.resolve('COULD_NOT_APPLY_HINT');\n    }\n\n    if (this._peerConnection.signalingState !== 'stable') {\n      // enqueue this hint to be applied when pc becomes stable.\n      this._log.debug('Queuing up publisher hint because signalingState:', this._peerConnection.signalingState);\n      const deferred = defer();\n      this._mediaTrackSenderToPublisherHints.set(mediaTrackSender, { deferred, encodings });\n      return deferred.promise;\n    }\n\n    const parameters = sender.getParameters();\n    if (encodings !== null) {\n      encodings.forEach(({ enabled, layer_index: layerIndex }) => {\n        if (parameters.encodings.length > layerIndex) {\n          this._log.debug(`layer:${layerIndex}, active:${parameters.encodings[layerIndex].active} => ${enabled}`);\n          parameters.encodings[layerIndex].active = enabled;\n        } else {\n          this._log.warn(`invalid layer:${layerIndex}, active:${enabled}`);\n        }\n      });\n    }\n\n    // Note(mpatwardhan): after publisher hints are applied, overwrite with default encodings\n    // to disable any encoding that shouldn't have been enabled by publisher_hints.\n    // When encodings===null (that is we are asked to reset encodings for replaceTrack)\n    // along with disabling encodings, clear active flag for encodings that should not be disabled\n    this._maybeUpdateEncodings(sender.track, parameters.encodings, encodings === null /* trackReplaced */);\n\n    return sender.setParameters(parameters).then(() => 'OK').catch(error => {\n      this._log.error('Failed to apply publisher hints:', error);\n      return 'COULD_NOT_APPLY_HINT';\n    });\n  }\n\n  /**\n   * Add the {@link MediaTrackSender} to the {@link PeerConnectionV2}.\n   * @param {MediaTrackSender} mediaTrackSender\n   * @returns {void}\n   */\n  addMediaTrackSender(mediaTrackSender) {\n    if (this._peerConnection.signalingState === 'closed' || this._rtpSenders.has(mediaTrackSender)) {\n      return;\n    }\n    const transceiver = this._addOrUpdateTransceiver(mediaTrackSender.track);\n    const { sender } = transceiver;\n    mediaTrackSender.addSender(sender, encodings => this._setPublisherHint(mediaTrackSender, encodings));\n    this._rtpNewSenders.add(sender);\n    this._rtpSenders.set(mediaTrackSender, sender);\n  }\n\n  /**\n   * Close the {@link PeerConnectionV2}.\n   * @returns {void}\n   */\n  close() {\n    if (this._close()) {\n      this._descriptionRevision++;\n      this._localDescription = { type: 'close' };\n      this.emit('description', this.getState());\n    }\n  }\n\n  /**\n   * Get the {@link DataTrackReceiver}s and the {@link MediaTrackReceiver}s on the\n   * {@link PeerConnectionV2}.\n   * @returns {Array<DataTrackReceiver|MediaTrackReceiver>} trackReceivers\n   */\n  getTrackReceivers() {\n    return Array.from(this._dataTrackReceivers).concat(Array.from(this._mediaTrackReceivers));\n  }\n\n  /**\n   * Get the {@link PeerConnectionV2}'s state (specifically, its description).\n   * @returns {?object}\n   */\n  getState() {\n    if (!this._localDescription) {\n      return null;\n    }\n\n    // NOTE(mpatwardhan): Return most recent localDescription. If the most recent local description is an\n    // answer, and this method is called for sending a \"sync\" message while the next remote offer is being processed,\n    // we need to send the most recent stable description revision instead of the current description revision,\n    // which is supposed to be for the next local answer.\n    const localDescriptionRevision = this._localDescription.type === 'answer' ? this._lastStableDescriptionRevision : this._descriptionRevision;\n    const localDescription = {\n      type: this._localDescription.type,\n      revision: localDescriptionRevision\n    };\n    if (this._localDescription.sdp) {\n      localDescription.sdp = this._localDescription.sdp;\n    }\n    return {\n      description: localDescription,\n      id: this.id\n    };\n  }\n\n  /**\n   * Create an offer and set it on the {@link PeerConnectionV2}.\n   * @returns {Promise<void>}\n   */\n  offer() {\n    if (this._needsAnswer || this._isRestartingIce) {\n      this._shouldOffer = true;\n      return Promise.resolve();\n    }\n\n    return this.bracket('offering', key => {\n      this.transition('updating', key);\n      const promise = this._needsAnswer || this._isRestartingIce ? Promise.resolve() : this._offer();\n      return promise.then(() => {\n        this.tryTransition('open', key);\n      }, error => {\n        this.tryTransition('open', key);\n        throw error;\n      });\n    });\n  }\n\n  /**\n   * Remove a {@link DataTrackSender} from the {@link PeerConnectionV2}.\n   * @param {DataTrackSender} dataTrackSender\n   * @returns {void}\n   */\n  removeDataTrackSender(dataTrackSender) {\n    const dataChannel = this._dataChannels.get(dataTrackSender);\n    if (dataChannel) {\n      dataTrackSender.removeDataChannel(dataChannel);\n      this._dataChannels.delete(dataTrackSender);\n      dataChannel.close();\n    }\n  }\n\n  /**\n   * Remove the {@link MediaTrackSender} from the {@link PeerConnectionV2}.\n   * @param {MediaTrackSender} mediaTrackSender\n   * @returns {void}\n   */\n  removeMediaTrackSender(mediaTrackSender) {\n    const sender = this._rtpSenders.get(mediaTrackSender);\n    if (!sender) {\n      return;\n    }\n    if (this._peerConnection.signalingState !== 'closed') {\n      this._peerConnection.removeTrack(sender);\n    }\n    mediaTrackSender.removeSender(sender);\n    // clean up any pending publisher hints associated with this mediaTrackSender.\n    if (this._mediaTrackSenderToPublisherHints.has(mediaTrackSender)) {\n      const queuedHint = this._mediaTrackSenderToPublisherHints.get(mediaTrackSender);\n      queuedHint.deferred.resolve('UNKNOWN_TRACK');\n      this._mediaTrackSenderToPublisherHints.delete(mediaTrackSender);\n    }\n    this._rtpNewSenders.delete(sender);\n    this._rtpSenders.delete(mediaTrackSender);\n  }\n\n  /**\n   * Set the RTCConfiguration on the underlying RTCPeerConnection.\n   * @param {RTCConfiguration} configuration\n   * @returns {void}\n   */\n  setConfiguration(configuration) {\n    if (typeof this._peerConnection.setConfiguration === 'function') {\n      this._peerConnection.setConfiguration(getConfiguration(configuration));\n    }\n  }\n\n  /**\n   * Set the ICE reconnect timeout period.\n   * @param {number} period - Period in milliseconds.\n   * @returns {this}\n   */\n  setIceReconnectTimeout(period) {\n    this._iceReconnectTimeout.setDelay(period);\n    this._log.debug('Updated ICE reconnection timeout period:',\n      this._iceReconnectTimeout.delay);\n    return this;\n  }\n\n  /**\n   * Update the {@link PeerConnectionV2}.\n   * @param {object} peerConnectionState\n   * @returns {Promise<void>}\n   */\n  update(peerConnectionState) {\n    return this.bracket('updating', key => {\n      if (this.state === 'closed') {\n        return Promise.resolve();\n      }\n\n      this.transition('updating', key);\n\n      const updates = [];\n\n      if (peerConnectionState.ice) {\n        updates.push(this._updateIce(peerConnectionState.ice));\n      }\n\n      if (peerConnectionState.description) {\n        updates.push(this._updateDescription(peerConnectionState.description));\n      }\n\n      return Promise.all(updates).then(() => {\n        this.tryTransition('open', key);\n      }, error => {\n        this.tryTransition('open', key);\n        throw error;\n      });\n    });\n  }\n\n  /**\n   * Get the {@link PeerConnectionV2}'s media statistics.\n   * @returns {Promise<StandardizedStatsResponse>}\n   */\n  getStats() {\n    return getStatistics(this._peerConnection).then(response => rewriteTrackIds(this, response));\n  }\n}\n\nfunction rewriteLocalTrackId(pcv2, stats) {\n  const trackId = pcv2._getMediaTrackSenderId(stats.trackId);\n  return Object.assign(stats, { trackId });\n}\n\nfunction rewriteTrackId(pcv2, stats) {\n  const receiver = [...pcv2._mediaTrackReceivers]\n    .find(receiver => receiver.track.id === stats.trackId);\n  const trackId = receiver ? receiver.id : null;\n  return Object.assign(stats, { trackId });\n}\n\nfunction rewriteTrackIds(pcv2, response) {\n  return Object.assign(response, {\n    remoteAudioTrackStats: response.remoteAudioTrackStats.map(stats => rewriteTrackId(pcv2, stats)),\n    remoteVideoTrackStats: response.remoteVideoTrackStats.map(stats => rewriteTrackId(pcv2, stats)),\n    localAudioTrackStats: response.localAudioTrackStats.map(stats => rewriteLocalTrackId(pcv2, stats)),\n    localVideoTrackStats: response.localVideoTrackStats.map(stats => rewriteLocalTrackId(pcv2, stats)),\n  });\n}\n\n/**\n * @event PeerConnectionV2#candidates\n * @param {object} candidates\n */\n\n/**\n * @event PeerConnectionV2#connectionStateChanged\n */\n\n/**\n * @event PeerConnectionV2#description\n * @param {object} description\n */\n\n/**\n * @event PeerConnectionV2#iceConnectionStateChanged\n */\n\n/**\n * @event PeerConnectionV2#trackAdded\n * @param {DataTrackReceiver|MediaTrackReceiver} trackReceiver\n */\n\nfunction getUfrag(description) {\n  if (description.sdp) {\n    const match = description.sdp.match(/^a=ice-ufrag:([a-zA-Z0-9+/]+)/m);\n    if (match) {\n      return match[1];\n    }\n  }\n  return null;\n}\n\nfunction getConfiguration(configuration) {\n  return Object.assign({\n    bundlePolicy: 'max-bundle',\n    rtcpMuxPolicy: 'require'\n  }, configuration);\n}\n\n/**\n * Whether the MediaStreamTrack of the given RTCRTPSender is a non-ended\n * MediaStreamTrack of a given kind.\n * @private\n * @param {string} kind\n * @param {RTCRtpSender} sender\n * @return {boolean}\n */\nfunction isSenderOfKind(kind, sender) {\n  const track = sender.track;\n  return track && track.kind === kind && track.readyState !== 'ended';\n}\n\n/**\n * Preferred codecs.\n * @typedef {object} PreferredCodecs\n * @property {Array<AudioCodec>} audio\n * @property {Array<VideoCodec>} video\n */\n\nfunction filterOutMediaStreamIds(sdp) {\n  return sdp.replace(/a=msid:[^ ]+ /g, 'a=msid:- ');\n}\n\n/**\n * Whether an RTCRtpTransceiver can be recycled.\n * @param {RTCRtpTransceiver} transceiver\n * @returns {boolean}\n */\nfunction shouldRecycleTransceiver(transceiver, pcv2) {\n  return !transceiver.stopped\n    && !pcv2._replaceTrackPromises.has(transceiver)\n    && ['inactive', 'recvonly'].includes(transceiver.direction);\n}\n\n/**\n * Take a recycled RTCRtpTransceiver if available.\n * @param {PeerConnectionV2} pcv2\n * @param {Track.Kind} kind\n * @returns {?RTCRtpTransceiver}\n */\nfunction takeRecycledTransceiver(pcv2, kind) {\n  const preferredCodecs = {\n    audio: pcv2._preferredAudioCodecs.map(({ codec }) => codec.toLowerCase()),\n    video: pcv2._preferredVideoCodecs.map(({ codec }) => codec.toLowerCase())\n  }[kind];\n\n  const recycledTransceivers = pcv2._recycledTransceivers[kind];\n  const localCodec = preferredCodecs.find(codec => pcv2._localCodecs.has(codec));\n  if (!localCodec) {\n    return recycledTransceivers.shift();\n  }\n\n  const transceiver = recycledTransceivers.find(transceiver => {\n    const remoteCodecMap = pcv2._remoteCodecMaps.get(transceiver.mid);\n    return remoteCodecMap && remoteCodecMap.has(localCodec);\n  });\n\n  if (transceiver) {\n    recycledTransceivers.splice(recycledTransceivers.indexOf(transceiver), 1);\n  }\n  return transceiver;\n}\n\n/**\n * Update the set of locally supported {@link Codec}s.\n * @param pcv2\n * @returns {void}\n */\nfunction updateLocalCodecs(pcv2) {\n  const description = pcv2._peerConnection.localDescription;\n  if (!description || !description.sdp) {\n    return;\n  }\n  getMediaSections(description.sdp).forEach(section => {\n    const codecMap = createCodecMapForMediaSection(section);\n    codecMap.forEach((pts, codec) => pcv2._localCodecs.add(codec));\n  });\n}\n\n/**\n * Update the {@link Codec} maps for all m= sections in the remote {@link RTCSessionDescription}s.\n * @param {PeerConnectionV2} pcv2\n * @returns {void}\n */\nfunction updateRemoteCodecMaps(pcv2) {\n  const description = pcv2._peerConnection.remoteDescription;\n  if (!description || !description.sdp) {\n    return;\n  }\n  getMediaSections(description.sdp).forEach(section => {\n    const matched = section.match(/^a=mid:(.+)$/m);\n    if (!matched || !matched[1]) {\n      return;\n    }\n    const mid = matched[1];\n    const codecMap = createCodecMapForMediaSection(section);\n    pcv2._remoteCodecMaps.set(mid, codecMap);\n  });\n}\n\n/**\n * Update the list of recycled RTCRtpTransceivers.\n * @param {PeerConnectionV2} pcv2\n */\nfunction updateRecycledTransceivers(pcv2) {\n  pcv2._recycledTransceivers.audio = [];\n  pcv2._recycledTransceivers.video = [];\n  pcv2._peerConnection.getTransceivers().forEach(transceiver => {\n    if (shouldRecycleTransceiver(transceiver, pcv2)) {\n      const track = transceiver.receiver.track;\n      pcv2._recycledTransceivers[track.kind].push(transceiver);\n    }\n  });\n}\n\n/**\n * Perform certain updates after an SDP negotiation is completed.\n * @param {PeerConnectionV2} pcv2\n * @returns {void}\n */\nfunction negotiationCompleted(pcv2) {\n  updateRecycledTransceivers(pcv2);\n  updateLocalCodecs(pcv2);\n  updateRemoteCodecMaps(pcv2);\n  updateEncodingParameters(pcv2).then(() => {\n    // if there any any publisher hints queued, apply them now.\n    pcv2._handleQueuedPublisherHints();\n  });\n}\n\n/**\n * Update the RTCRtpEncodingParameters of all active RTCRtpSenders.\n * @param {PeerConnectionV2} pcv2\n * @returns {void}\n */\nfunction updateEncodingParameters(pcv2) {\n  const { maxAudioBitrate, maxVideoBitrate } = pcv2._encodingParameters;\n\n  const maxBitrates = new Map([\n    ['audio', maxAudioBitrate],\n    ['video', maxVideoBitrate]\n  ]);\n\n  const promises = [];\n  pcv2._peerConnection.getSenders().filter(sender => sender.track).forEach(sender => {\n    const maxBitrate = maxBitrates.get(sender.track.kind);\n    const params = sender.getParameters();\n\n    if (maxBitrate === null || maxBitrate === 0) {\n      removeMaxBitrate(params);\n    } else if (pcv2._isChromeScreenShareTrack(sender.track)) {\n      // NOTE(mpatwardhan): Sometimes (JSDK-2557) chrome does not send any bytes on screen track if MaxBitRate is set on it via setParameters,\n      // To workaround this issue we will not apply maxBitrate if the track appears to be a screen share track created by chrome\n      pcv2._log.warn(`Not setting maxBitrate for ${sender.track.kind} Track ${sender.track.id} because it appears to be screen share track: ${sender.track.label}`);\n    } else {\n      setMaxBitrate(params, maxBitrate);\n    }\n\n    if (!isFirefox && params.encodings.length > 0) {\n      if (sender.track.kind === 'audio') {\n        // NOTE(mmalavalli): \"priority\" is a per-sender property and not\n        // a per-encoding-layer property. So, we set the value only on the first\n        // encoding layer. Any attempt to set the value on subsequent encoding\n        // layers (in the case of simulcast) will result in the Promise returned\n        // by RTCRtpSender.setParameters() being rejected. With this, audio encoding\n        // is prioritized the most.\n        params.encodings[0].priority = 'high';\n      } else if (pcv2._isChromeScreenShareTrack(sender.track)) {\n        // NOTE(mmalavalli): Screen share encodings are prioritized more than those\n        // of the camera.\n        params.encodings[0].priority = 'medium';\n      }\n      if (pcv2._enableDscp) {\n        // NOTE(mmalavalli): \"networkPriority\" is a per-sender property and not\n        // a per-encoding-layer property. So, we set the value only on the first\n        // encoding layer. Any attempt to set the value on subsequent encoding\n        // layers (in the case of simulcast) will result in the Promise returned\n        // by RTCRtpSender.setParameters() being rejected.\n        params.encodings[0].networkPriority = 'high';\n      }\n    }\n\n    // when a sender is reused, delete any active encodings set by server.\n    const trackReplaced = pcv2._rtpNewSenders.has(sender);\n    pcv2._maybeUpdateEncodings(sender.track, params.encodings, trackReplaced);\n    pcv2._rtpNewSenders.delete(sender);\n\n    const promise = sender.setParameters(params).catch(error => {\n      pcv2._log.warn(`Error while setting encodings parameters for ${sender.track.kind} Track ${sender.track.id}: ${error.message || error.name}`);\n    });\n    promises.push(promise);\n  });\n  return Promise.all(promises);\n}\n\n/**\n * Remove maxBitrate from the RTCRtpSendParameters' encodings.\n * @param {RTCRtpSendParameters} params\n * @returns {void}\n */\nfunction removeMaxBitrate(params) {\n  if (Array.isArray(params.encodings)) {\n    params.encodings.forEach(encoding => delete encoding.maxBitrate);\n  }\n}\n\n/**\n * Set the given maxBitrate in the RTCRtpSendParameters' encodings.\n * @param {RTCRtpSendParameters} params\n * @param {number} maxBitrate\n * @returns {void}\n */\nfunction setMaxBitrate(params, maxBitrate) {\n  if (isFirefox) {\n    params.encodings = [{ maxBitrate }];\n  } else {\n    params.encodings.forEach(encoding => {\n      encoding.maxBitrate = maxBitrate;\n    });\n  }\n}\nmodule.exports = PeerConnectionV2;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}