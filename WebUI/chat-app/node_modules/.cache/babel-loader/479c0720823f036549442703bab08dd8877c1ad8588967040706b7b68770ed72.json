{"ast":null,"code":"'use strict';\n\nvar RTCSessionDescription = require('../../webrtc').RTCSessionDescription;\nvar _a = require('./'),\n  createPtToCodecName = _a.createPtToCodecName,\n  getMediaSections = _a.getMediaSections;\n/**\n * An RTX payload type\n * @typedef {PT} RtxPT\n */\n/**\n * A non-RTX payload type\n * @typedef {PT} NonRtxPT\n */\n/**\n * A Set with at least one element\n * @typedef {Set} NonEmptySet\n */\n/**\n * Apply the workaround for Issue 8329 to an RTCSessionDescriptionInit.\n * @param {RTCSessionDescriptionInit} description\n * @returns {RTCSessionDescription} newDescription\n */\nfunction workaround(description) {\n  var descriptionInit = {\n    type: description.type\n  };\n  if (description.type !== 'rollback') {\n    descriptionInit.sdp = sdpWorkaround(description.sdp);\n  }\n  return new RTCSessionDescription(descriptionInit);\n}\n/**\n * @param {string} sdp\n * @returns {string} newSdp\n */\nfunction sdpWorkaround(sdp) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(mediaSectionWorkaround)).join('\\r\\n');\n}\n/**\n * @param {string} mediaSection\n * @returns {string} newMediaSection\n */\nfunction mediaSectionWorkaround(mediaSection) {\n  var ptToCodecName = createPtToCodecName(mediaSection);\n  mediaSection = deleteDuplicateRtxPts(mediaSection, ptToCodecName);\n  var codecNameToPts = createCodecNameToPts(ptToCodecName);\n  var rtxPts = codecNameToPts.get('rtx') || new Set();\n  var invalidRtxPts = new Set();\n  var rtxPtToAssociatedPt = createRtxPtToAssociatedPt(mediaSection, ptToCodecName, rtxPts, invalidRtxPts);\n  var associatedPtToRtxPt = createAssociatedPtToRtxPt(rtxPtToAssociatedPt, invalidRtxPts);\n  var unassociatedRtxPts = Array.from(invalidRtxPts);\n  // NOTE(mroberts): We normalize to lowercase.\n  var knownCodecNames = ['h264', 'vp8', 'vp9'];\n  var unassociatedPts = knownCodecNames.reduce(function (unassociatedPts, codecName) {\n    var pts = codecNameToPts.get(codecName) || new Set();\n    return Array.from(pts).reduce(function (unassociatedPts, pt) {\n      return associatedPtToRtxPt.has(pt) ? unassociatedPts : unassociatedPts.add(pt);\n    }, unassociatedPts);\n  }, new Set());\n  unassociatedPts.forEach(function (pt) {\n    if (unassociatedRtxPts.length) {\n      var rtxPt = unassociatedRtxPts.shift();\n      mediaSection = deleteFmtpAttributesForRtxPt(mediaSection, rtxPt);\n      mediaSection = addFmtpAttributeForRtxPt(mediaSection, rtxPt, pt);\n    }\n  });\n  unassociatedRtxPts.forEach(function (rtxPt) {\n    mediaSection = deleteFmtpAttributesForRtxPt(mediaSection, rtxPt);\n    mediaSection = deleteRtpmapAttributesForRtxPt(mediaSection, rtxPt);\n  });\n  return mediaSection;\n}\n/**\n * @param {string} mediaSection\n * @param {Map<PT, Codec>} ptToCodecName\n * @returns {string} newMediaSection\n */\nfunction deleteDuplicateRtxPts(mediaSection, ptToCodecName) {\n  // NOTE(syerrapragada): In some cases Chrome produces an offer/answer\n  // with duplicate \"rtx\" payload mapping in media section. When applied,\n  // Chrome rejects the SDP. We workaround this by deleting duplicate\n  // \"rtx\" mappings found in SDP.\n  return Array.from(ptToCodecName.keys()).reduce(function (section, pt) {\n    var rtpmapRegex = new RegExp(\"^a=rtpmap:\" + pt + \" rtx.+$\", 'gm');\n    return (section.match(rtpmapRegex) || []).slice(ptToCodecName.get(pt) === 'rtx' ? 1 : 0).reduce(function (section, rtpmap) {\n      var rtpmapRegex = new RegExp(\"\\r\\n\" + rtpmap);\n      var fmtpmapRegex = new RegExp(\"\\r\\na=fmtp:\" + pt + \" apt=[0-9]+\");\n      return section.replace(rtpmapRegex, '').replace(fmtpmapRegex, '');\n    }, section);\n  }, mediaSection);\n}\n/**\n * @param {Map<PT, Codec>} ptToCodecName\n * @returns {Map<string, NonEmptySet<PT>>} codecNameToPts\n */\nfunction createCodecNameToPts(ptToCodecName) {\n  var codecNameToPts = new Map();\n  ptToCodecName.forEach(function (codecName, pt) {\n    var pts = codecNameToPts.get(codecName) || new Set();\n    return codecNameToPts.set(codecName, pts.add(pt));\n  });\n  return codecNameToPts;\n}\n/**\n * @param {string} mediaSection\n * @param {Map<PT, Codec>} ptToCodecName\n * @param {Set<RtxPT>} rtxPts\n * @param {Set<RtxPT>} invalidRtxPts\n * @returns {Map<RtxPT, NonRtxPT>} rtxPtToAssociatedPt\n */\nfunction createRtxPtToAssociatedPt(mediaSection, ptToCodecName, rtxPts, invalidRtxPts) {\n  return Array.from(rtxPts).reduce(function (rtxPtToAssociatedPt, rtxPt) {\n    var fmtpPattern = new RegExp(\"a=fmtp:\" + rtxPt + \" apt=(\\\\d+)\");\n    var matches = mediaSection.match(fmtpPattern);\n    if (!matches) {\n      invalidRtxPts.add(rtxPt);\n      return rtxPtToAssociatedPt;\n    }\n    var pt = Number.parseInt(matches[1]);\n    if (!ptToCodecName.has(pt)) {\n      // This is Issue 8329.\n      invalidRtxPts.add(rtxPt);\n      return rtxPtToAssociatedPt;\n    }\n    var codecName = ptToCodecName.get(pt);\n    if (codecName === 'rtx') {\n      // Strange\n      invalidRtxPts.add(rtxPt);\n      return rtxPtToAssociatedPt;\n    }\n    return rtxPtToAssociatedPt.set(rtxPt, pt);\n  }, new Map());\n}\n/**\n * @param {string} mediaSection\n * @param {Map<RtxPT, NonRtxPT>} rtxPtToAssociatedPt\n * @param {Set<RtxPT>} invalidRtxPts\n * @returns {Map<NonRtxPT, RtxPT>} associatedPtToRtxPt\n */\nfunction createAssociatedPtToRtxPt(rtxPtToAssociatedPt, invalidRtxPts) {\n  // First, we construct a Map<NonRtxPT, NonEmptySet<RtxPT>>.\n  var associatedPtToRtxPts = Array.from(rtxPtToAssociatedPt).reduce(function (associatedPtToRtxPts, pair) {\n    var rtxPt = pair[0];\n    var pt = pair[1];\n    var rtxPts = associatedPtToRtxPts.get(pt) || new Set();\n    return associatedPtToRtxPts.set(pt, rtxPts.add(rtxPt));\n  }, new Map());\n  // Then, we filter down to a Map<NonRtxPT, RtxPt>. Any RtxPTs that map to the\n  // same NonRtxPT are removed and added to invalidRtxPts.\n  return Array.from(associatedPtToRtxPts).reduce(function (associatedPtToRtxPt, pair) {\n    var pt = pair[0];\n    var rtxPts = Array.from(pair[1]);\n    if (rtxPts.length > 1) {\n      rtxPts.forEach(function (rtxPt) {\n        invalidRtxPts.add(rtxPt);\n      });\n      return associatedPtToRtxPt;\n    }\n    return associatedPtToRtxPt.set(pt, rtxPts[0]);\n  }, new Map());\n}\n/**\n * @param {string} mediaSection\n * @param {RtxPT} rtxPt\n * @returns {string} newMediaSection\n */\nfunction deleteFmtpAttributesForRtxPt(mediaSection, rtxPt) {\n  var pattern = new RegExp(\"a=fmtp:\" + rtxPt + \".*\\r\\n\", 'gm');\n  return mediaSection.replace(pattern, '');\n}\n/**\n * @param {string} mediaSection\n * @param {RtxPT} rtxPt\n * @returns {string} newMediaSection\n */\nfunction deleteRtpmapAttributesForRtxPt(mediaSection, rtxPt) {\n  var pattern = new RegExp(\"a=rtpmap:\" + rtxPt + \".*\\r\\n\", 'gm');\n  return mediaSection.replace(pattern, '');\n}\n/**\n * @param {string} mediaSection\n * @param {RtxPT} rtxPt\n * @param {NonRtxPT} pt\n * @returns {string} newMediaSection\n */\nfunction addFmtpAttributeForRtxPt(mediaSection, rtxPt, pt) {\n  return mediaSection.endsWith('\\r\\n') ? mediaSection + \"a=fmtp:\" + rtxPt + \" apt=\" + pt + \"\\r\\n\" : mediaSection + \"\\r\\na=fmtp:\" + rtxPt + \" apt=\" + pt;\n}\nmodule.exports = workaround;","map":{"version":3,"names":["RTCSessionDescription","require","_a","createPtToCodecName","getMediaSections","workaround","description","descriptionInit","type","sdp","sdpWorkaround","mediaSections","session","split","concat","map","mediaSectionWorkaround","join","mediaSection","ptToCodecName","deleteDuplicateRtxPts","codecNameToPts","createCodecNameToPts","rtxPts","get","Set","invalidRtxPts","rtxPtToAssociatedPt","createRtxPtToAssociatedPt","associatedPtToRtxPt","createAssociatedPtToRtxPt","unassociatedRtxPts","Array","from","knownCodecNames","unassociatedPts","reduce","codecName","pts","pt","has","add","forEach","length","rtxPt","shift","deleteFmtpAttributesForRtxPt","addFmtpAttributeForRtxPt","deleteRtpmapAttributesForRtxPt","keys","section","rtpmapRegex","RegExp","match","slice","rtpmap","fmtpmapRegex","replace","Map","set","fmtpPattern","matches","Number","parseInt","associatedPtToRtxPts","pair","pattern","endsWith","module","exports"],"sources":["/home/denis/RiderProjects/ChatRoulette/WebUI/chat-app/node_modules/twilio-video/lib/util/sdp/issue8329.js"],"sourcesContent":["'use strict';\n\nconst { RTCSessionDescription } = require('../../webrtc');\n\nconst { createPtToCodecName, getMediaSections } = require('./');\n\n/**\n * An RTX payload type\n * @typedef {PT} RtxPT\n */\n\n/**\n * A non-RTX payload type\n * @typedef {PT} NonRtxPT\n */\n\n/**\n * A Set with at least one element\n * @typedef {Set} NonEmptySet\n */\n\n/**\n * Apply the workaround for Issue 8329 to an RTCSessionDescriptionInit.\n * @param {RTCSessionDescriptionInit} description\n * @returns {RTCSessionDescription} newDescription\n */\nfunction workaround(description) {\n  const descriptionInit = { type: description.type };\n  if (description.type !== 'rollback') {\n    descriptionInit.sdp = sdpWorkaround(description.sdp);\n  }\n  return new RTCSessionDescription(descriptionInit);\n}\n\n/**\n * @param {string} sdp\n * @returns {string} newSdp\n */\nfunction sdpWorkaround(sdp) {\n  const mediaSections = getMediaSections(sdp);\n  const session = sdp.split('\\r\\nm=')[0];\n  return [session]\n    .concat(mediaSections.map(mediaSectionWorkaround))\n    .join('\\r\\n');\n}\n\n/**\n * @param {string} mediaSection\n * @returns {string} newMediaSection\n */\nfunction mediaSectionWorkaround(mediaSection) {\n  const ptToCodecName = createPtToCodecName(mediaSection);\n  mediaSection = deleteDuplicateRtxPts(mediaSection, ptToCodecName);\n  const codecNameToPts = createCodecNameToPts(ptToCodecName);\n  const rtxPts = codecNameToPts.get('rtx') || new Set();\n\n  const invalidRtxPts = new Set();\n  const rtxPtToAssociatedPt = createRtxPtToAssociatedPt(\n    mediaSection, ptToCodecName, rtxPts, invalidRtxPts);\n  const associatedPtToRtxPt = createAssociatedPtToRtxPt(\n    rtxPtToAssociatedPt, invalidRtxPts);\n\n  const unassociatedRtxPts = Array.from(invalidRtxPts);\n\n  // NOTE(mroberts): We normalize to lowercase.\n  const knownCodecNames = ['h264', 'vp8', 'vp9'];\n  const unassociatedPts = knownCodecNames.reduce((unassociatedPts, codecName) => {\n    const pts = codecNameToPts.get(codecName) || new Set();\n    return Array.from(pts).reduce((unassociatedPts, pt) => associatedPtToRtxPt.has(pt)\n      ? unassociatedPts\n      : unassociatedPts.add(pt), unassociatedPts);\n  }, new Set());\n\n  unassociatedPts.forEach(pt => {\n    if (unassociatedRtxPts.length) {\n      const rtxPt = unassociatedRtxPts.shift();\n      mediaSection = deleteFmtpAttributesForRtxPt(mediaSection, rtxPt);\n      mediaSection = addFmtpAttributeForRtxPt(mediaSection, rtxPt, pt);\n    }\n  });\n\n  unassociatedRtxPts.forEach(rtxPt => {\n    mediaSection = deleteFmtpAttributesForRtxPt(mediaSection, rtxPt);\n    mediaSection = deleteRtpmapAttributesForRtxPt(mediaSection, rtxPt);\n  });\n\n  return mediaSection;\n}\n\n/**\n * @param {string} mediaSection\n * @param {Map<PT, Codec>} ptToCodecName\n * @returns {string} newMediaSection\n */\nfunction deleteDuplicateRtxPts(mediaSection, ptToCodecName) {\n  // NOTE(syerrapragada): In some cases Chrome produces an offer/answer\n  // with duplicate \"rtx\" payload mapping in media section. When applied,\n  // Chrome rejects the SDP. We workaround this by deleting duplicate\n  // \"rtx\" mappings found in SDP.\n  return Array.from(ptToCodecName.keys()).reduce((section, pt) => {\n    const rtpmapRegex = new RegExp(`^a=rtpmap:${pt} rtx.+$`, 'gm');\n    return (section.match(rtpmapRegex) || []).slice(ptToCodecName.get(pt) === 'rtx' ? 1 : 0).reduce((section, rtpmap) => {\n      const rtpmapRegex = new RegExp(`\\r\\n${rtpmap}`);\n      const fmtpmapRegex = new RegExp(`\\r\\na=fmtp:${pt} apt=[0-9]+`);\n      return section.replace(rtpmapRegex, '').replace(fmtpmapRegex, '');\n    }, section);\n  }, mediaSection);\n}\n\n/**\n * @param {Map<PT, Codec>} ptToCodecName\n * @returns {Map<string, NonEmptySet<PT>>} codecNameToPts\n */\nfunction createCodecNameToPts(ptToCodecName) {\n  const codecNameToPts = new Map();\n  ptToCodecName.forEach((codecName, pt) => {\n    const pts = codecNameToPts.get(codecName) || new Set();\n    return codecNameToPts.set(codecName, pts.add(pt));\n  });\n  return codecNameToPts;\n}\n\n/**\n * @param {string} mediaSection\n * @param {Map<PT, Codec>} ptToCodecName\n * @param {Set<RtxPT>} rtxPts\n * @param {Set<RtxPT>} invalidRtxPts\n * @returns {Map<RtxPT, NonRtxPT>} rtxPtToAssociatedPt\n */\nfunction createRtxPtToAssociatedPt(mediaSection, ptToCodecName, rtxPts, invalidRtxPts) {\n  return Array.from(rtxPts).reduce((rtxPtToAssociatedPt, rtxPt) => {\n    const fmtpPattern = new RegExp(`a=fmtp:${rtxPt} apt=(\\\\d+)`);\n    const matches = mediaSection.match(fmtpPattern);\n    if (!matches) {\n      invalidRtxPts.add(rtxPt);\n      return rtxPtToAssociatedPt;\n    }\n\n    const pt = Number.parseInt(matches[1]);\n    if (!ptToCodecName.has(pt)) {\n      // This is Issue 8329.\n      invalidRtxPts.add(rtxPt);\n      return rtxPtToAssociatedPt;\n    }\n\n    const codecName = ptToCodecName.get(pt);\n    if (codecName === 'rtx') {\n      // Strange\n      invalidRtxPts.add(rtxPt);\n      return rtxPtToAssociatedPt;\n    }\n\n    return rtxPtToAssociatedPt.set(rtxPt, pt);\n  }, new Map());\n}\n\n/**\n * @param {string} mediaSection\n * @param {Map<RtxPT, NonRtxPT>} rtxPtToAssociatedPt\n * @param {Set<RtxPT>} invalidRtxPts\n * @returns {Map<NonRtxPT, RtxPT>} associatedPtToRtxPt\n */\nfunction createAssociatedPtToRtxPt(rtxPtToAssociatedPt, invalidRtxPts) {\n  // First, we construct a Map<NonRtxPT, NonEmptySet<RtxPT>>.\n  const associatedPtToRtxPts = Array.from(rtxPtToAssociatedPt).reduce((associatedPtToRtxPts, pair) => {\n    const rtxPt = pair[0];\n    const pt = pair[1];\n    const rtxPts = associatedPtToRtxPts.get(pt) || new Set();\n    return associatedPtToRtxPts.set(pt, rtxPts.add(rtxPt));\n  }, new Map());\n\n  // Then, we filter down to a Map<NonRtxPT, RtxPt>. Any RtxPTs that map to the\n  // same NonRtxPT are removed and added to invalidRtxPts.\n  return Array.from(associatedPtToRtxPts).reduce((associatedPtToRtxPt, pair) => {\n    const pt = pair[0];\n    const rtxPts = Array.from(pair[1]);\n    if (rtxPts.length > 1) {\n      rtxPts.forEach(rtxPt => {\n        invalidRtxPts.add(rtxPt);\n      });\n      return associatedPtToRtxPt;\n    }\n    return associatedPtToRtxPt.set(pt, rtxPts[0]);\n  }, new Map());\n}\n\n/**\n * @param {string} mediaSection\n * @param {RtxPT} rtxPt\n * @returns {string} newMediaSection\n */\nfunction deleteFmtpAttributesForRtxPt(mediaSection, rtxPt) {\n  const pattern = new RegExp(`a=fmtp:${rtxPt}.*\\r\\n`, 'gm');\n  return mediaSection.replace(pattern, '');\n}\n\n/**\n * @param {string} mediaSection\n * @param {RtxPT} rtxPt\n * @returns {string} newMediaSection\n */\nfunction deleteRtpmapAttributesForRtxPt(mediaSection, rtxPt) {\n  const pattern = new RegExp(`a=rtpmap:${rtxPt}.*\\r\\n`, 'gm');\n  return mediaSection.replace(pattern, '');\n}\n\n/**\n * @param {string} mediaSection\n * @param {RtxPT} rtxPt\n * @param {NonRtxPT} pt\n * @returns {string} newMediaSection\n */\nfunction addFmtpAttributeForRtxPt(mediaSection, rtxPt, pt) {\n  return mediaSection.endsWith('\\r\\n')\n    ? `${mediaSection}a=fmtp:${rtxPt} apt=${pt}\\r\\n`\n    : `${mediaSection}\\r\\na=fmtp:${rtxPt} apt=${pt}`;\n}\n\nmodule.exports = workaround;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}