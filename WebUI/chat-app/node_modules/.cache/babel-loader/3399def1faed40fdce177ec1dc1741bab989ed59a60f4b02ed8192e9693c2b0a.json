{"ast":null,"code":"/* globals RTCDataChannel, RTCPeerConnection, RTCSessionDescription */\n'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nvar ChromeRTCSessionDescription = require('../rtcsessiondescription/chrome');\nvar EventTarget = require('../../eventtarget');\nvar Latch = require('../util/latch');\nvar MediaStream = require('../mediastream');\nvar RTCRtpSenderShim = require('../rtcrtpsender');\nvar _a = require('../util/sdp'),\n  getSdpFormat = _a.getSdpFormat,\n  updatePlanBTrackIdsToSSRCs = _a.updatePlanBTrackIdsToSSRCs,\n  updateUnifiedPlanTrackIdsToSSRCs = _a.updateUnifiedPlanTrackIdsToSSRCs;\nvar _b = require('../util'),\n  delegateMethods = _b.delegateMethods,\n  interceptEvent = _b.interceptEvent,\n  isIOSChrome = _b.isIOSChrome,\n  legacyPromise = _b.legacyPromise,\n  proxyProperties = _b.proxyProperties;\nvar isUnifiedPlan = getSdpFormat() === 'unified';\n// NOTE(mroberts): This class wraps Chrome's RTCPeerConnection implementation.\n// It provides some functionality not currently present in Chrome, namely the\n// abilities to\n//\n//   1. Rollback, per the workaround suggested here:\n//      https://bugs.chromium.org/p/webrtc/issues/detail?id=5738#c3\n//\n//   2. Listen for track events, per the adapter.js workaround.\n//\n//   3. Set iceTransportPolicy.\n//\nvar ChromeRTCPeerConnection = /** @class */function (_super) {\n  __extends(ChromeRTCPeerConnection, _super);\n  function ChromeRTCPeerConnection(configuration, constraints) {\n    if (configuration === void 0) {\n      configuration = {};\n    }\n    var _this = _super.call(this) || this;\n    var newConfiguration = Object.assign(configuration.iceTransportPolicy ? {\n      iceTransports: configuration.iceTransportPolicy\n    } : {}, configuration);\n    interceptEvent(_this, 'datachannel');\n    interceptEvent(_this, 'signalingstatechange');\n    var sdpFormat = getSdpFormat(newConfiguration.sdpSemantics);\n    var peerConnection = new RTCPeerConnection(newConfiguration, constraints);\n    Object.defineProperties(_this, {\n      _appliedTracksToSSRCs: {\n        value: new Map(),\n        writable: true\n      },\n      _localStream: {\n        value: new MediaStream()\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _pendingLocalOffer: {\n        value: null,\n        writable: true\n      },\n      _pendingRemoteOffer: {\n        value: null,\n        writable: true\n      },\n      _rolledBackTracksToSSRCs: {\n        value: new Map(),\n        writable: true\n      },\n      _sdpFormat: {\n        value: sdpFormat\n      },\n      _senders: {\n        value: new Map()\n      },\n      _signalingStateLatch: {\n        value: new Latch()\n      },\n      _tracksToSSRCs: {\n        value: new Map(),\n        writable: true\n      }\n    });\n    peerConnection.addEventListener('datachannel', function (event) {\n      shimDataChannel(event.channel);\n      _this.dispatchEvent(event);\n    });\n    peerConnection.addEventListener('signalingstatechange', function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      if (peerConnection.signalingState === 'stable') {\n        _this._appliedTracksToSSRCs = new Map(_this._tracksToSSRCs);\n      }\n      if (!_this._pendingLocalOffer && !_this._pendingRemoteOffer) {\n        _this.dispatchEvent.apply(_this, __spreadArray([], __read(args)));\n      }\n    });\n    peerConnection.ontrack = function () {\n      // NOTE(mroberts): adapter.js's \"track\" event shim only kicks off if we set\n      // the ontrack property of the RTCPeerConnection.\n    };\n    if (typeof peerConnection.addTrack !== 'function') {\n      peerConnection.addStream(_this._localStream);\n    }\n    proxyProperties(RTCPeerConnection.prototype, _this, peerConnection);\n    return _this;\n  }\n  Object.defineProperty(ChromeRTCPeerConnection.prototype, \"localDescription\", {\n    get: function () {\n      return this._pendingLocalOffer ? this._pendingLocalOffer : this._peerConnection.localDescription;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ChromeRTCPeerConnection.prototype, \"remoteDescription\", {\n    get: function () {\n      return this._pendingRemoteOffer ? this._pendingRemoteOffer : this._peerConnection.remoteDescription;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ChromeRTCPeerConnection.prototype, \"signalingState\", {\n    get: function () {\n      if (this._pendingLocalOffer) {\n        return 'have-local-offer';\n      } else if (this._pendingRemoteOffer) {\n        return 'have-remote-offer';\n      }\n      return this._peerConnection.signalingState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  // NOTE(mmalavalli): This shim supports our limited case of adding\n  // all MediaStreamTracks to one MediaStream. It has been implemented this\n  // keeping in mind that this is to be maintained only until \"addTrack\" is\n  // supported natively in Chrome.\n  ChromeRTCPeerConnection.prototype.addTrack = function (track) {\n    var _a;\n    var rest = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      rest[_i - 1] = arguments[_i];\n    }\n    if (typeof this._peerConnection.addTrack === 'function') {\n      return (_a = this._peerConnection).addTrack.apply(_a, __spreadArray([track], __read(rest)));\n    }\n    if (this._peerConnection.signalingState === 'closed') {\n      throw new Error(\"Cannot add MediaStreamTrack [\" + track.id + \", \\n        \" + track.kind + \"]: RTCPeerConnection is closed\");\n    }\n    var sender = this._senders.get(track);\n    if (sender && sender.track) {\n      throw new Error(\"Cannot add MediaStreamTrack ['\" + track.id + \", \\n        \" + track.kind + \"]: RTCPeerConnection already has it\");\n    }\n    this._peerConnection.removeStream(this._localStream);\n    this._localStream.addTrack(track);\n    this._peerConnection.addStream(this._localStream);\n    sender = new RTCRtpSenderShim(track);\n    this._senders.set(track, sender);\n    return sender;\n  };\n  // NOTE(mmalavalli): This shim supports our limited case of removing\n  // MediaStreamTracks from one MediaStream. It has been implemented this\n  // keeping in mind that this is to be maintained only until \"removeTrack\" is\n  // supported natively in Chrome.\n  ChromeRTCPeerConnection.prototype.removeTrack = function (sender) {\n    if (this._peerConnection.signalingState === 'closed') {\n      throw new Error('Cannot remove MediaStreamTrack: RTCPeerConnection is closed');\n    }\n    if (typeof this._peerConnection.addTrack === 'function') {\n      try {\n        return this._peerConnection.removeTrack(sender);\n      } catch (e) {\n        // NOTE(mhuynh): Do nothing. In Chrome, will throw if a 'sender was not\n        // created by this peer connection'. This behavior does not seem to be\n        // spec compliant, so a temporary shim is introduced. A bug has been filed,\n        // and is tracked here:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=860853\n      }\n    } else {\n      var track = sender.track;\n      if (!track) {\n        return;\n      }\n      sender = this._senders.get(track);\n      if (sender && sender.track) {\n        sender.track = null;\n        this._peerConnection.removeStream(this._localStream);\n        this._localStream.removeTrack(track);\n        this._peerConnection.addStream(this._localStream);\n      }\n    }\n  };\n  ChromeRTCPeerConnection.prototype.getSenders = function () {\n    if (typeof this._peerConnection.addTrack === 'function') {\n      return this._peerConnection.getSenders();\n    }\n    return Array.from(this._senders.values());\n  };\n  ChromeRTCPeerConnection.prototype.addIceCandidate = function (candidate) {\n    var _this = this;\n    var rest = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      rest[_i - 1] = arguments[_i];\n    }\n    var promise;\n    if (this.signalingState === 'have-remote-offer') {\n      // NOTE(mroberts): Because the ChromeRTCPeerConnection simulates the\n      // \"have-remote-offer\" signalingStates, we only want to invoke the true\n      // addIceCandidates method when the remote description has been applied.\n      promise = this._signalingStateLatch.when('low').then(function () {\n        return _this._peerConnection.addIceCandidate(candidate);\n      });\n    } else {\n      promise = this._peerConnection.addIceCandidate(candidate);\n    }\n    return rest.length > 0 ? legacyPromise.apply(void 0, __spreadArray([promise], __read(rest))) : promise;\n  };\n  // NOTE(mroberts): The WebRTC spec does not specify that close should throw an\n  // Error; however, in Chrome it does. We workaround this by checking the\n  // signalingState manually.\n  ChromeRTCPeerConnection.prototype.close = function () {\n    if (this.signalingState !== 'closed') {\n      this._pendingLocalOffer = null;\n      this._pendingRemoteOffer = null;\n      this._peerConnection.close();\n    }\n  };\n  // NOTE(mroberts): Because we workaround Chrome's lack of rollback support by\n  // \"faking\" setRemoteDescription, we cannot create an answer until we actually\n  // apply the remote description. This means, once you call createAnswer, you\n  // can no longer rollback. This is acceptable for our use case because we will\n  // apply the newly-created answer almost immediately; however, this may be\n  // unacceptable for other use cases.\n  ChromeRTCPeerConnection.prototype.createAnswer = function () {\n    var _this = this;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var promise;\n    if (this._pendingRemoteOffer) {\n      promise = this._peerConnection.setRemoteDescription(this._pendingRemoteOffer).then(function () {\n        // NOTE(mroberts): The signalingStates between the ChromeRTCPeerConnection\n        // and the underlying RTCPeerConnection implementation have converged. We\n        // can unblock any pending calls to addIceCandidate now.\n        _this._signalingStateLatch.lower();\n        return _this._peerConnection.createAnswer();\n      }).then(function (answer) {\n        _this._pendingRemoteOffer = null;\n        // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n        // longer need to retain the rolled back tracks to SSRCs Map.\n        _this._rolledBackTracksToSSRCs.clear();\n        return new ChromeRTCSessionDescription({\n          type: 'answer',\n          sdp: updateTrackIdsToSSRCs(_this._sdpFormat, _this._tracksToSSRCs, answer.sdp)\n        });\n      }, function (error) {\n        _this._pendingRemoteOffer = null;\n        throw error;\n      });\n    } else {\n      promise = this._peerConnection.createAnswer().then(function (answer) {\n        // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n        // longer need to retain the rolled back tracks to SSRCs Map.\n        _this._rolledBackTracksToSSRCs.clear();\n        return new ChromeRTCSessionDescription({\n          type: 'answer',\n          sdp: updateTrackIdsToSSRCs(_this._sdpFormat, _this._tracksToSSRCs, answer.sdp)\n        });\n      });\n    }\n    return args.length > 1 ? legacyPromise.apply(void 0, __spreadArray([promise], __read(args))) : promise;\n  };\n  ChromeRTCPeerConnection.prototype.createOffer = function () {\n    var _this = this;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var _a = __read(args, 3),\n      arg1 = _a[0],\n      arg2 = _a[1],\n      arg3 = _a[2];\n    var options = arg3 || arg1 || {};\n    if (isIOSChrome()) {\n      // NOTE (joma): From SafariRTCPeerConnection in order to support iOS Chrome.\n      if (options.offerToReceiveVideo && !this._audioTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'audio'))) {\n        delete options.offerToReceiveAudio;\n        try {\n          this._audioTransceiver = isUnifiedPlan ? this.addTransceiver('audio', {\n            direction: 'recvonly'\n          }) : this.addTransceiver('audio');\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n      if (options.offerToReceiveVideo && !this._videoTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'video'))) {\n        delete options.offerToReceiveVideo;\n        try {\n          this._videoTransceiver = isUnifiedPlan ? this.addTransceiver('video', {\n            direction: 'recvonly'\n          }) : this.addTransceiver('video');\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }\n    var promise = this._peerConnection.createOffer(options).then(function (offer) {\n      // NOTE(mmalavalli): If createOffer() is called immediately after rolling back, then we no\n      // longer need to retain the rolled back tracks to SSRCs Map.\n      _this._rolledBackTracksToSSRCs.clear();\n      return new ChromeRTCSessionDescription({\n        type: offer.type,\n        sdp: updateTrackIdsToSSRCs(_this._sdpFormat, _this._tracksToSSRCs, offer.sdp)\n      });\n    });\n    return args.length > 1 ? legacyPromise(promise, arg1, arg2) : promise;\n  };\n  ChromeRTCPeerConnection.prototype.createDataChannel = function (label, dataChannelDict) {\n    dataChannelDict = shimDataChannelInit(dataChannelDict);\n    var dataChannel = this._peerConnection.createDataChannel(label, dataChannelDict);\n    shimDataChannel(dataChannel);\n    return dataChannel;\n  };\n  ChromeRTCPeerConnection.prototype.setLocalDescription = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var _a = __read(args, 3),\n      description = _a[0],\n      arg1 = _a[1],\n      arg2 = _a[2];\n    // NOTE(mmalavalli): If setLocalDescription() is called immediately after rolling back,\n    // then we need to restore the rolled back tracks to SSRCs Map.\n    if (this._rolledBackTracksToSSRCs.size > 0) {\n      this._tracksToSSRCs = new Map(this._rolledBackTracksToSSRCs);\n      this._rolledBackTracksToSSRCs.clear();\n    }\n    var promise = setDescription(this, true, description);\n    return args.length > 1 ? legacyPromise(promise, arg1, arg2) : promise;\n  };\n  ChromeRTCPeerConnection.prototype.setRemoteDescription = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var _a = __read(args, 3),\n      description = _a[0],\n      arg1 = _a[1],\n      arg2 = _a[2];\n    // NOTE(mmalavalli): If setRemoteDescription() is called immediately after rolling back,\n    // then we no longer need to retain the rolled back tracks to SSRCs Map.\n    this._rolledBackTracksToSSRCs.clear();\n    var promise = setDescription(this, false, description);\n    return args.length > 1 ? legacyPromise(promise, arg1, arg2) : promise;\n  };\n  return ChromeRTCPeerConnection;\n}(EventTarget);\ndelegateMethods(RTCPeerConnection.prototype, ChromeRTCPeerConnection.prototype, '_peerConnection');\n// NOTE(mroberts): We workaround Chrome's lack of rollback support, per the\n// workaround suggested here: https://bugs.chromium.org/p/webrtc/issues/detail?id=5738#c3\n// Namely, we \"fake\" setting the local or remote description and instead buffer\n// it. If we receive or create an answer, then we will actually apply the\n// description. Until we receive or create an answer, we will be able to\n// \"rollback\" by simply discarding the buffer description.\nfunction setDescription(peerConnection, local, description) {\n  function setPendingLocalOffer(offer) {\n    if (local) {\n      peerConnection._pendingLocalOffer = offer;\n    } else {\n      peerConnection._pendingRemoteOffer = offer;\n    }\n  }\n  function clearPendingLocalOffer() {\n    if (local) {\n      peerConnection._pendingLocalOffer = null;\n    } else {\n      peerConnection._pendingRemoteOffer = null;\n    }\n  }\n  var pendingLocalOffer = local ? peerConnection._pendingLocalOffer : peerConnection._pendingRemoteOffer;\n  var pendingRemoteOffer = local ? peerConnection._pendingRemoteOffer : peerConnection._pendingLocalOffer;\n  var intermediateState = local ? 'have-local-offer' : 'have-remote-offer';\n  var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n  var promise;\n  if (!local && pendingRemoteOffer && description.type === 'answer') {\n    promise = setRemoteAnswer(peerConnection, description);\n  } else if (description.type === 'offer') {\n    if (peerConnection.signalingState !== intermediateState && peerConnection.signalingState !== 'stable') {\n      // NOTE(mroberts): Error message copied from Firefox.\n      return Promise.reject(new Error(\"Cannot set \" + (local ? 'local' : 'remote') + \" offer in state \" + peerConnection.signalingState));\n    }\n    // We need to save this local offer in case of a rollback. We also need to\n    // check to see if the signalingState between the ChromeRTCPeerConnection\n    // and the underlying RTCPeerConnection implementation are about to diverge.\n    // If so, we need to ensure subsequent calls to addIceCandidate will block.\n    if (!pendingLocalOffer && peerConnection._signalingStateLatch.state === 'low') {\n      peerConnection._signalingStateLatch.raise();\n    }\n    var previousSignalingState = peerConnection.signalingState;\n    setPendingLocalOffer(unwrap(description));\n    promise = Promise.resolve();\n    // Only dispatch a signalingstatechange event if we transitioned.\n    if (peerConnection.signalingState !== previousSignalingState) {\n      promise.then(function () {\n        return peerConnection.dispatchEvent(new Event('signalingstatechange'));\n      });\n    }\n  } else if (description.type === 'rollback') {\n    if (peerConnection.signalingState !== intermediateState) {\n      // NOTE(mroberts): Error message copied from Firefox.\n      promise = Promise.reject(new Error(\"Cannot rollback \" + (local ? 'local' : 'remote') + \" description in \" + peerConnection.signalingState));\n    } else {\n      // Reset the pending offer.\n      clearPendingLocalOffer();\n      // NOTE(mmalavalli): We store the rolled back tracks to SSRCs Map here in case\n      // setLocalDescription() is called immediately after a rollback (without calling\n      // createOffer() or createAnswer()), in which case this roll back is not due to a\n      // glare scenario and this Map should be restored.\n      peerConnection._rolledBackTracksToSSRCs = new Map(peerConnection._tracksToSSRCs);\n      peerConnection._tracksToSSRCs = new Map(peerConnection._appliedTracksToSSRCs);\n      promise = Promise.resolve();\n      promise.then(function () {\n        return peerConnection.dispatchEvent(new Event('signalingstatechange'));\n      });\n    }\n  }\n  return promise || peerConnection._peerConnection[setLocalDescription](unwrap(description));\n}\nfunction setRemoteAnswer(peerConnection, answer) {\n  // Apply the pending local offer.\n  var pendingLocalOffer = peerConnection._pendingLocalOffer;\n  return peerConnection._peerConnection.setLocalDescription(pendingLocalOffer).then(function () {\n    peerConnection._pendingLocalOffer = null;\n    return peerConnection.setRemoteDescription(answer);\n  }).then(function () {\n    // NOTE(mroberts): The signalingStates between the ChromeRTCPeerConnection\n    // and the underlying RTCPeerConnection implementation have converged. We\n    // can unblock any pending calls to addIceCandidate now.\n    peerConnection._signalingStateLatch.lower();\n  });\n}\n/**\n * Whether a ChromeRTCPeerConnection has any RTCRtpReceivers(s) for the given\n * MediaStreamTrack kind.\n * @param {ChromeRTCPeerConnection} peerConnection\n * @param {'audio' | 'video'} kind\n * @returns {boolean}\n */\nfunction hasReceiversForTracksOfKind(peerConnection, kind) {\n  return !!peerConnection.getTransceivers().find(function (_a) {\n    var _b = _a.receiver,\n      receiver = _b === void 0 ? {} : _b;\n    var _c = receiver.track,\n      track = _c === void 0 ? {} : _c;\n    return track.kind === kind;\n  });\n}\nfunction unwrap(description) {\n  if (description instanceof ChromeRTCSessionDescription) {\n    if (description._description) {\n      return description._description;\n    }\n  }\n  return new RTCSessionDescription(description);\n}\n/**\n * Check whether or not we need to apply our maxPacketLifeTime shim. We are\n * pretty conservative: we'll only apply it if the legacy maxRetransmitTime\n * property is available _and_ the standard maxPacketLifeTime property is _not_\n * available (the thinking being that Chrome will land the standards-compliant\n * property).\n * @returns {boolean}\n */\nfunction needsMaxPacketLifeTimeShim() {\n  return 'maxRetransmitTime' in RTCDataChannel.prototype && !('maxPacketLifeTime' in RTCDataChannel.prototype);\n}\n/**\n * Shim an RTCDataChannelInit dictionary (if necessary). This function returns\n * a copy of the original RTCDataChannelInit.\n * @param {RTCDataChannelInit} dataChannelDict\n * @returns {RTCDataChannelInit}\n */\nfunction shimDataChannelInit(dataChannelDict) {\n  dataChannelDict = Object.assign({}, dataChannelDict);\n  if (needsMaxPacketLifeTimeShim() && 'maxPacketLifeTime' in dataChannelDict) {\n    dataChannelDict.maxRetransmitTime = dataChannelDict.maxPacketLifeTime;\n  }\n  return dataChannelDict;\n}\n/**\n * Shim an RTCDataChannel (if necessary). This function mutates the\n * RTCDataChannel.\n * @param {RTCDataChannel} dataChannel\n * @returns {RTCDataChannel}\n */\nfunction shimDataChannel(dataChannel) {\n  Object.defineProperty(dataChannel, 'maxRetransmits', {\n    value: dataChannel.maxRetransmits === 65535 ? null : dataChannel.maxRetransmits\n  });\n  if (needsMaxPacketLifeTimeShim()) {\n    // NOTE(mroberts): We can rename `maxRetransmitTime` to `maxPacketLifeTime`.\n    //\n    //   https://bugs.chromium.org/p/chromium/issues/detail?id=696681\n    //\n    Object.defineProperty(dataChannel, 'maxPacketLifeTime', {\n      value: dataChannel.maxRetransmitTime === 65535 ? null : dataChannel.maxRetransmitTime\n    });\n  }\n  return dataChannel;\n}\n/**\n * Update the mappings from MediaStreamTrack IDs to SSRCs as indicated by both\n * the Map from MediaStreamTrack IDs to SSRCs and the SDP itself. This method\n * ensures that SSRCs never change once announced.\n * @param {'planb'|'unified'} sdpFormat\n * @param {Map<string, Set<string>>} tracksToSSRCs\n * @param {string} sdp - an SDP whose format is determined by `sdpSemantics`\n * @returns {string} updatedSdp - updated SDP\n */\nfunction updateTrackIdsToSSRCs(sdpFormat, tracksToSSRCs, sdp) {\n  return sdpFormat === 'unified' ? updateUnifiedPlanTrackIdsToSSRCs(tracksToSSRCs, sdp) : updatePlanBTrackIdsToSSRCs(tracksToSSRCs, sdp);\n}\nmodule.exports = ChromeRTCPeerConnection;","map":{"version":3,"names":["ChromeRTCSessionDescription","require","EventTarget","Latch","MediaStream","RTCRtpSenderShim","_a","getSdpFormat","updatePlanBTrackIdsToSSRCs","updateUnifiedPlanTrackIdsToSSRCs","_b","delegateMethods","interceptEvent","isIOSChrome","legacyPromise","proxyProperties","isUnifiedPlan","ChromeRTCPeerConnection","_super","__extends","configuration","constraints","_this","call","newConfiguration","Object","assign","iceTransportPolicy","iceTransports","sdpFormat","sdpSemantics","peerConnection","RTCPeerConnection","defineProperties","_appliedTracksToSSRCs","value","Map","writable","_localStream","_peerConnection","_pendingLocalOffer","_pendingRemoteOffer","_rolledBackTracksToSSRCs","_sdpFormat","_senders","_signalingStateLatch","_tracksToSSRCs","addEventListener","event","shimDataChannel","channel","dispatchEvent","args","_i","arguments","length","signalingState","apply","__spreadArray","__read","ontrack","addTrack","addStream","prototype","defineProperty","get","localDescription","remoteDescription","track","rest","Error","id","kind","sender","removeStream","set","removeTrack","e","getSenders","Array","from","values","addIceCandidate","candidate","promise","when","then","close","createAnswer","setRemoteDescription","lower","answer","clear","type","sdp","updateTrackIdsToSSRCs","error","createOffer","arg1","arg2","arg3","options","offerToReceiveVideo","_audioTransceiver","hasReceiversForTracksOfKind","offerToReceiveAudio","addTransceiver","direction","Promise","reject","_videoTransceiver","offer","createDataChannel","label","dataChannelDict","shimDataChannelInit","dataChannel","setLocalDescription","description","size","setDescription","local","setPendingLocalOffer","clearPendingLocalOffer","pendingLocalOffer","pendingRemoteOffer","intermediateState","setRemoteAnswer","state","raise","previousSignalingState","unwrap","resolve","Event","getTransceivers","find","receiver","_c","_description","RTCSessionDescription","needsMaxPacketLifeTimeShim","RTCDataChannel","maxRetransmitTime","maxPacketLifeTime","maxRetransmits","tracksToSSRCs","module","exports"],"sources":["/home/denis/RiderProjects/ChatRoulette/WebUI/chat-app/node_modules/twilio-video/lib/webrtc/rtcpeerconnection/chrome.js"],"sourcesContent":["/* globals RTCDataChannel, RTCPeerConnection, RTCSessionDescription */\n'use strict';\n\nconst ChromeRTCSessionDescription = require('../rtcsessiondescription/chrome');\nconst EventTarget = require('../../eventtarget');\nconst Latch = require('../util/latch');\nconst MediaStream = require('../mediastream');\nconst RTCRtpSenderShim = require('../rtcrtpsender');\nconst { getSdpFormat, updatePlanBTrackIdsToSSRCs, updateUnifiedPlanTrackIdsToSSRCs } = require('../util/sdp');\nconst { delegateMethods, interceptEvent, isIOSChrome, legacyPromise, proxyProperties } = require('../util');\n\nconst isUnifiedPlan = getSdpFormat() === 'unified';\n\n// NOTE(mroberts): This class wraps Chrome's RTCPeerConnection implementation.\n// It provides some functionality not currently present in Chrome, namely the\n// abilities to\n//\n//   1. Rollback, per the workaround suggested here:\n//      https://bugs.chromium.org/p/webrtc/issues/detail?id=5738#c3\n//\n//   2. Listen for track events, per the adapter.js workaround.\n//\n//   3. Set iceTransportPolicy.\n//\nclass ChromeRTCPeerConnection extends EventTarget {\n  constructor(configuration = {}, constraints) {\n    super();\n\n    const newConfiguration = Object.assign(configuration.iceTransportPolicy\n      ? { iceTransports: configuration.iceTransportPolicy }\n      : {}, configuration);\n\n    interceptEvent(this, 'datachannel');\n    interceptEvent(this, 'signalingstatechange');\n    const sdpFormat = getSdpFormat(newConfiguration.sdpSemantics);\n    const peerConnection = new RTCPeerConnection(newConfiguration, constraints);\n\n    Object.defineProperties(this, {\n      _appliedTracksToSSRCs: {\n        value: new Map(),\n        writable: true\n      },\n      _localStream: {\n        value: new MediaStream()\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _pendingLocalOffer: {\n        value: null,\n        writable: true\n      },\n      _pendingRemoteOffer: {\n        value: null,\n        writable: true\n      },\n      _rolledBackTracksToSSRCs: {\n        value: new Map(),\n        writable: true\n      },\n      _sdpFormat: {\n        value: sdpFormat\n      },\n      _senders: {\n        value: new Map()\n      },\n      _signalingStateLatch: {\n        value: new Latch()\n      },\n      _tracksToSSRCs: {\n        value: new Map(),\n        writable: true\n      }\n    });\n\n    peerConnection.addEventListener('datachannel', event => {\n      shimDataChannel(event.channel);\n      this.dispatchEvent(event);\n    });\n\n    peerConnection.addEventListener('signalingstatechange', (...args) => {\n      if (peerConnection.signalingState === 'stable') {\n        this._appliedTracksToSSRCs = new Map(this._tracksToSSRCs);\n      }\n      if (!this._pendingLocalOffer && !this._pendingRemoteOffer) {\n        this.dispatchEvent(...args);\n      }\n    });\n\n    peerConnection.ontrack = () => {\n      // NOTE(mroberts): adapter.js's \"track\" event shim only kicks off if we set\n      // the ontrack property of the RTCPeerConnection.\n    };\n\n    if (typeof peerConnection.addTrack !== 'function') {\n      peerConnection.addStream(this._localStream);\n    }\n    proxyProperties(RTCPeerConnection.prototype, this, peerConnection);\n  }\n\n  get localDescription() {\n    return this._pendingLocalOffer ? this._pendingLocalOffer : this._peerConnection.localDescription;\n  }\n\n  get remoteDescription() {\n    return this._pendingRemoteOffer ? this._pendingRemoteOffer : this._peerConnection.remoteDescription;\n  }\n\n  get signalingState() {\n    if (this._pendingLocalOffer) {\n      return 'have-local-offer';\n    } else if (this._pendingRemoteOffer) {\n      return 'have-remote-offer';\n    }\n    return this._peerConnection.signalingState;\n  }\n\n  // NOTE(mmalavalli): This shim supports our limited case of adding\n  // all MediaStreamTracks to one MediaStream. It has been implemented this\n  // keeping in mind that this is to be maintained only until \"addTrack\" is\n  // supported natively in Chrome.\n  addTrack(track, ...rest) {\n    if (typeof this._peerConnection.addTrack === 'function') {\n      return this._peerConnection.addTrack(track, ...rest);\n    }\n    if (this._peerConnection.signalingState === 'closed') {\n      throw new Error(`Cannot add MediaStreamTrack [${track.id}, \n        ${track.kind}]: RTCPeerConnection is closed`);\n    }\n\n    let sender = this._senders.get(track);\n    if (sender && sender.track) {\n      throw new Error(`Cannot add MediaStreamTrack ['${track.id}, \n        ${track.kind}]: RTCPeerConnection already has it`);\n    }\n    this._peerConnection.removeStream(this._localStream);\n    this._localStream.addTrack(track);\n    this._peerConnection.addStream(this._localStream);\n    sender = new RTCRtpSenderShim(track);\n    this._senders.set(track, sender);\n    return sender;\n  }\n\n  // NOTE(mmalavalli): This shim supports our limited case of removing\n  // MediaStreamTracks from one MediaStream. It has been implemented this\n  // keeping in mind that this is to be maintained only until \"removeTrack\" is\n  // supported natively in Chrome.\n  removeTrack(sender) {\n    if (this._peerConnection.signalingState === 'closed') {\n      throw new Error('Cannot remove MediaStreamTrack: RTCPeerConnection is closed');\n    }\n    if (typeof this._peerConnection.addTrack === 'function') {\n      try {\n        return this._peerConnection.removeTrack(sender);\n      } catch (e) {\n        // NOTE(mhuynh): Do nothing. In Chrome, will throw if a 'sender was not\n        // created by this peer connection'. This behavior does not seem to be\n        // spec compliant, so a temporary shim is introduced. A bug has been filed,\n        // and is tracked here:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=860853\n      }\n    } else {\n      const { track } = sender;\n      if (!track) {\n        return;\n      }\n      sender = this._senders.get(track);\n      if (sender && sender.track) {\n        sender.track = null;\n        this._peerConnection.removeStream(this._localStream);\n        this._localStream.removeTrack(track);\n        this._peerConnection.addStream(this._localStream);\n      }\n    }\n  }\n\n  getSenders() {\n    if (typeof this._peerConnection.addTrack === 'function') {\n      return this._peerConnection.getSenders();\n    }\n    return Array.from(this._senders.values());\n  }\n\n  addIceCandidate(candidate, ...rest) {\n    let promise;\n\n    if (this.signalingState === 'have-remote-offer') {\n      // NOTE(mroberts): Because the ChromeRTCPeerConnection simulates the\n      // \"have-remote-offer\" signalingStates, we only want to invoke the true\n      // addIceCandidates method when the remote description has been applied.\n      promise = this._signalingStateLatch.when('low').then(() =>\n        this._peerConnection.addIceCandidate(candidate));\n    } else {\n      promise = this._peerConnection.addIceCandidate(candidate);\n    }\n\n    return rest.length > 0\n      ? legacyPromise(promise, ...rest)\n      : promise;\n  }\n\n  // NOTE(mroberts): The WebRTC spec does not specify that close should throw an\n  // Error; however, in Chrome it does. We workaround this by checking the\n  // signalingState manually.\n  close() {\n    if (this.signalingState !== 'closed') {\n      this._pendingLocalOffer = null;\n      this._pendingRemoteOffer = null;\n      this._peerConnection.close();\n    }\n  }\n\n  // NOTE(mroberts): Because we workaround Chrome's lack of rollback support by\n  // \"faking\" setRemoteDescription, we cannot create an answer until we actually\n  // apply the remote description. This means, once you call createAnswer, you\n  // can no longer rollback. This is acceptable for our use case because we will\n  // apply the newly-created answer almost immediately; however, this may be\n  // unacceptable for other use cases.\n  createAnswer(...args) {\n    let promise;\n\n    if (this._pendingRemoteOffer) {\n      promise = this._peerConnection.setRemoteDescription(this._pendingRemoteOffer).then(() => {\n        // NOTE(mroberts): The signalingStates between the ChromeRTCPeerConnection\n        // and the underlying RTCPeerConnection implementation have converged. We\n        // can unblock any pending calls to addIceCandidate now.\n        this._signalingStateLatch.lower();\n        return this._peerConnection.createAnswer();\n      }).then(answer => {\n        this._pendingRemoteOffer = null;\n\n        // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n        // longer need to retain the rolled back tracks to SSRCs Map.\n        this._rolledBackTracksToSSRCs.clear();\n\n        return new ChromeRTCSessionDescription({\n          type: 'answer',\n          sdp: updateTrackIdsToSSRCs(this._sdpFormat, this._tracksToSSRCs, answer.sdp)\n        });\n      }, error => {\n        this._pendingRemoteOffer = null;\n        throw error;\n      });\n    } else {\n      promise = this._peerConnection.createAnswer().then(answer => {\n        // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n        // longer need to retain the rolled back tracks to SSRCs Map.\n        this._rolledBackTracksToSSRCs.clear();\n\n        return new ChromeRTCSessionDescription({\n          type: 'answer',\n          sdp: updateTrackIdsToSSRCs(this._sdpFormat, this._tracksToSSRCs, answer.sdp)\n        });\n      });\n    }\n\n    return args.length > 1\n      ? legacyPromise(promise, ...args)\n      : promise;\n  }\n\n  createOffer(...args) {\n    const [arg1, arg2, arg3] = args;\n    const options = arg3 || arg1 || {};\n\n    if (isIOSChrome()) {\n      // NOTE (joma): From SafariRTCPeerConnection in order to support iOS Chrome.\n      if (options.offerToReceiveVideo && !this._audioTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'audio'))) {\n        delete options.offerToReceiveAudio;\n        try {\n          this._audioTransceiver = isUnifiedPlan\n            ? this.addTransceiver('audio', { direction: 'recvonly' })\n            : this.addTransceiver('audio');\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n\n      if (options.offerToReceiveVideo && !this._videoTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'video'))) {\n        delete options.offerToReceiveVideo;\n        try {\n          this._videoTransceiver = isUnifiedPlan\n            ? this.addTransceiver('video', { direction: 'recvonly' })\n            : this.addTransceiver('video');\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }\n\n    const promise = this._peerConnection.createOffer(options).then(offer => {\n      // NOTE(mmalavalli): If createOffer() is called immediately after rolling back, then we no\n      // longer need to retain the rolled back tracks to SSRCs Map.\n      this._rolledBackTracksToSSRCs.clear();\n\n      return new ChromeRTCSessionDescription({\n        type: offer.type,\n        sdp: updateTrackIdsToSSRCs(this._sdpFormat, this._tracksToSSRCs, offer.sdp)\n      });\n    });\n\n    return args.length > 1\n      ? legacyPromise(promise, arg1, arg2)\n      : promise;\n  }\n\n  createDataChannel(label, dataChannelDict) {\n    dataChannelDict = shimDataChannelInit(dataChannelDict);\n    const dataChannel = this._peerConnection.createDataChannel(label, dataChannelDict);\n    shimDataChannel(dataChannel);\n    return dataChannel;\n  }\n\n  setLocalDescription(...args) {\n    const [description, arg1, arg2] = args;\n\n    // NOTE(mmalavalli): If setLocalDescription() is called immediately after rolling back,\n    // then we need to restore the rolled back tracks to SSRCs Map.\n    if (this._rolledBackTracksToSSRCs.size > 0) {\n      this._tracksToSSRCs = new Map(this._rolledBackTracksToSSRCs);\n      this._rolledBackTracksToSSRCs.clear();\n    }\n\n    const promise = setDescription(this, true, description);\n    return args.length > 1\n      ? legacyPromise(promise, arg1, arg2)\n      : promise;\n  }\n\n  setRemoteDescription(...args) {\n    const [description, arg1, arg2] = args;\n\n    // NOTE(mmalavalli): If setRemoteDescription() is called immediately after rolling back,\n    // then we no longer need to retain the rolled back tracks to SSRCs Map.\n    this._rolledBackTracksToSSRCs.clear();\n\n    const promise = setDescription(this, false, description);\n    return args.length > 1\n      ? legacyPromise(promise, arg1, arg2)\n      : promise;\n  }\n}\n\ndelegateMethods(\n  RTCPeerConnection.prototype,\n  ChromeRTCPeerConnection.prototype,\n  '_peerConnection');\n\n// NOTE(mroberts): We workaround Chrome's lack of rollback support, per the\n// workaround suggested here: https://bugs.chromium.org/p/webrtc/issues/detail?id=5738#c3\n// Namely, we \"fake\" setting the local or remote description and instead buffer\n// it. If we receive or create an answer, then we will actually apply the\n// description. Until we receive or create an answer, we will be able to\n// \"rollback\" by simply discarding the buffer description.\nfunction setDescription(peerConnection, local, description) {\n  function setPendingLocalOffer(offer) {\n    if (local) {\n      peerConnection._pendingLocalOffer = offer;\n    } else {\n      peerConnection._pendingRemoteOffer = offer;\n    }\n  }\n\n  function clearPendingLocalOffer() {\n    if (local) {\n      peerConnection._pendingLocalOffer = null;\n    } else {\n      peerConnection._pendingRemoteOffer = null;\n    }\n  }\n\n  const pendingLocalOffer = local ? peerConnection._pendingLocalOffer : peerConnection._pendingRemoteOffer;\n  const pendingRemoteOffer = local ? peerConnection._pendingRemoteOffer : peerConnection._pendingLocalOffer;\n  const intermediateState = local ? 'have-local-offer' : 'have-remote-offer';\n  const setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n  let promise;\n\n  if (!local && pendingRemoteOffer && description.type === 'answer') {\n    promise = setRemoteAnswer(peerConnection, description);\n  } else if (description.type === 'offer') {\n    if (peerConnection.signalingState !== intermediateState && peerConnection.signalingState !== 'stable') {\n      // NOTE(mroberts): Error message copied from Firefox.\n      return Promise.reject(new Error(`Cannot set ${local ? 'local' : 'remote'} offer in state ${peerConnection.signalingState}`));\n    }\n\n    // We need to save this local offer in case of a rollback. We also need to\n    // check to see if the signalingState between the ChromeRTCPeerConnection\n    // and the underlying RTCPeerConnection implementation are about to diverge.\n    // If so, we need to ensure subsequent calls to addIceCandidate will block.\n    if (!pendingLocalOffer && peerConnection._signalingStateLatch.state === 'low') {\n      peerConnection._signalingStateLatch.raise();\n    }\n    const previousSignalingState = peerConnection.signalingState;\n    setPendingLocalOffer(unwrap(description));\n    promise = Promise.resolve();\n\n    // Only dispatch a signalingstatechange event if we transitioned.\n    if (peerConnection.signalingState !== previousSignalingState) {\n      promise.then(() => peerConnection.dispatchEvent(new Event('signalingstatechange')));\n    }\n\n  } else if (description.type === 'rollback') {\n    if (peerConnection.signalingState !== intermediateState) {\n      // NOTE(mroberts): Error message copied from Firefox.\n      promise = Promise.reject(new Error(`Cannot rollback ${local ? 'local' : 'remote'} description in ${peerConnection.signalingState}`));\n    } else {\n      // Reset the pending offer.\n      clearPendingLocalOffer();\n\n      // NOTE(mmalavalli): We store the rolled back tracks to SSRCs Map here in case\n      // setLocalDescription() is called immediately after a rollback (without calling\n      // createOffer() or createAnswer()), in which case this roll back is not due to a\n      // glare scenario and this Map should be restored.\n      peerConnection._rolledBackTracksToSSRCs = new Map(peerConnection._tracksToSSRCs);\n      peerConnection._tracksToSSRCs = new Map(peerConnection._appliedTracksToSSRCs);\n\n      promise = Promise.resolve();\n      promise.then(() => peerConnection.dispatchEvent(new Event('signalingstatechange')));\n    }\n  }\n\n  return promise || peerConnection._peerConnection[setLocalDescription](unwrap(description));\n}\n\nfunction setRemoteAnswer(peerConnection, answer) {\n  // Apply the pending local offer.\n  const pendingLocalOffer = peerConnection._pendingLocalOffer;\n  return peerConnection._peerConnection.setLocalDescription(pendingLocalOffer).then(() => {\n    peerConnection._pendingLocalOffer = null;\n    return peerConnection.setRemoteDescription(answer);\n  }).then(() => {\n    // NOTE(mroberts): The signalingStates between the ChromeRTCPeerConnection\n    // and the underlying RTCPeerConnection implementation have converged. We\n    // can unblock any pending calls to addIceCandidate now.\n    peerConnection._signalingStateLatch.lower();\n  });\n}\n\n/**\n * Whether a ChromeRTCPeerConnection has any RTCRtpReceivers(s) for the given\n * MediaStreamTrack kind.\n * @param {ChromeRTCPeerConnection} peerConnection\n * @param {'audio' | 'video'} kind\n * @returns {boolean}\n */\nfunction hasReceiversForTracksOfKind(peerConnection, kind) {\n  return !!peerConnection.getTransceivers().find(({ receiver = {} }) => {\n    const { track = {} } = receiver;\n    return track.kind === kind;\n  });\n}\n\nfunction unwrap(description) {\n  if (description instanceof ChromeRTCSessionDescription) {\n    if (description._description) {\n      return description._description;\n    }\n  }\n  return new RTCSessionDescription(description);\n}\n\n/**\n * Check whether or not we need to apply our maxPacketLifeTime shim. We are\n * pretty conservative: we'll only apply it if the legacy maxRetransmitTime\n * property is available _and_ the standard maxPacketLifeTime property is _not_\n * available (the thinking being that Chrome will land the standards-compliant\n * property).\n * @returns {boolean}\n */\nfunction needsMaxPacketLifeTimeShim() {\n  return 'maxRetransmitTime' in RTCDataChannel.prototype\n    && !('maxPacketLifeTime' in RTCDataChannel.prototype);\n}\n\n/**\n * Shim an RTCDataChannelInit dictionary (if necessary). This function returns\n * a copy of the original RTCDataChannelInit.\n * @param {RTCDataChannelInit} dataChannelDict\n * @returns {RTCDataChannelInit}\n */\nfunction shimDataChannelInit(dataChannelDict) {\n  dataChannelDict = Object.assign({}, dataChannelDict);\n  if (needsMaxPacketLifeTimeShim() && 'maxPacketLifeTime' in dataChannelDict) {\n    dataChannelDict.maxRetransmitTime = dataChannelDict.maxPacketLifeTime;\n  }\n  return dataChannelDict;\n}\n\n/**\n * Shim an RTCDataChannel (if necessary). This function mutates the\n * RTCDataChannel.\n * @param {RTCDataChannel} dataChannel\n * @returns {RTCDataChannel}\n */\nfunction shimDataChannel(dataChannel) {\n  Object.defineProperty(dataChannel, 'maxRetransmits', {\n    value: dataChannel.maxRetransmits === 65535\n      ? null\n      : dataChannel.maxRetransmits\n  });\n  if (needsMaxPacketLifeTimeShim()) {\n    // NOTE(mroberts): We can rename `maxRetransmitTime` to `maxPacketLifeTime`.\n    //\n    //   https://bugs.chromium.org/p/chromium/issues/detail?id=696681\n    //\n    Object.defineProperty(dataChannel, 'maxPacketLifeTime', {\n      value: dataChannel.maxRetransmitTime === 65535\n        ? null\n        : dataChannel.maxRetransmitTime\n    });\n  }\n  return dataChannel;\n}\n\n/**\n * Update the mappings from MediaStreamTrack IDs to SSRCs as indicated by both\n * the Map from MediaStreamTrack IDs to SSRCs and the SDP itself. This method\n * ensures that SSRCs never change once announced.\n * @param {'planb'|'unified'} sdpFormat\n * @param {Map<string, Set<string>>} tracksToSSRCs\n * @param {string} sdp - an SDP whose format is determined by `sdpSemantics`\n * @returns {string} updatedSdp - updated SDP\n */\nfunction updateTrackIdsToSSRCs(sdpFormat, tracksToSSRCs, sdp) {\n  return sdpFormat === 'unified'\n    ? updateUnifiedPlanTrackIdsToSSRCs(tracksToSSRCs, sdp)\n    : updatePlanBTrackIdsToSSRCs(tracksToSSRCs, sdp);\n}\n\nmodule.exports = ChromeRTCPeerConnection;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}