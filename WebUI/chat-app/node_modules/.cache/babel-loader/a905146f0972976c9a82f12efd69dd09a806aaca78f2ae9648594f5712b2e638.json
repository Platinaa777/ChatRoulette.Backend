{"ast":null,"code":"'use strict';\n\n/**\n * Return a Promise that resolves after `timeout` milliseconds.\n * @param {?number} [timeout=0]\n * @returns {Promise<void>}\n */\nfunction delay(timeout) {\n  timeout = typeof timeout === 'number' ? timeout : 0;\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, timeout);\n  });\n}\n/**\n * Attempt to detect silence. The Promise returned by this function returns\n * false as soon as audio is detected or true after `timeout` milliseconds.\n * @param {AudioContext} audioContext\n * @param {MediaStream} stream\n * @param {?number} [timeout=250]\n * @returns {Promise<boolean>}\n */\nfunction detectSilence(audioContext, stream, timeout) {\n  timeout = typeof timeout === 'number' ? timeout : 250;\n  var source = audioContext.createMediaStreamSource(stream);\n  var analyser = audioContext.createAnalyser();\n  analyser.fftSize = 2048;\n  source.connect(analyser);\n  var samples = new Uint8Array(analyser.fftSize);\n  var timeoutDidFire = false;\n  setTimeout(function () {\n    timeoutDidFire = true;\n  }, timeout);\n  /**\n   * We can't use async/await yet, so I need to factor this out.\n   * @returns {Promise<boolean>}\n   */\n  function doDetectSilence() {\n    if (timeoutDidFire) {\n      return Promise.resolve(true);\n    }\n    analyser.getByteTimeDomainData(samples);\n    // NOTE(mpatwardhan): An audio MediaStreamTrack can be silent either due to all samples\n    // being equal to 128 or all samples being equal to 0.\n    return samples.some(function (sample) {\n      return sample !== 128 && sample !== 0;\n    }) ? Promise.resolve(false) : delay().then(doDetectSilence);\n  }\n  return doDetectSilence().then(function (isSilent) {\n    source.disconnect();\n    return isSilent;\n  }, function (error) {\n    source.disconnect();\n    throw error;\n  });\n}\nmodule.exports = detectSilence;","map":{"version":3,"names":["delay","timeout","Promise","resolve","setTimeout","detectSilence","audioContext","stream","source","createMediaStreamSource","analyser","createAnalyser","fftSize","connect","samples","Uint8Array","timeoutDidFire","doDetectSilence","getByteTimeDomainData","some","sample","then","isSilent","disconnect","error","module","exports"],"sources":["/home/denis/RiderProjects/ChatRoulette/WebUI/chat-app/node_modules/twilio-video/lib/webaudio/detectsilence.js"],"sourcesContent":["'use strict';\n\n/**\n * Return a Promise that resolves after `timeout` milliseconds.\n * @param {?number} [timeout=0]\n * @returns {Promise<void>}\n */\nfunction delay(timeout) {\n  timeout = typeof timeout === 'number' ? timeout : 0;\n  return new Promise(resolve => setTimeout(resolve, timeout));\n}\n\n/**\n * Attempt to detect silence. The Promise returned by this function returns\n * false as soon as audio is detected or true after `timeout` milliseconds.\n * @param {AudioContext} audioContext\n * @param {MediaStream} stream\n * @param {?number} [timeout=250]\n * @returns {Promise<boolean>}\n */\nfunction detectSilence(audioContext, stream, timeout) {\n  timeout = typeof timeout === 'number' ? timeout : 250;\n\n  const source = audioContext.createMediaStreamSource(stream);\n  const analyser = audioContext.createAnalyser();\n  analyser.fftSize = 2048;\n  source.connect(analyser);\n\n  const samples = new Uint8Array(analyser.fftSize);\n\n  let timeoutDidFire = false;\n  setTimeout(() => { timeoutDidFire = true; }, timeout);\n\n  /**\n   * We can't use async/await yet, so I need to factor this out.\n   * @returns {Promise<boolean>}\n   */\n  function doDetectSilence() {\n    if (timeoutDidFire) {\n      return Promise.resolve(true);\n    }\n    analyser.getByteTimeDomainData(samples);\n    // NOTE(mpatwardhan): An audio MediaStreamTrack can be silent either due to all samples\n    // being equal to 128 or all samples being equal to 0.\n    return samples.some(sample => sample !== 128 && sample !== 0)\n      ? Promise.resolve(false)\n      : delay().then(doDetectSilence);\n  }\n\n  return doDetectSilence().then(isSilent => {\n    source.disconnect();\n    return isSilent;\n  }, error => {\n    source.disconnect();\n    throw error;\n  });\n}\n\nmodule.exports = detectSilence;\n"],"mappings":"AAAA,YAAY;;AAEZ;;;;;AAKA,SAASA,KAAKA,CAACC,OAAO;EACpBA,OAAO,GAAG,OAAOA,OAAO,KAAK,QAAQ,GAAGA,OAAO,GAAG,CAAC;EACnD,OAAO,IAAIC,OAAO,CAAC,UAAAC,OAAO;IAAI,OAAAC,UAAU,CAACD,OAAO,EAAEF,OAAO,CAAC;EAA5B,CAA4B,CAAC;AAC7D;AAEA;;;;;;;;AAQA,SAASI,aAAaA,CAACC,YAAY,EAAEC,MAAM,EAAEN,OAAO;EAClDA,OAAO,GAAG,OAAOA,OAAO,KAAK,QAAQ,GAAGA,OAAO,GAAG,GAAG;EAErD,IAAMO,MAAM,GAAGF,YAAY,CAACG,uBAAuB,CAACF,MAAM,CAAC;EAC3D,IAAMG,QAAQ,GAAGJ,YAAY,CAACK,cAAc,EAAE;EAC9CD,QAAQ,CAACE,OAAO,GAAG,IAAI;EACvBJ,MAAM,CAACK,OAAO,CAACH,QAAQ,CAAC;EAExB,IAAMI,OAAO,GAAG,IAAIC,UAAU,CAACL,QAAQ,CAACE,OAAO,CAAC;EAEhD,IAAII,cAAc,GAAG,KAAK;EAC1BZ,UAAU,CAAC;IAAQY,cAAc,GAAG,IAAI;EAAE,CAAC,EAAEf,OAAO,CAAC;EAErD;;;;EAIA,SAASgB,eAAeA,CAAA;IACtB,IAAID,cAAc,EAAE;MAClB,OAAOd,OAAO,CAACC,OAAO,CAAC,IAAI,CAAC;;IAE9BO,QAAQ,CAACQ,qBAAqB,CAACJ,OAAO,CAAC;IACvC;IACA;IACA,OAAOA,OAAO,CAACK,IAAI,CAAC,UAAAC,MAAM;MAAI,OAAAA,MAAM,KAAK,GAAG,IAAIA,MAAM,KAAK,CAAC;IAA9B,CAA8B,CAAC,GACzDlB,OAAO,CAACC,OAAO,CAAC,KAAK,CAAC,GACtBH,KAAK,EAAE,CAACqB,IAAI,CAACJ,eAAe,CAAC;EACnC;EAEA,OAAOA,eAAe,EAAE,CAACI,IAAI,CAAC,UAAAC,QAAQ;IACpCd,MAAM,CAACe,UAAU,EAAE;IACnB,OAAOD,QAAQ;EACjB,CAAC,EAAE,UAAAE,KAAK;IACNhB,MAAM,CAACe,UAAU,EAAE;IACnB,MAAMC,KAAK;EACb,CAAC,CAAC;AACJ;AAEAC,MAAM,CAACC,OAAO,GAAGrB,aAAa"},"metadata":{},"sourceType":"script","externalDependencies":[]}