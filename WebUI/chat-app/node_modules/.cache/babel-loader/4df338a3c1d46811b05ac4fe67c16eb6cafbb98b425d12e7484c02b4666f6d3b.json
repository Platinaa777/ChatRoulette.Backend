{"ast":null,"code":"'use strict';\n\nvar CancelablePromise = require('../../util/cancelablepromise');\nvar DefaultPeerConnectionManager = require('./peerconnectionmanager');\nvar DefaultRoomV2 = require('./room');\nvar DefaultTransport = require('./twilioconnectiontransport');\nvar _a = require('../../util/twilio-video-errors'),\n  SignalingConnectionDisconnectedError = _a.SignalingConnectionDisconnectedError,\n  SignalingIncomingMessageInvalidError = _a.SignalingIncomingMessageInvalidError;\nvar _b = require('../../util'),\n  flatMap = _b.flatMap,\n  createRoomConnectEventPayload = _b.createRoomConnectEventPayload;\nfunction createCancelableRoomSignalingPromise(token, wsServer, localParticipant, encodingParameters, preferredCodecs, options) {\n  options = Object.assign({\n    PeerConnectionManager: DefaultPeerConnectionManager,\n    RoomV2: DefaultRoomV2,\n    Transport: DefaultTransport\n  }, options);\n  var adaptiveSimulcast = preferredCodecs.video[0] && preferredCodecs.video[0].adaptiveSimulcast === true;\n  var PeerConnectionManager = options.PeerConnectionManager,\n    RoomV2 = options.RoomV2,\n    Transport = options.Transport,\n    iceServers = options.iceServers,\n    log = options.log;\n  var peerConnectionManager = new PeerConnectionManager(encodingParameters, preferredCodecs, options);\n  var trackSenders = flatMap(localParticipant.tracks, function (trackV2) {\n    return [trackV2.trackTransceiver];\n  });\n  peerConnectionManager.setTrackSenders(trackSenders);\n  var cancellationError = new Error('Canceled');\n  var transport;\n  var cancelablePromise = new CancelablePromise(function (resolve, reject, isCanceled) {\n    var onIced = function (iceServers) {\n      if (isCanceled()) {\n        reject(cancellationError);\n        return Promise.reject(cancellationError);\n      }\n      log.debug('Got ICE servers:', iceServers);\n      options.iceServers = iceServers;\n      peerConnectionManager.setConfiguration(options);\n      return peerConnectionManager.createAndOffer().then(function () {\n        if (isCanceled()) {\n          reject(cancellationError);\n          throw cancellationError;\n        }\n        log.debug('createAndOffer() succeeded.');\n        // NOTE(mmalavalli): PeerConnectionManager#createAndOffer() queues the\n        // initial offer in the event queue for the 'description' event. So,\n        // we are dequeueing to prevent the spurious 'update' message sent by\n        // the client after connecting to a room.\n        peerConnectionManager.dequeue('description');\n      }).catch(function (error) {\n        log.error('createAndOffer() failed:', error);\n        reject(error);\n        throw error;\n      });\n    };\n    var automaticSubscription = options.automaticSubscription,\n      bandwidthProfile = options.bandwidthProfile,\n      dominantSpeaker = options.dominantSpeaker,\n      environment = options.environment,\n      eventObserver = options.eventObserver,\n      loggerName = options.loggerName,\n      logLevel = options.logLevel,\n      name = options.name,\n      networkMonitor = options.networkMonitor,\n      networkQuality = options.networkQuality,\n      notifyWarnings = options.notifyWarnings,\n      realm = options.realm,\n      sdpSemantics = options.sdpSemantics;\n    // decide which msp channels to request\n    // dominantSpeaker, networkQuality\n    var trackPriority = !!bandwidthProfile;\n    var trackSwitchOff = !!bandwidthProfile;\n    var renderHints = !!bandwidthProfile && (options.clientTrackSwitchOffControl !== 'disabled' || options.contentPreferencesMode !== 'disabled');\n    var transportOptions = Object.assign({\n      adaptiveSimulcast: adaptiveSimulcast,\n      automaticSubscription: automaticSubscription,\n      dominantSpeaker: dominantSpeaker,\n      environment: environment,\n      eventObserver: eventObserver,\n      loggerName: loggerName,\n      logLevel: logLevel,\n      networkMonitor: networkMonitor,\n      networkQuality: networkQuality,\n      notifyWarnings: notifyWarnings,\n      iceServers: iceServers,\n      onIced: onIced,\n      realm: realm,\n      renderHints: renderHints,\n      sdpSemantics: sdpSemantics,\n      trackPriority: trackPriority,\n      trackSwitchOff: trackSwitchOff\n    }, bandwidthProfile ? {\n      bandwidthProfile: bandwidthProfile\n    } : {});\n    transport = new Transport(name, token, localParticipant, peerConnectionManager, wsServer, transportOptions);\n    var connectEventPayload = createRoomConnectEventPayload(options);\n    eventObserver.emit('event', connectEventPayload);\n    transport.once('connected', function (initialState) {\n      log.debug('Transport connected:', initialState);\n      if (isCanceled()) {\n        reject(cancellationError);\n        return;\n      }\n      var localParticipantState = initialState.participant;\n      if (!localParticipantState) {\n        reject(new SignalingIncomingMessageInvalidError());\n        return;\n      }\n      resolve(new RoomV2(localParticipant, initialState, transport, peerConnectionManager, options));\n    });\n    transport.once('stateChanged', function (state, error) {\n      if (state === 'disconnected') {\n        transport = null;\n        reject(error || new SignalingConnectionDisconnectedError());\n      } else {\n        log.debug('Transport state changed:', state);\n      }\n    });\n  }, function () {\n    if (transport) {\n      transport.disconnect();\n      transport = null;\n    }\n  });\n  cancelablePromise.catch(function () {\n    if (transport) {\n      transport.disconnect();\n      transport = null;\n    }\n    peerConnectionManager.close();\n  });\n  return cancelablePromise;\n}\nmodule.exports = createCancelableRoomSignalingPromise;","map":{"version":3,"names":["CancelablePromise","require","DefaultPeerConnectionManager","DefaultRoomV2","DefaultTransport","_a","SignalingConnectionDisconnectedError","SignalingIncomingMessageInvalidError","_b","flatMap","createRoomConnectEventPayload","createCancelableRoomSignalingPromise","token","wsServer","localParticipant","encodingParameters","preferredCodecs","options","Object","assign","PeerConnectionManager","RoomV2","Transport","adaptiveSimulcast","video","iceServers","log","peerConnectionManager","trackSenders","tracks","trackV2","trackTransceiver","setTrackSenders","cancellationError","Error","transport","cancelablePromise","resolve","reject","isCanceled","onIced","Promise","debug","setConfiguration","createAndOffer","then","dequeue","catch","error","automaticSubscription","bandwidthProfile","dominantSpeaker","environment","eventObserver","loggerName","logLevel","name","networkMonitor","networkQuality","notifyWarnings","realm","sdpSemantics","trackPriority","trackSwitchOff","renderHints","clientTrackSwitchOffControl","contentPreferencesMode","transportOptions","connectEventPayload","emit","once","initialState","localParticipantState","participant","state","disconnect","close","module","exports"],"sources":["/home/denis/RiderProjects/ChatRoulette/WebUI/chat-app/node_modules/twilio-video/lib/signaling/v2/cancelableroomsignalingpromise.js"],"sourcesContent":["'use strict';\n\nconst CancelablePromise = require('../../util/cancelablepromise');\nconst DefaultPeerConnectionManager = require('./peerconnectionmanager');\nconst DefaultRoomV2 = require('./room');\nconst DefaultTransport = require('./twilioconnectiontransport');\n\nconst {\n  SignalingConnectionDisconnectedError,\n  SignalingIncomingMessageInvalidError\n} = require('../../util/twilio-video-errors');\n\nconst { flatMap, createRoomConnectEventPayload } = require('../../util');\n\nfunction createCancelableRoomSignalingPromise(token, wsServer, localParticipant, encodingParameters, preferredCodecs, options) {\n  options = Object.assign({\n    PeerConnectionManager: DefaultPeerConnectionManager,\n    RoomV2: DefaultRoomV2,\n    Transport: DefaultTransport\n  }, options);\n\n  const adaptiveSimulcast = preferredCodecs.video[0] &&  preferredCodecs.video[0].adaptiveSimulcast === true;\n  const { PeerConnectionManager, RoomV2, Transport, iceServers, log } = options;\n  const peerConnectionManager = new PeerConnectionManager(encodingParameters, preferredCodecs, options);\n  const trackSenders = flatMap(localParticipant.tracks, trackV2 => [trackV2.trackTransceiver]);\n  peerConnectionManager.setTrackSenders(trackSenders);\n\n  const cancellationError = new Error('Canceled');\n\n  let transport;\n\n  const cancelablePromise = new CancelablePromise((resolve, reject, isCanceled) => {\n    const onIced = iceServers => {\n      if (isCanceled()) {\n        reject(cancellationError);\n        return Promise.reject(cancellationError);\n      }\n      log.debug('Got ICE servers:', iceServers);\n      options.iceServers = iceServers;\n      peerConnectionManager.setConfiguration(options);\n\n      return peerConnectionManager.createAndOffer().then(() => {\n        if (isCanceled()) {\n          reject(cancellationError);\n          throw cancellationError;\n        }\n        log.debug('createAndOffer() succeeded.');\n        // NOTE(mmalavalli): PeerConnectionManager#createAndOffer() queues the\n        // initial offer in the event queue for the 'description' event. So,\n        // we are dequeueing to prevent the spurious 'update' message sent by\n        // the client after connecting to a room.\n        peerConnectionManager.dequeue('description');\n      }).catch(error => {\n        log.error('createAndOffer() failed:', error);\n        reject(error);\n        throw error;\n      });\n    };\n\n    const {\n      automaticSubscription,\n      bandwidthProfile,\n      dominantSpeaker,\n      environment,\n      eventObserver,\n      loggerName,\n      logLevel,\n      name,\n      networkMonitor,\n      networkQuality,\n      notifyWarnings,\n      realm,\n      sdpSemantics,\n    } = options;\n\n    // decide which msp channels to request\n    // dominantSpeaker, networkQuality\n    const trackPriority = !!bandwidthProfile;\n    const trackSwitchOff = !!bandwidthProfile;\n    const renderHints = !!bandwidthProfile &&\n      (options.clientTrackSwitchOffControl !== 'disabled' || options.contentPreferencesMode !== 'disabled');\n\n    const transportOptions = Object.assign({\n      adaptiveSimulcast,\n      automaticSubscription,\n      dominantSpeaker,\n      environment,\n      eventObserver,\n      loggerName,\n      logLevel,\n      networkMonitor,\n      networkQuality,\n      notifyWarnings,\n      iceServers,\n      onIced,\n      realm,\n      renderHints,\n      sdpSemantics,\n      trackPriority,\n      trackSwitchOff\n    }, bandwidthProfile ? {\n      bandwidthProfile\n    } : {});\n\n    transport = new Transport(\n      name,\n      token,\n      localParticipant,\n      peerConnectionManager,\n      wsServer,\n      transportOptions);\n\n    const connectEventPayload = createRoomConnectEventPayload(options);\n    eventObserver.emit('event', connectEventPayload);\n\n    transport.once('connected', initialState => {\n      log.debug('Transport connected:', initialState);\n      if (isCanceled()) {\n        reject(cancellationError);\n        return;\n      }\n      const { participant: localParticipantState } = initialState;\n      if (!localParticipantState) {\n        reject(new SignalingIncomingMessageInvalidError());\n        return;\n      }\n      resolve(new RoomV2(localParticipant, initialState, transport, peerConnectionManager, options));\n    });\n\n    transport.once('stateChanged', (state, error) => {\n      if (state === 'disconnected') {\n        transport = null;\n        reject(error || new SignalingConnectionDisconnectedError());\n      } else {\n        log.debug('Transport state changed:', state);\n      }\n    });\n  }, () => {\n    if (transport) {\n      transport.disconnect();\n      transport = null;\n    }\n  });\n\n  cancelablePromise.catch(() => {\n    if (transport) {\n      transport.disconnect();\n      transport = null;\n    }\n    peerConnectionManager.close();\n  });\n\n  return cancelablePromise;\n}\n\nmodule.exports = createCancelableRoomSignalingPromise;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}