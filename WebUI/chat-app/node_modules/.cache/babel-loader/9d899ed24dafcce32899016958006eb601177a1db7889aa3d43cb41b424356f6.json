{"ast":null,"code":"'use strict';\n\nvar _a = require('../../util/constants'),\n  ICE_ACTIVITY_CHECK_PERIOD_MS = _a.ICE_ACTIVITY_CHECK_PERIOD_MS,\n  ICE_INACTIVITY_THRESHOLD_MS = _a.ICE_INACTIVITY_THRESHOLD_MS;\n/**\n * Monitors a {@link RTCPeerConnection}'s stats and notifies\n * caller when inactivity is detected.\n */\nvar IceConnectionMonitor = /** @class */function () {\n  /**\n   * Construct an {@link IceConnectionMonitor}.\n   * @param {RTCPeerConnection} peerConnection\n   * @param {object} [options]\n   */\n  function IceConnectionMonitor(peerConnection, options) {\n    options = Object.assign({\n      activityCheckPeriodMs: ICE_ACTIVITY_CHECK_PERIOD_MS,\n      inactivityThresholdMs: ICE_INACTIVITY_THRESHOLD_MS\n    }, options);\n    Object.defineProperties(this, {\n      _activityCheckPeriodMs: {\n        value: options.activityCheckPeriodMs\n      },\n      _inactivityThresholdMs: {\n        value: options.inactivityThresholdMs\n      },\n      _lastActivity: {\n        value: null,\n        writable: true\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _timer: {\n        value: null,\n        writable: true\n      },\n      _onIceConnectionStateChanged: {\n        value: null,\n        writable: true\n      }\n    });\n  }\n  IceConnectionMonitor.prototype._getActivePairStat = function (stats) {\n    var statsArray = Array.from(stats.values());\n    var activePairStats = statsArray.find(function (stat) {\n      return stat.type === 'candidate-pair' && stat.nominated;\n    });\n    // NOTE(mpatwardhan): sometimes (JSDK-2667) after getting disconnected while switching network\n    // we may not find active pair. Treat this as 0 bytesReceived so that we count it towards inactivity.\n    return activePairStats || {\n      bytesReceived: 0,\n      timestamp: Math.round(new Date().getTime())\n    };\n  };\n  /**\n   * Get ICE connection stats, and extract received and send bytes.\n   * @returns Promise<?RTCIceCandidatePairStats>\n   */\n  IceConnectionMonitor.prototype._getIceConnectionStats = function () {\n    var _this = this;\n    return this._peerConnection.getStats().then(function (stats) {\n      return _this._getActivePairStat(stats);\n    }).catch(function () {\n      return null;\n    });\n  };\n  /**\n   * schedules/un-schedules inactivity callback.\n   */\n  IceConnectionMonitor.prototype._scheduleInactivityCallback = function (callback) {\n    var _this = this;\n    if (callback && this._onIceConnectionStateChanged === null) {\n      // schedule callback\n      this._onIceConnectionStateChanged = function () {\n        if (_this._peerConnection.iceConnectionState === 'disconnected') {\n          // eslint-disable-next-line callback-return\n          callback();\n        }\n      };\n      this._peerConnection.addEventListener('iceconnectionstatechange', this._onIceConnectionStateChanged);\n    } else if (!callback && this._onIceConnectionStateChanged) {\n      // unschedule callback\n      this._peerConnection.removeEventListener('iceconnectionstatechange', this._onIceConnectionStateChanged);\n      this._onIceConnectionStateChanged = null;\n    }\n  };\n  /**\n   * Start monitoring the ICE connection.\n   * Monitors bytes received on active ice connection pair,\n   * invokes onIceConnectionInactive when inactivity is detected.\n   * @param {function} onIceConnectionInactive\n   */\n  IceConnectionMonitor.prototype.start = function (onIceConnectionInactive) {\n    var _this = this;\n    this.stop();\n    this._timer = setInterval(function () {\n      _this._getIceConnectionStats().then(function (iceStats) {\n        if (!iceStats) {\n          return;\n        }\n        // NOTE(mpatwardhan): We look at bytesReceived on active candidate pair as an indication of active ice connection.\n        // As per spec (https://w3c.github.io/webrtc-stats/#dom-rtcicecandidatepairstats-bytesreceived) this value\n        // includes RTCP traffic and is +ve even when there are no tracks subscribed to.\n        if (!_this._lastActivity || _this._lastActivity.bytesReceived !== iceStats.bytesReceived) {\n          _this._lastActivity = iceStats;\n          // detected activity, cancel scheduled callback if any.\n          _this._scheduleInactivityCallback(null);\n        }\n        if (iceStats.timestamp - _this._lastActivity.timestamp >= _this._inactivityThresholdMs) {\n          // detected inactivity.\n          if (_this._peerConnection.iceConnectionState === 'disconnected') {\n            onIceConnectionInactive();\n          } else if (_this._onIceConnectionStateChanged === null) {\n            _this._scheduleInactivityCallback(onIceConnectionInactive);\n          }\n        }\n      });\n    }, this._activityCheckPeriodMs);\n  };\n  /**\n   * Stop monitoring the ICE connection state.\n   * @returns {void}\n   */\n  IceConnectionMonitor.prototype.stop = function () {\n    this._scheduleInactivityCallback(null);\n    if (this._timer !== null) {\n      clearInterval(this._timer);\n      this._timer = null;\n      this._lastActivity = null;\n    }\n  };\n  return IceConnectionMonitor;\n}();\nmodule.exports = IceConnectionMonitor;","map":{"version":3,"names":["_a","require","ICE_ACTIVITY_CHECK_PERIOD_MS","ICE_INACTIVITY_THRESHOLD_MS","IceConnectionMonitor","peerConnection","options","Object","assign","activityCheckPeriodMs","inactivityThresholdMs","defineProperties","_activityCheckPeriodMs","value","_inactivityThresholdMs","_lastActivity","writable","_peerConnection","_timer","_onIceConnectionStateChanged","prototype","_getActivePairStat","stats","statsArray","Array","from","values","activePairStats","find","stat","type","nominated","bytesReceived","timestamp","Math","round","Date","getTime","_getIceConnectionStats","_this","getStats","then","catch","_scheduleInactivityCallback","callback","iceConnectionState","addEventListener","removeEventListener","start","onIceConnectionInactive","stop","setInterval","iceStats","clearInterval","module","exports"],"sources":["/home/denis/RiderProjects/ChatRoulette/WebUI/chat-app/node_modules/twilio-video/lib/signaling/v2/iceconnectionmonitor.js"],"sourcesContent":["'use strict';\n\nconst { ICE_ACTIVITY_CHECK_PERIOD_MS, ICE_INACTIVITY_THRESHOLD_MS } = require('../../util/constants');\n\n/**\n * Monitors a {@link RTCPeerConnection}'s stats and notifies\n * caller when inactivity is detected.\n */\nclass IceConnectionMonitor {\n  /**\n   * Construct an {@link IceConnectionMonitor}.\n   * @param {RTCPeerConnection} peerConnection\n   * @param {object} [options]\n   */\n  constructor(peerConnection, options) {\n    options = Object.assign({\n      activityCheckPeriodMs: ICE_ACTIVITY_CHECK_PERIOD_MS,\n      inactivityThresholdMs: ICE_INACTIVITY_THRESHOLD_MS,\n    }, options);\n\n    Object.defineProperties(this, {\n      _activityCheckPeriodMs: {\n        value: options.activityCheckPeriodMs\n      },\n      _inactivityThresholdMs: {\n        value: options.inactivityThresholdMs\n      },\n      _lastActivity: {\n        value: null,\n        writable: true\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _timer: {\n        value: null,\n        writable: true,\n      },\n      _onIceConnectionStateChanged: {\n        value: null,\n        writable: true\n      }\n    });\n  }\n\n  _getActivePairStat(stats) {\n    const statsArray = Array.from(stats.values());\n    const activePairStats = statsArray.find(stat => stat.type === 'candidate-pair' && stat.nominated);\n    // NOTE(mpatwardhan): sometimes (JSDK-2667) after getting disconnected while switching network\n    // we may not find active pair. Treat this as 0 bytesReceived so that we count it towards inactivity.\n    return activePairStats || {\n      bytesReceived: 0,\n      timestamp: Math.round((new Date()).getTime())\n    };\n  }\n\n  /**\n   * Get ICE connection stats, and extract received and send bytes.\n   * @returns Promise<?RTCIceCandidatePairStats>\n   */\n  _getIceConnectionStats() {\n    return this._peerConnection.getStats().then(stats => this._getActivePairStat(stats)).catch(() => {\n      return null;\n    });\n  }\n\n  /**\n   * schedules/un-schedules inactivity callback.\n   */\n  _scheduleInactivityCallback(callback) {\n    if (callback && this._onIceConnectionStateChanged === null) {\n      // schedule callback\n      this._onIceConnectionStateChanged = () => {\n        if (this._peerConnection.iceConnectionState === 'disconnected') {\n          // eslint-disable-next-line callback-return\n          callback();\n        }\n      };\n      this._peerConnection.addEventListener('iceconnectionstatechange', this._onIceConnectionStateChanged);\n    } else if (!callback && this._onIceConnectionStateChanged) {\n      // unschedule callback\n      this._peerConnection.removeEventListener('iceconnectionstatechange', this._onIceConnectionStateChanged);\n      this._onIceConnectionStateChanged = null;\n    }\n  }\n\n  /**\n   * Start monitoring the ICE connection.\n   * Monitors bytes received on active ice connection pair,\n   * invokes onIceConnectionInactive when inactivity is detected.\n   * @param {function} onIceConnectionInactive\n   */\n  start(onIceConnectionInactive) {\n    this.stop();\n\n    this._timer = setInterval(() => {\n      this._getIceConnectionStats().then(iceStats => {\n        if (!iceStats) {\n          return;\n        }\n\n        // NOTE(mpatwardhan): We look at bytesReceived on active candidate pair as an indication of active ice connection.\n        // As per spec (https://w3c.github.io/webrtc-stats/#dom-rtcicecandidatepairstats-bytesreceived) this value\n        // includes RTCP traffic and is +ve even when there are no tracks subscribed to.\n        if (!this._lastActivity || this._lastActivity.bytesReceived !== iceStats.bytesReceived) {\n          this._lastActivity = iceStats;\n          // detected activity, cancel scheduled callback if any.\n          this._scheduleInactivityCallback(null);\n        }\n\n        if (iceStats.timestamp - this._lastActivity.timestamp >= this._inactivityThresholdMs) {\n          // detected inactivity.\n          if (this._peerConnection.iceConnectionState === 'disconnected') {\n            onIceConnectionInactive();\n          } else if (this._onIceConnectionStateChanged === null) {\n            this._scheduleInactivityCallback(onIceConnectionInactive);\n          }\n        }\n      });\n    }, this._activityCheckPeriodMs);\n  }\n\n  /**\n   * Stop monitoring the ICE connection state.\n   * @returns {void}\n   */\n  stop() {\n    this._scheduleInactivityCallback(null);\n    if (this._timer !== null) {\n      clearInterval(this._timer);\n      this._timer = null;\n      this._lastActivity = null;\n    }\n  }\n}\n\nmodule.exports = IceConnectionMonitor;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}