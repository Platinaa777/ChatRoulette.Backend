{"ast":null,"code":"/* globals RTCPeerConnection, RTCSessionDescription */\n'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nvar EventTarget = require('../../eventtarget');\nvar Latch = require('../util/latch');\nvar _a = require('../util/sdp'),\n  getSdpFormat = _a.getSdpFormat,\n  updatePlanBTrackIdsToSSRCs = _a.updatePlanBTrackIdsToSSRCs,\n  updateUnifiedPlanTrackIdsToSSRCs = _a.updateUnifiedPlanTrackIdsToSSRCs;\nvar _b = require('../util'),\n  delegateMethods = _b.delegateMethods,\n  interceptEvent = _b.interceptEvent,\n  proxyProperties = _b.proxyProperties;\nvar isUnifiedPlan = getSdpFormat() === 'unified';\nvar updateTrackIdsToSSRCs = isUnifiedPlan ? updateUnifiedPlanTrackIdsToSSRCs : updatePlanBTrackIdsToSSRCs;\nvar SafariRTCPeerConnection = /** @class */function (_super) {\n  __extends(SafariRTCPeerConnection, _super);\n  function SafariRTCPeerConnection(configuration) {\n    var _this = _super.call(this) || this;\n    interceptEvent(_this, 'datachannel');\n    interceptEvent(_this, 'iceconnectionstatechange');\n    interceptEvent(_this, 'signalingstatechange');\n    interceptEvent(_this, 'track');\n    var peerConnection = new RTCPeerConnection(configuration);\n    Object.defineProperties(_this, {\n      _appliedTracksToSSRCs: {\n        value: new Map(),\n        writable: true\n      },\n      _audioTransceiver: {\n        value: null,\n        writable: true\n      },\n      _isClosed: {\n        value: false,\n        writable: true\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _pendingLocalOffer: {\n        value: null,\n        writable: true\n      },\n      _pendingRemoteOffer: {\n        value: null,\n        writable: true\n      },\n      _rolledBackTracksToSSRCs: {\n        value: new Map(),\n        writable: true\n      },\n      _signalingStateLatch: {\n        value: new Latch()\n      },\n      _tracksToSSRCs: {\n        value: new Map(),\n        writable: true\n      },\n      _videoTransceiver: {\n        value: null,\n        writable: true\n      }\n    });\n    peerConnection.addEventListener('datachannel', function (event) {\n      shimDataChannel(event.channel);\n      _this.dispatchEvent(event);\n    });\n    peerConnection.addEventListener('iceconnectionstatechange', function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      if (_this._isClosed) {\n        return;\n      }\n      _this.dispatchEvent.apply(_this, __spreadArray([], __read(args)));\n    });\n    peerConnection.addEventListener('signalingstatechange', function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      if (_this._isClosed) {\n        return;\n      }\n      if (peerConnection.signalingState === 'stable') {\n        _this._appliedTracksToSSRCs = new Map(_this._tracksToSSRCs);\n      }\n      if (!_this._pendingLocalOffer && !_this._pendingRemoteOffer) {\n        _this.dispatchEvent.apply(_this, __spreadArray([], __read(args)));\n      }\n    });\n    // NOTE(syerrapragada): This ensures that SafariRTCPeerConnection's \"remoteDescription\", when accessed\n    // in an RTCTrackEvent listener, will point to the underlying RTCPeerConnection's\n    // \"remoteDescription\". Before this fix, this was still pointing to \"_pendingRemoteOffer\"\n    // even though a new remote RTCSessionDescription had already been applied.\n    peerConnection.addEventListener('track', function (event) {\n      _this._pendingRemoteOffer = null;\n      _this.dispatchEvent(event);\n    });\n    proxyProperties(RTCPeerConnection.prototype, _this, peerConnection);\n    return _this;\n  }\n  Object.defineProperty(SafariRTCPeerConnection.prototype, \"localDescription\", {\n    get: function () {\n      return this._pendingLocalOffer || this._peerConnection.localDescription;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SafariRTCPeerConnection.prototype, \"iceConnectionState\", {\n    get: function () {\n      return this._isClosed ? 'closed' : this._peerConnection.iceConnectionState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SafariRTCPeerConnection.prototype, \"iceGatheringState\", {\n    get: function () {\n      return this._isClosed ? 'complete' : this._peerConnection.iceGatheringState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SafariRTCPeerConnection.prototype, \"remoteDescription\", {\n    get: function () {\n      return this._pendingRemoteOffer || this._peerConnection.remoteDescription;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SafariRTCPeerConnection.prototype, \"signalingState\", {\n    get: function () {\n      if (this._isClosed) {\n        return 'closed';\n      } else if (this._pendingLocalOffer) {\n        return 'have-local-offer';\n      } else if (this._pendingRemoteOffer) {\n        return 'have-remote-offer';\n      }\n      return this._peerConnection.signalingState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  SafariRTCPeerConnection.prototype.addIceCandidate = function (candidate) {\n    var _this = this;\n    if (this.signalingState === 'have-remote-offer') {\n      return this._signalingStateLatch.when('low').then(function () {\n        return _this._peerConnection.addIceCandidate(candidate);\n      });\n    }\n    return this._peerConnection.addIceCandidate(candidate);\n  };\n  SafariRTCPeerConnection.prototype.createOffer = function (options) {\n    var _this = this;\n    options = Object.assign({}, options);\n    // NOTE(mroberts): In general, this is not the way to do this; however, it's\n    // good enough for our application.\n    if (options.offerToReceiveVideo && !this._audioTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'audio'))) {\n      delete options.offerToReceiveAudio;\n      try {\n        this._audioTransceiver = isUnifiedPlan ? this.addTransceiver('audio', {\n          direction: 'recvonly'\n        }) : this.addTransceiver('audio');\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }\n    if (options.offerToReceiveVideo && !this._videoTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'video'))) {\n      delete options.offerToReceiveVideo;\n      try {\n        this._videoTransceiver = isUnifiedPlan ? this.addTransceiver('video', {\n          direction: 'recvonly'\n        }) : this.addTransceiver('video');\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }\n    return this._peerConnection.createOffer(options).then(function (offer) {\n      // NOTE(mmalavalli): If createOffer() is called immediately after rolling back,\n      // then we no longer need to retain the rolled back tracks to SSRCs Map.\n      _this._rolledBackTracksToSSRCs.clear();\n      return new RTCSessionDescription({\n        type: offer.type,\n        sdp: updateTrackIdsToSSRCs(_this._tracksToSSRCs, offer.sdp)\n      });\n    });\n  };\n  SafariRTCPeerConnection.prototype.createAnswer = function (options) {\n    var _this = this;\n    if (this._pendingRemoteOffer) {\n      return this._peerConnection.setRemoteDescription(this._pendingRemoteOffer).then(function () {\n        _this._signalingStateLatch.lower();\n        return _this._peerConnection.createAnswer();\n      }).then(function (answer) {\n        _this._pendingRemoteOffer = null;\n        // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n        // longer need to retain the rolled back tracks to SSRCs Map.\n        _this._rolledBackTracksToSSRCs.clear();\n        return isUnifiedPlan ? new RTCSessionDescription({\n          type: answer.type,\n          sdp: updateTrackIdsToSSRCs(_this._tracksToSSRCs, answer.sdp)\n        }) : answer;\n      }, function (error) {\n        _this._pendingRemoteOffer = null;\n        throw error;\n      });\n    }\n    return this._peerConnection.createAnswer(options).then(function (answer) {\n      // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n      // longer need to retain the rolled back tracks to SSRCs Map.\n      _this._rolledBackTracksToSSRCs.clear();\n      return isUnifiedPlan ? new RTCSessionDescription({\n        type: answer.type,\n        sdp: updateTrackIdsToSSRCs(_this._tracksToSSRCs, answer.sdp)\n      }) : answer;\n    });\n  };\n  SafariRTCPeerConnection.prototype.createDataChannel = function (label, dataChannelDict) {\n    var dataChannel = this._peerConnection.createDataChannel(label, dataChannelDict);\n    shimDataChannel(dataChannel);\n    return dataChannel;\n  };\n  SafariRTCPeerConnection.prototype.removeTrack = function (sender) {\n    sender.replaceTrack(null);\n    this._peerConnection.removeTrack(sender);\n  };\n  SafariRTCPeerConnection.prototype.setLocalDescription = function (description) {\n    // NOTE(mmalavalli): If setLocalDescription() is called immediately after rolling back,\n    // then we need to restore the rolled back tracks to SSRCs Map.\n    if (this._rolledBackTracksToSSRCs.size > 0) {\n      this._tracksToSSRCs = new Map(this._rolledBackTracksToSSRCs);\n      this._rolledBackTracksToSSRCs.clear();\n    }\n    return setDescription(this, true, description);\n  };\n  SafariRTCPeerConnection.prototype.setRemoteDescription = function (description) {\n    // NOTE(mmalavalli): If setRemoteDescription() is called immediately after rolling back,\n    // then we no longer need to retain the rolled back tracks to SSRCs Map.\n    this._rolledBackTracksToSSRCs.clear();\n    return setDescription(this, false, description);\n  };\n  SafariRTCPeerConnection.prototype.close = function () {\n    var _this = this;\n    if (this._isClosed) {\n      return;\n    }\n    this._isClosed = true;\n    this._peerConnection.close();\n    setTimeout(function () {\n      _this.dispatchEvent(new Event('iceconnectionstatechange'));\n      _this.dispatchEvent(new Event('signalingstatechange'));\n    });\n  };\n  return SafariRTCPeerConnection;\n}(EventTarget);\ndelegateMethods(RTCPeerConnection.prototype, SafariRTCPeerConnection.prototype, '_peerConnection');\nfunction setDescription(peerConnection, local, description) {\n  function setPendingLocalOffer(offer) {\n    if (local) {\n      peerConnection._pendingLocalOffer = offer;\n    } else {\n      peerConnection._pendingRemoteOffer = offer;\n    }\n  }\n  function clearPendingLocalOffer() {\n    if (local) {\n      peerConnection._pendingLocalOffer = null;\n    } else {\n      peerConnection._pendingRemoteOffer = null;\n    }\n  }\n  var pendingLocalOffer = local ? peerConnection._pendingLocalOffer : peerConnection._pendingRemoteOffer;\n  var pendingRemoteOffer = local ? peerConnection._pendingRemoteOffer : peerConnection._pendingLocalOffer;\n  var intermediateState = local ? 'have-local-offer' : 'have-remote-offer';\n  var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n  if (!local && pendingRemoteOffer && description.type === 'answer') {\n    return setRemoteAnswer(peerConnection, description);\n  } else if (description.type === 'offer') {\n    if (peerConnection.signalingState !== intermediateState && peerConnection.signalingState !== 'stable') {\n      return Promise.reject(new Error(\"Cannot set \" + (local ? 'local' : 'remote') + \"\\n        offer in state \" + peerConnection.signalingState));\n    }\n    if (!pendingLocalOffer && peerConnection._signalingStateLatch.state === 'low') {\n      peerConnection._signalingStateLatch.raise();\n    }\n    var previousSignalingState = peerConnection.signalingState;\n    setPendingLocalOffer(description);\n    // Only dispatch a signalingstatechange event if we transitioned.\n    if (peerConnection.signalingState !== previousSignalingState) {\n      return Promise.resolve().then(function () {\n        return peerConnection.dispatchEvent(new Event('signalingstatechange'));\n      });\n    }\n    return Promise.resolve();\n  } else if (description.type === 'rollback') {\n    if (peerConnection.signalingState !== intermediateState) {\n      return Promise.reject(new Error(\"Cannot rollback \\n        \" + (local ? 'local' : 'remote') + \" description in \" + peerConnection.signalingState));\n    }\n    clearPendingLocalOffer();\n    // NOTE(mmalavalli): We store the rolled back tracks to SSRCs Map here in case\n    // setLocalDescription() is called immediately aftera rollback (without calling\n    // createOffer() or createAnswer()), in which case this roll back is not due to\n    // a glare scenario and this Map should be restored.\n    peerConnection._rolledBackTracksToSSRCs = new Map(peerConnection._tracksToSSRCs);\n    peerConnection._tracksToSSRCs = new Map(peerConnection._appliedTracksToSSRCs);\n    return Promise.resolve().then(function () {\n      return peerConnection.dispatchEvent(new Event('signalingstatechange'));\n    });\n  }\n  return peerConnection._peerConnection[setLocalDescription](description);\n}\nfunction setRemoteAnswer(peerConnection, answer) {\n  var pendingLocalOffer = peerConnection._pendingLocalOffer;\n  return peerConnection._peerConnection.setLocalDescription(pendingLocalOffer).then(function () {\n    peerConnection._pendingLocalOffer = null;\n    return peerConnection.setRemoteDescription(answer);\n  }).then(function () {\n    return peerConnection._signalingStateLatch.lower();\n  });\n}\n/**\n * Whether a SafariRTCPeerConnection has any RTCRtpReceivers(s) for the given\n * MediaStreamTrack kind.\n * @param {SafariRTCPeerConnection} peerConnection\n * @param {'audio' | 'video'} kind\n * @returns {boolean}\n */\nfunction hasReceiversForTracksOfKind(peerConnection, kind) {\n  return !!peerConnection.getTransceivers().find(function (_a) {\n    var _b = _a.receiver,\n      receiver = _b === void 0 ? {} : _b;\n    var _c = receiver.track,\n      track = _c === void 0 ? {} : _c;\n    return track.kind === kind;\n  });\n}\n/**\n * Shim an RTCDataChannel. This function mutates the RTCDataChannel.\n * @param {RTCDataChannel} dataChannel\n * @returns {RTCDataChannel}\n */\nfunction shimDataChannel(dataChannel) {\n  return Object.defineProperties(dataChannel, {\n    maxPacketLifeTime: {\n      value: dataChannel.maxPacketLifeTime === 65535 ? null : dataChannel.maxPacketLifeTime\n    },\n    maxRetransmits: {\n      value: dataChannel.maxRetransmits === 65535 ? null : dataChannel.maxRetransmits\n    }\n  });\n}\nmodule.exports = SafariRTCPeerConnection;","map":{"version":3,"names":["EventTarget","require","Latch","_a","getSdpFormat","updatePlanBTrackIdsToSSRCs","updateUnifiedPlanTrackIdsToSSRCs","_b","delegateMethods","interceptEvent","proxyProperties","isUnifiedPlan","updateTrackIdsToSSRCs","SafariRTCPeerConnection","_super","__extends","configuration","_this","call","peerConnection","RTCPeerConnection","Object","defineProperties","_appliedTracksToSSRCs","value","Map","writable","_audioTransceiver","_isClosed","_peerConnection","_pendingLocalOffer","_pendingRemoteOffer","_rolledBackTracksToSSRCs","_signalingStateLatch","_tracksToSSRCs","_videoTransceiver","addEventListener","event","shimDataChannel","channel","dispatchEvent","args","_i","arguments","length","apply","__spreadArray","__read","signalingState","prototype","defineProperty","get","localDescription","iceConnectionState","iceGatheringState","remoteDescription","addIceCandidate","candidate","when","then","createOffer","options","assign","offerToReceiveVideo","hasReceiversForTracksOfKind","offerToReceiveAudio","addTransceiver","direction","e","Promise","reject","offer","clear","RTCSessionDescription","type","sdp","createAnswer","setRemoteDescription","lower","answer","error","createDataChannel","label","dataChannelDict","dataChannel","removeTrack","sender","replaceTrack","setLocalDescription","description","size","setDescription","close","setTimeout","Event","local","setPendingLocalOffer","clearPendingLocalOffer","pendingLocalOffer","pendingRemoteOffer","intermediateState","setRemoteAnswer","Error","state","raise","previousSignalingState","resolve","kind","getTransceivers","find","receiver","_c","track","maxPacketLifeTime","maxRetransmits","module","exports"],"sources":["/home/denis/RiderProjects/ChatRoulette/WebUI/chat-app/node_modules/twilio-video/lib/webrtc/rtcpeerconnection/safari.js"],"sourcesContent":["/* globals RTCPeerConnection, RTCSessionDescription */\n'use strict';\n\nconst EventTarget = require('../../eventtarget');\nconst Latch = require('../util/latch');\nconst { getSdpFormat, updatePlanBTrackIdsToSSRCs, updateUnifiedPlanTrackIdsToSSRCs } = require('../util/sdp');\nconst { delegateMethods, interceptEvent, proxyProperties } = require('../util');\n\nconst isUnifiedPlan = getSdpFormat() === 'unified';\n\nconst updateTrackIdsToSSRCs = isUnifiedPlan\n  ? updateUnifiedPlanTrackIdsToSSRCs\n  : updatePlanBTrackIdsToSSRCs;\n\nclass SafariRTCPeerConnection extends EventTarget {\n  constructor(configuration) {\n    super();\n\n    interceptEvent(this, 'datachannel');\n    interceptEvent(this, 'iceconnectionstatechange');\n    interceptEvent(this, 'signalingstatechange');\n    interceptEvent(this, 'track');\n\n    const peerConnection = new RTCPeerConnection(configuration);\n\n    Object.defineProperties(this, {\n      _appliedTracksToSSRCs: {\n        value: new Map(),\n        writable: true\n      },\n      _audioTransceiver: {\n        value: null,\n        writable: true\n      },\n      _isClosed: {\n        value: false,\n        writable: true\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _pendingLocalOffer: {\n        value: null,\n        writable: true\n      },\n      _pendingRemoteOffer: {\n        value: null,\n        writable: true\n      },\n      _rolledBackTracksToSSRCs: {\n        value: new Map(),\n        writable: true\n      },\n      _signalingStateLatch: {\n        value: new Latch()\n      },\n      _tracksToSSRCs: {\n        value: new Map(),\n        writable: true\n      },\n      _videoTransceiver: {\n        value: null,\n        writable: true\n      }\n    });\n\n    peerConnection.addEventListener('datachannel', event => {\n      shimDataChannel(event.channel);\n      this.dispatchEvent(event);\n    });\n\n    peerConnection.addEventListener('iceconnectionstatechange', (...args) => {\n      if (this._isClosed) {\n        return;\n      }\n      this.dispatchEvent(...args);\n    });\n\n    peerConnection.addEventListener('signalingstatechange', (...args) => {\n      if (this._isClosed) {\n        return;\n      }\n      if (peerConnection.signalingState === 'stable') {\n        this._appliedTracksToSSRCs = new Map(this._tracksToSSRCs);\n      }\n      if (!this._pendingLocalOffer && !this._pendingRemoteOffer) {\n        this.dispatchEvent(...args);\n      }\n    });\n\n    // NOTE(syerrapragada): This ensures that SafariRTCPeerConnection's \"remoteDescription\", when accessed\n    // in an RTCTrackEvent listener, will point to the underlying RTCPeerConnection's\n    // \"remoteDescription\". Before this fix, this was still pointing to \"_pendingRemoteOffer\"\n    // even though a new remote RTCSessionDescription had already been applied.\n    peerConnection.addEventListener('track', event => {\n      this._pendingRemoteOffer = null;\n      this.dispatchEvent(event);\n    });\n\n    proxyProperties(RTCPeerConnection.prototype, this, peerConnection);\n\n  }\n\n  get localDescription() {\n    return this._pendingLocalOffer || this._peerConnection.localDescription;\n  }\n\n  get iceConnectionState() {\n    return this._isClosed ? 'closed' : this._peerConnection.iceConnectionState;\n  }\n\n  get iceGatheringState() {\n    return this._isClosed ? 'complete' : this._peerConnection.iceGatheringState;\n  }\n\n  get remoteDescription() {\n    return this._pendingRemoteOffer || this._peerConnection.remoteDescription;\n  }\n\n  get signalingState() {\n    if (this._isClosed) {\n      return 'closed';\n    } else if (this._pendingLocalOffer) {\n      return 'have-local-offer';\n    } else if (this._pendingRemoteOffer) {\n      return 'have-remote-offer';\n    }\n    return this._peerConnection.signalingState;\n  }\n\n  addIceCandidate(candidate) {\n    if (this.signalingState === 'have-remote-offer') {\n      return this._signalingStateLatch.when('low').then(() => this._peerConnection.addIceCandidate(candidate));\n    }\n    return this._peerConnection.addIceCandidate(candidate);\n  }\n\n  createOffer(options) {\n    options = Object.assign({}, options);\n\n    // NOTE(mroberts): In general, this is not the way to do this; however, it's\n    // good enough for our application.\n    if (options.offerToReceiveVideo && !this._audioTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'audio'))) {\n      delete options.offerToReceiveAudio;\n      try {\n        this._audioTransceiver = isUnifiedPlan\n          ? this.addTransceiver('audio', { direction: 'recvonly' })\n          : this.addTransceiver('audio');\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }\n\n    if (options.offerToReceiveVideo && !this._videoTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'video'))) {\n      delete options.offerToReceiveVideo;\n      try {\n        this._videoTransceiver = isUnifiedPlan\n          ? this.addTransceiver('video', { direction: 'recvonly' })\n          : this.addTransceiver('video');\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }\n\n    return this._peerConnection.createOffer(options).then(offer => {\n      // NOTE(mmalavalli): If createOffer() is called immediately after rolling back,\n      // then we no longer need to retain the rolled back tracks to SSRCs Map.\n      this._rolledBackTracksToSSRCs.clear();\n\n      return new RTCSessionDescription({\n        type: offer.type,\n        sdp: updateTrackIdsToSSRCs(this._tracksToSSRCs, offer.sdp)\n      });\n    });\n  }\n\n  createAnswer(options) {\n    if (this._pendingRemoteOffer) {\n      return this._peerConnection.setRemoteDescription(this._pendingRemoteOffer).then(() => {\n        this._signalingStateLatch.lower();\n        return this._peerConnection.createAnswer();\n      }).then(answer => {\n        this._pendingRemoteOffer = null;\n\n        // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n        // longer need to retain the rolled back tracks to SSRCs Map.\n        this._rolledBackTracksToSSRCs.clear();\n\n        return isUnifiedPlan ? new RTCSessionDescription({\n          type: answer.type,\n          sdp: updateTrackIdsToSSRCs(this._tracksToSSRCs, answer.sdp)\n        }) : answer;\n      }, error => {\n        this._pendingRemoteOffer = null;\n        throw error;\n      });\n    }\n\n    return this._peerConnection.createAnswer(options).then(answer => {\n      // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n      // longer need to retain the rolled back tracks to SSRCs Map.\n      this._rolledBackTracksToSSRCs.clear();\n\n      return isUnifiedPlan ? new RTCSessionDescription({\n        type: answer.type,\n        sdp: updateTrackIdsToSSRCs(this._tracksToSSRCs, answer.sdp)\n      }) : answer;\n    });\n  }\n\n  createDataChannel(label, dataChannelDict) {\n    const dataChannel = this._peerConnection.createDataChannel(label, dataChannelDict);\n    shimDataChannel(dataChannel);\n    return dataChannel;\n  }\n\n  removeTrack(sender) {\n    sender.replaceTrack(null);\n    this._peerConnection.removeTrack(sender);\n  }\n\n  setLocalDescription(description) {\n    // NOTE(mmalavalli): If setLocalDescription() is called immediately after rolling back,\n    // then we need to restore the rolled back tracks to SSRCs Map.\n    if (this._rolledBackTracksToSSRCs.size > 0) {\n      this._tracksToSSRCs = new Map(this._rolledBackTracksToSSRCs);\n      this._rolledBackTracksToSSRCs.clear();\n    }\n    return setDescription(this, true, description);\n  }\n\n  setRemoteDescription(description) {\n    // NOTE(mmalavalli): If setRemoteDescription() is called immediately after rolling back,\n    // then we no longer need to retain the rolled back tracks to SSRCs Map.\n    this._rolledBackTracksToSSRCs.clear();\n    return setDescription(this, false, description);\n  }\n\n  close() {\n    if (this._isClosed) {\n      return;\n    }\n    this._isClosed = true;\n    this._peerConnection.close();\n    setTimeout(() => {\n      this.dispatchEvent(new Event('iceconnectionstatechange'));\n      this.dispatchEvent(new Event('signalingstatechange'));\n    });\n  }\n}\n\ndelegateMethods(\n  RTCPeerConnection.prototype,\n  SafariRTCPeerConnection.prototype,\n  '_peerConnection');\n\nfunction setDescription(peerConnection, local, description) {\n  function setPendingLocalOffer(offer) {\n    if (local) {\n      peerConnection._pendingLocalOffer = offer;\n    } else {\n      peerConnection._pendingRemoteOffer = offer;\n    }\n  }\n\n  function clearPendingLocalOffer() {\n    if (local) {\n      peerConnection._pendingLocalOffer = null;\n    } else {\n      peerConnection._pendingRemoteOffer = null;\n    }\n  }\n\n  const pendingLocalOffer = local ? peerConnection._pendingLocalOffer : peerConnection._pendingRemoteOffer;\n  const pendingRemoteOffer = local ? peerConnection._pendingRemoteOffer : peerConnection._pendingLocalOffer;\n  const intermediateState = local ? 'have-local-offer' : 'have-remote-offer';\n  const setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n\n  if (!local && pendingRemoteOffer && description.type === 'answer') {\n    return setRemoteAnswer(peerConnection, description);\n  } else if (description.type === 'offer') {\n    if (peerConnection.signalingState !== intermediateState && peerConnection.signalingState !== 'stable') {\n      return Promise.reject(new Error(`Cannot set ${local ? 'local' : 'remote'}\n        offer in state ${peerConnection.signalingState}`));\n    }\n\n    if (!pendingLocalOffer && peerConnection._signalingStateLatch.state === 'low') {\n      peerConnection._signalingStateLatch.raise();\n    }\n    const previousSignalingState = peerConnection.signalingState;\n    setPendingLocalOffer(description);\n\n    // Only dispatch a signalingstatechange event if we transitioned.\n    if (peerConnection.signalingState !== previousSignalingState) {\n      return Promise.resolve().then(() => peerConnection.dispatchEvent(new Event('signalingstatechange')));\n    }\n\n    return Promise.resolve();\n  } else if (description.type === 'rollback') {\n    if (peerConnection.signalingState !== intermediateState) {\n      return Promise.reject(new Error(`Cannot rollback \n        ${local ? 'local' : 'remote'} description in ${peerConnection.signalingState}`));\n    }\n    clearPendingLocalOffer();\n\n    // NOTE(mmalavalli): We store the rolled back tracks to SSRCs Map here in case\n    // setLocalDescription() is called immediately aftera rollback (without calling\n    // createOffer() or createAnswer()), in which case this roll back is not due to\n    // a glare scenario and this Map should be restored.\n    peerConnection._rolledBackTracksToSSRCs = new Map(peerConnection._tracksToSSRCs);\n    peerConnection._tracksToSSRCs = new Map(peerConnection._appliedTracksToSSRCs);\n\n    return Promise.resolve().then(() => peerConnection.dispatchEvent(new Event('signalingstatechange')));\n  }\n\n  return peerConnection._peerConnection[setLocalDescription](description);\n}\n\nfunction setRemoteAnswer(peerConnection, answer) {\n  const pendingLocalOffer = peerConnection._pendingLocalOffer;\n  return peerConnection._peerConnection.setLocalDescription(pendingLocalOffer).then(() => {\n    peerConnection._pendingLocalOffer = null;\n    return peerConnection.setRemoteDescription(answer);\n  }).then(() => peerConnection._signalingStateLatch.lower());\n}\n\n/**\n * Whether a SafariRTCPeerConnection has any RTCRtpReceivers(s) for the given\n * MediaStreamTrack kind.\n * @param {SafariRTCPeerConnection} peerConnection\n * @param {'audio' | 'video'} kind\n * @returns {boolean}\n */\nfunction hasReceiversForTracksOfKind(peerConnection, kind) {\n  return !!peerConnection.getTransceivers().find(({ receiver = {} }) => {\n    const { track = {} } = receiver;\n    return track.kind === kind;\n  });\n}\n\n/**\n * Shim an RTCDataChannel. This function mutates the RTCDataChannel.\n * @param {RTCDataChannel} dataChannel\n * @returns {RTCDataChannel}\n */\nfunction shimDataChannel(dataChannel) {\n  return Object.defineProperties(dataChannel, {\n    maxPacketLifeTime: {\n      value: dataChannel.maxPacketLifeTime === 65535\n        ? null\n        : dataChannel.maxPacketLifeTime\n    },\n    maxRetransmits: {\n      value: dataChannel.maxRetransmits === 65535\n        ? null\n        : dataChannel.maxRetransmits\n    }\n  });\n}\n\nmodule.exports = SafariRTCPeerConnection;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}