{"ast":null,"code":"'use strict';\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\n/**\n * Create a {@link Deferred}.\n * @returns {Deferred}\n */\nfunction defer() {\n  var deferred = {};\n  deferred.promise = new Promise(function (resolve, reject) {\n    deferred.resolve = resolve;\n    deferred.reject = reject;\n  });\n  return deferred;\n}\n/**\n * Copy a method from a `source` prototype onto a `wrapper` prototype. Invoking\n * the method on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} methodName\n * @returns {undefined}\n */\nfunction delegateMethod(source, wrapper, target, methodName) {\n  if (methodName in wrapper) {\n    // Skip any methods already set.\n    return;\n  } else if (methodName.match(/^on[a-z]+$/)) {\n    // Skip EventHandlers (these are handled in the constructor).\n    return;\n  }\n  var isProperty = false;\n  try {\n    var propDesc = Object.getOwnPropertyDescriptor(source, methodName);\n    isProperty = propDesc && !!propDesc.get;\n  } catch (error) {\n    // its okay to eat failure here.\n  }\n  // NOTE(mpatwardhan):skip properties. we are only interested in overriding\n  // functions. we do not even want to evaluate  `typeof source[methodName]` for properties\n  // because getter would get invoked, and they might have side effects.\n  // For example RTCPeerConnection.peerIdentity is a property that returns a promise.\n  // calling typeof RTCPeerConnection.peerIdentity, would leak a promise, and in case it rejects\n  // we see errors.\n  if (isProperty) {\n    return;\n  }\n  var type;\n  try {\n    type = typeof source[methodName];\n  } catch (error) {\n    // NOTE(mroberts): Attempting to check the type of non-function members\n    // on the prototype throws an error for some types.\n  }\n  if (type !== 'function') {\n    // Skip non-function members.\n    return;\n  }\n  /* eslint no-loop-func:0 */\n  wrapper[methodName] = function () {\n    return this[target][methodName].apply(this[target], arguments);\n  };\n}\n/**\n * Copy methods from a `source` prototype onto a `wrapper` prototype. Invoking\n * the methods on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\nfunction delegateMethods(source, wrapper, target) {\n  for (var methodName in source) {\n    delegateMethod(source, wrapper, target, methodName);\n  }\n}\n/**\n * Finds the items in list1 that are not in list2.\n * @param {Array<*>|Map<*>|Set<*>} list1\n * @param {Array<*>|Map<*>|Set<*>} list2\n * @returns {Set}\n */\nfunction difference(list1, list2) {\n  list1 = Array.isArray(list1) ? new Set(list1) : new Set(list1.values());\n  list2 = Array.isArray(list2) ? new Set(list2) : new Set(list2.values());\n  var difference = new Set();\n  list1.forEach(function (item) {\n    if (!list2.has(item)) {\n      difference.add(item);\n    }\n  });\n  return difference;\n}\n/**\n * Map a list to an array of arrays, and return the flattened result.\n * @param {Array<*>|Set<*>|Map<*>} list\n * @param {function(*): Array<*>} mapFn\n * @returns Array<*>\n */\nfunction flatMap(list, mapFn) {\n  var listArray = list instanceof Map || list instanceof Set ? Array.from(list.values()) : list;\n  return listArray.reduce(function (flattened, item) {\n    return flattened.concat(mapFn(item));\n  }, []);\n}\n/**\n * Get the browser's user agent, if available.\n * @returns {?string}\n */\nfunction getUserAgent() {\n  return typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' ? navigator.userAgent : null;\n}\n/**\n * Guess the browser.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {?string} browser - \"chrome\", \"firefox\", \"safari\", or null\n */\nfunction guessBrowser(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n  if (/Chrome|CriOS/.test(userAgent)) {\n    return 'chrome';\n  }\n  if (/Firefox|FxiOS/.test(userAgent)) {\n    return 'firefox';\n  }\n  if (/Safari|iPhone|iPad|iPod/.test(userAgent)) {\n    return 'safari';\n  }\n  return null;\n}\n/**\n * Guess the browser version.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {?{major: number, minor: number}}\n */\nfunction guessBrowserVersion(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n  var prefix = {\n    chrome: 'Chrome|CriOS',\n    firefox: 'Firefox|FxiOS',\n    safari: 'Version'\n  }[guessBrowser(userAgent)];\n  if (!prefix) {\n    return null;\n  }\n  var regex = new RegExp(\"(\" + prefix + \")/([^\\\\s]+)\");\n  var _a = __read(userAgent.match(regex) || [], 3),\n    match = _a[2];\n  if (!match) {\n    return null;\n  }\n  var versions = match.split('.').map(Number);\n  return {\n    major: isNaN(versions[0]) ? null : versions[0],\n    minor: isNaN(versions[1]) ? null : versions[1]\n  };\n}\n/**\n * Check whether the current browser is iOS Chrome.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {boolean}\n */\nfunction isIOSChrome(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n  return /Mobi/.test(userAgent) && guessBrowser() === 'chrome' && /iPad|iPhone|iPod/.test(userAgent);\n}\n/**\n * Intercept an event that might otherwise be proxied on an EventTarget.\n * @param {EventTarget} target\n * @param {string} type\n * @returns {void}\n */\nfunction interceptEvent(target, type) {\n  var currentListener = null;\n  Object.defineProperty(target, 'on' + type, {\n    get: function () {\n      return currentListener;\n    },\n    set: function (newListener) {\n      if (currentListener) {\n        this.removeEventListener(type, currentListener);\n      }\n      if (typeof newListener === 'function') {\n        currentListener = newListener;\n        this.addEventListener(type, currentListener);\n      } else {\n        currentListener = null;\n      }\n    }\n  });\n}\n/**\n * This is a function for turning a Promise into the kind referenced in the\n * Legacy Interface Extensions section of the WebRTC spec.\n * @param {Promise<*>} promise\n * @param {function<*>} onSuccess\n * @param {function<Error>} onFailure\n * @returns {Promise<undefined>}\n */\nfunction legacyPromise(promise, onSuccess, onFailure) {\n  return onSuccess ? promise.then(onSuccess, onFailure) : promise;\n}\n/**\n * Make a unique ID.\n * @return {string}\n */\nfunction makeUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0;\n    var v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n/**\n * For each property name on the `source` prototype, add getters and/or setters\n * to `wrapper` that proxy to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\nfunction proxyProperties(source, wrapper, target) {\n  Object.getOwnPropertyNames(source).forEach(function (propertyName) {\n    proxyProperty(source, wrapper, target, propertyName);\n  });\n}\n/**\n * For the property name on the `source` prototype, add a getter and/or setter\n * to `wrapper` that proxies to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} propertyName\n * @returns {undefined}\n */\nfunction proxyProperty(source, wrapper, target, propertyName) {\n  if (propertyName in wrapper) {\n    // Skip any properties already set.\n    return;\n  } else if (propertyName.match(/^on[a-z]+$/)) {\n    Object.defineProperty(wrapper, propertyName, {\n      value: null,\n      writable: true\n    });\n    target.addEventListener(propertyName.slice(2), function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      return wrapper.dispatchEvent.apply(wrapper, __spreadArray([], __read(args)));\n    });\n    return;\n  }\n  Object.defineProperty(wrapper, propertyName, {\n    enumerable: true,\n    get: function () {\n      return target[propertyName];\n    }\n  });\n}\n/**\n * Check whether native WebRTC APIs are supported.\n * @returns {boolean}\n */\nfunction support() {\n  return typeof navigator === 'object' && typeof navigator.mediaDevices === 'object' && typeof navigator.mediaDevices.getUserMedia === 'function' && typeof RTCPeerConnection === 'function';\n}\n/**\n * Create a Set of supported codecs for a certain kind of media.\n * @param {'audio'|'video'} kind\n * @returns {Promise<Set<AudioCodec|VideoCodec>>}\n */\nfunction createSupportedCodecsSet(kind) {\n  if (typeof RTCRtpSender !== 'undefined' && typeof RTCRtpSender.getCapabilities === 'function') {\n    return Promise.resolve(new Set(RTCRtpSender.getCapabilities(kind).codecs.map(function (_a) {\n      var mimeType = _a.mimeType;\n      return mimeType.split('/')[1].toLowerCase();\n    })));\n  }\n  if (typeof RTCPeerConnection === 'undefined' || typeof RTCPeerConnection.prototype === 'undefined' || typeof RTCPeerConnection.prototype.addTransceiver !== 'function' || typeof RTCPeerConnection.prototype.close !== 'function' || typeof RTCPeerConnection.prototype.createOffer !== 'function') {\n    return Promise.resolve(new Set());\n  }\n  var pc = new RTCPeerConnection();\n  pc.addTransceiver(kind);\n  return pc.createOffer().then(function (_a) {\n    var sdp = _a.sdp;\n    pc.close();\n    return new Set((sdp.match(/^a=rtpmap:.+$/gm) || []).map(function (line) {\n      return line.match(/^a=rtpmap:.+ ([^/]+)/)[1].toLowerCase();\n    }));\n  }, function () {\n    pc.close();\n    return new Set();\n  });\n}\n// NOTE(mmalavalli): Cache the supported audio and video codecs here.\nvar supportedCodecs = new Map();\n/**\n * Check whether a given codec for a certain kind of media is supported.\n * @param {AudioCodec|VideoCodec} codec\n * @param {'audio'|'video'} kind\n * @returns {Promise<boolean>}\n */\nfunction isCodecSupported(codec, kind) {\n  var codecs = supportedCodecs.get(kind);\n  if (codecs) {\n    return Promise.resolve(codecs.has(codec.toLowerCase()));\n  }\n  return createSupportedCodecsSet(kind).then(function (codecs) {\n    supportedCodecs.set(kind, codecs);\n    return codecs.has(codec.toLowerCase());\n  });\n}\n/**\n * Clear cached supported codecs (unit tests only).\n */\nfunction clearCachedSupportedCodecs() {\n  supportedCodecs.clear();\n}\n/**\n * @typedef {object} Deferred\n * @property {Promise} promise\n * @property {function} reject\n * @property {function} resolve\n */\nexports.clearCachedSupportedCodecs = clearCachedSupportedCodecs;\nexports.defer = defer;\nexports.delegateMethods = delegateMethods;\nexports.difference = difference;\nexports.flatMap = flatMap;\nexports.guessBrowser = guessBrowser;\nexports.guessBrowserVersion = guessBrowserVersion;\nexports.isCodecSupported = isCodecSupported;\nexports.isIOSChrome = isIOSChrome;\nexports.interceptEvent = interceptEvent;\nexports.legacyPromise = legacyPromise;\nexports.makeUUID = makeUUID;\nexports.proxyProperties = proxyProperties;\nexports.support = support;","map":{"version":3,"names":["defer","deferred","promise","Promise","resolve","reject","delegateMethod","source","wrapper","target","methodName","match","isProperty","propDesc","Object","getOwnPropertyDescriptor","get","error","type","apply","arguments","delegateMethods","difference","list1","list2","Array","isArray","Set","values","forEach","item","has","add","flatMap","list","mapFn","listArray","Map","from","reduce","flattened","concat","getUserAgent","navigator","userAgent","guessBrowser","test","guessBrowserVersion","prefix","chrome","firefox","safari","regex","RegExp","_a","__read","versions","split","map","Number","major","isNaN","minor","isIOSChrome","interceptEvent","currentListener","defineProperty","set","newListener","removeEventListener","addEventListener","legacyPromise","onSuccess","onFailure","then","makeUUID","replace","c","r","Math","random","v","toString","proxyProperties","getOwnPropertyNames","propertyName","proxyProperty","value","writable","slice","args","_i","length","dispatchEvent","__spreadArray","enumerable","support","mediaDevices","getUserMedia","RTCPeerConnection","createSupportedCodecsSet","kind","RTCRtpSender","getCapabilities","codecs","mimeType","toLowerCase","prototype","addTransceiver","close","createOffer","pc","sdp","line","supportedCodecs","isCodecSupported","codec","clearCachedSupportedCodecs","clear","exports"],"sources":["/home/denis/RiderProjects/ChatRoulette/WebUI/chat-app/node_modules/twilio-video/lib/webrtc/util/index.js"],"sourcesContent":["'use strict';\n\n/**\n * Create a {@link Deferred}.\n * @returns {Deferred}\n */\nfunction defer() {\n  const deferred = {};\n  deferred.promise = new Promise((resolve, reject) => {\n    deferred.resolve = resolve;\n    deferred.reject = reject;\n  });\n  return deferred;\n}\n\n/**\n * Copy a method from a `source` prototype onto a `wrapper` prototype. Invoking\n * the method on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} methodName\n * @returns {undefined}\n */\nfunction delegateMethod(source, wrapper, target, methodName) {\n  if (methodName in wrapper) {\n    // Skip any methods already set.\n    return;\n  } else if (methodName.match(/^on[a-z]+$/)) {\n    // Skip EventHandlers (these are handled in the constructor).\n    return;\n  }\n\n\n  let isProperty = false;\n  try {\n    const propDesc = Object.getOwnPropertyDescriptor(source, methodName);\n    isProperty = propDesc && !!propDesc.get;\n  } catch (error) {\n    // its okay to eat failure here.\n  }\n\n  // NOTE(mpatwardhan):skip properties. we are only interested in overriding\n  // functions. we do not even want to evaluate  `typeof source[methodName]` for properties\n  // because getter would get invoked, and they might have side effects.\n  // For example RTCPeerConnection.peerIdentity is a property that returns a promise.\n  // calling typeof RTCPeerConnection.peerIdentity, would leak a promise, and in case it rejects\n  // we see errors.\n  if (isProperty) {\n    return;\n  }\n\n  let type;\n  try {\n    type = typeof source[methodName];\n  } catch (error) {\n    // NOTE(mroberts): Attempting to check the type of non-function members\n    // on the prototype throws an error for some types.\n  }\n\n  if (type !== 'function') {\n    // Skip non-function members.\n    return;\n  }\n\n  /* eslint no-loop-func:0 */\n  wrapper[methodName] = function() {\n    return this[target][methodName].apply(this[target], arguments);\n  };\n}\n\n/**\n * Copy methods from a `source` prototype onto a `wrapper` prototype. Invoking\n * the methods on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\nfunction delegateMethods(source, wrapper, target) {\n  for (const methodName in source) {\n    delegateMethod(source, wrapper, target, methodName);\n  }\n}\n\n/**\n * Finds the items in list1 that are not in list2.\n * @param {Array<*>|Map<*>|Set<*>} list1\n * @param {Array<*>|Map<*>|Set<*>} list2\n * @returns {Set}\n */\nfunction difference(list1, list2) {\n  list1 = Array.isArray(list1) ? new Set(list1) : new Set(list1.values());\n  list2 = Array.isArray(list2) ? new Set(list2) : new Set(list2.values());\n\n  const difference = new Set();\n\n  list1.forEach(item => {\n    if (!list2.has(item)) {\n      difference.add(item);\n    }\n  });\n\n  return difference;\n}\n\n/**\n * Map a list to an array of arrays, and return the flattened result.\n * @param {Array<*>|Set<*>|Map<*>} list\n * @param {function(*): Array<*>} mapFn\n * @returns Array<*>\n */\nfunction flatMap(list, mapFn) {\n  const listArray = list instanceof Map || list instanceof Set\n    ? Array.from(list.values())\n    : list;\n\n  return listArray.reduce((flattened, item) => flattened.concat(mapFn(item)), []);\n}\n\n/**\n * Get the browser's user agent, if available.\n * @returns {?string}\n */\nfunction getUserAgent() {\n  return typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string'\n    ? navigator.userAgent\n    : null;\n}\n\n/**\n * Guess the browser.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {?string} browser - \"chrome\", \"firefox\", \"safari\", or null\n */\nfunction guessBrowser(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n  if (/Chrome|CriOS/.test(userAgent)) {\n    return 'chrome';\n  }\n  if (/Firefox|FxiOS/.test(userAgent)) {\n    return 'firefox';\n  }\n  if (/Safari|iPhone|iPad|iPod/.test(userAgent)) {\n    return 'safari';\n  }\n  return null;\n}\n\n/**\n * Guess the browser version.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {?{major: number, minor: number}}\n */\nfunction guessBrowserVersion(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n  const prefix = {\n    chrome: 'Chrome|CriOS',\n    firefox: 'Firefox|FxiOS',\n    safari: 'Version'\n  }[guessBrowser(userAgent)];\n\n  if (!prefix) {\n    return null;\n  }\n  const regex = new RegExp(`(${prefix})/([^\\\\s]+)`);\n  const [, , match] = userAgent.match(regex) || [];\n\n  if (!match) {\n    return null;\n  }\n  const versions = match.split('.').map(Number);\n  return {\n    major: isNaN(versions[0]) ? null : versions[0],\n    minor: isNaN(versions[1]) ? null : versions[1]\n  };\n}\n\n/**\n * Check whether the current browser is iOS Chrome.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {boolean}\n */\nfunction isIOSChrome(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n  return (/Mobi/.test(userAgent) && guessBrowser() === 'chrome' && /iPad|iPhone|iPod/.test(userAgent));\n}\n\n/**\n * Intercept an event that might otherwise be proxied on an EventTarget.\n * @param {EventTarget} target\n * @param {string} type\n * @returns {void}\n */\nfunction interceptEvent(target, type) {\n  let currentListener = null;\n  Object.defineProperty(target, 'on' + type, {\n    get: function() {\n      return currentListener;\n    },\n    set: function(newListener) {\n      if (currentListener) {\n        this.removeEventListener(type, currentListener);\n      }\n\n      if (typeof newListener === 'function') {\n        currentListener = newListener;\n        this.addEventListener(type, currentListener);\n      } else {\n        currentListener = null;\n      }\n    }\n  });\n}\n\n/**\n * This is a function for turning a Promise into the kind referenced in the\n * Legacy Interface Extensions section of the WebRTC spec.\n * @param {Promise<*>} promise\n * @param {function<*>} onSuccess\n * @param {function<Error>} onFailure\n * @returns {Promise<undefined>}\n */\nfunction legacyPromise(promise, onSuccess, onFailure) {\n  return onSuccess\n    ? promise.then(onSuccess, onFailure)\n    : promise;\n}\n\n/**\n * Make a unique ID.\n * @return {string}\n */\nfunction makeUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\n/**\n * For each property name on the `source` prototype, add getters and/or setters\n * to `wrapper` that proxy to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\nfunction proxyProperties(source, wrapper, target) {\n  Object.getOwnPropertyNames(source).forEach(propertyName => {\n    proxyProperty(source, wrapper, target, propertyName);\n  });\n}\n\n/**\n * For the property name on the `source` prototype, add a getter and/or setter\n * to `wrapper` that proxies to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} propertyName\n * @returns {undefined}\n */\nfunction proxyProperty(source, wrapper, target, propertyName) {\n  if (propertyName in wrapper) {\n    // Skip any properties already set.\n    return;\n  } else if (propertyName.match(/^on[a-z]+$/)) {\n    Object.defineProperty(wrapper, propertyName, {\n      value: null,\n      writable: true\n    });\n\n    target.addEventListener(\n      propertyName.slice(2),\n      (...args) => wrapper.dispatchEvent(...args)\n    );\n\n    return;\n  }\n\n  Object.defineProperty(wrapper, propertyName, {\n    enumerable: true,\n    get: function() {\n      return target[propertyName];\n    }\n  });\n}\n\n/**\n * Check whether native WebRTC APIs are supported.\n * @returns {boolean}\n */\nfunction support() {\n  return typeof navigator === 'object'\n    && typeof navigator.mediaDevices === 'object'\n    && typeof navigator.mediaDevices.getUserMedia === 'function'\n    && typeof RTCPeerConnection === 'function';\n}\n\n/**\n * Create a Set of supported codecs for a certain kind of media.\n * @param {'audio'|'video'} kind\n * @returns {Promise<Set<AudioCodec|VideoCodec>>}\n */\nfunction createSupportedCodecsSet(kind) {\n  if (typeof RTCRtpSender !== 'undefined'\n    && typeof RTCRtpSender.getCapabilities === 'function') {\n    return Promise.resolve(new Set(\n      RTCRtpSender\n        .getCapabilities(kind)\n        .codecs\n        .map(({ mimeType }) => mimeType.split('/')[1].toLowerCase())\n    ));\n  }\n  if (typeof RTCPeerConnection === 'undefined'\n    || typeof RTCPeerConnection.prototype === 'undefined'\n    || typeof RTCPeerConnection.prototype.addTransceiver !== 'function'\n    || typeof RTCPeerConnection.prototype.close !== 'function'\n    || typeof RTCPeerConnection.prototype.createOffer !== 'function') {\n    return Promise.resolve(new Set());\n  }\n  const pc = new RTCPeerConnection();\n  pc.addTransceiver(kind);\n  return pc.createOffer().then(({ sdp }) => {\n    pc.close();\n    return new Set((sdp.match(/^a=rtpmap:.+$/gm) || [])\n      .map(line => line.match(/^a=rtpmap:.+ ([^/]+)/)[1].toLowerCase()));\n  }, () => {\n    pc.close();\n    return new Set();\n  });\n}\n\n// NOTE(mmalavalli): Cache the supported audio and video codecs here.\nconst supportedCodecs = new Map();\n\n/**\n * Check whether a given codec for a certain kind of media is supported.\n * @param {AudioCodec|VideoCodec} codec\n * @param {'audio'|'video'} kind\n * @returns {Promise<boolean>}\n */\nfunction isCodecSupported(codec, kind) {\n  const codecs = supportedCodecs.get(kind);\n  if (codecs) {\n    return Promise.resolve(codecs.has(codec.toLowerCase()));\n  }\n  return createSupportedCodecsSet(kind).then(codecs => {\n    supportedCodecs.set(kind, codecs);\n    return codecs.has(codec.toLowerCase());\n  });\n}\n\n/**\n * Clear cached supported codecs (unit tests only).\n */\nfunction clearCachedSupportedCodecs() {\n  supportedCodecs.clear();\n}\n\n/**\n * @typedef {object} Deferred\n * @property {Promise} promise\n * @property {function} reject\n * @property {function} resolve\n */\n\nexports.clearCachedSupportedCodecs = clearCachedSupportedCodecs;\nexports.defer = defer;\nexports.delegateMethods = delegateMethods;\nexports.difference = difference;\nexports.flatMap = flatMap;\nexports.guessBrowser = guessBrowser;\nexports.guessBrowserVersion = guessBrowserVersion;\nexports.isCodecSupported = isCodecSupported;\nexports.isIOSChrome = isIOSChrome;\nexports.interceptEvent = interceptEvent;\nexports.legacyPromise = legacyPromise;\nexports.makeUUID = makeUUID;\nexports.proxyProperties = proxyProperties;\nexports.support = support;\n"],"mappings":"AAAA,YAAY;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEZ;;;;AAIA,SAASA,KAAKA,CAAA;EACZ,IAAMC,QAAQ,GAAG,EAAE;EACnBA,QAAQ,CAACC,OAAO,GAAG,IAAIC,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM;IAC7CJ,QAAQ,CAACG,OAAO,GAAGA,OAAO;IAC1BH,QAAQ,CAACI,MAAM,GAAGA,MAAM;EAC1B,CAAC,CAAC;EACF,OAAOJ,QAAQ;AACjB;AAEA;;;;;;;;;;AAUA,SAASK,cAAcA,CAACC,MAAM,EAAEC,OAAO,EAAEC,MAAM,EAAEC,UAAU;EACzD,IAAIA,UAAU,IAAIF,OAAO,EAAE;IACzB;IACA;GACD,MAAM,IAAIE,UAAU,CAACC,KAAK,CAAC,YAAY,CAAC,EAAE;IACzC;IACA;;EAIF,IAAIC,UAAU,GAAG,KAAK;EACtB,IAAI;IACF,IAAMC,QAAQ,GAAGC,MAAM,CAACC,wBAAwB,CAACR,MAAM,EAAEG,UAAU,CAAC;IACpEE,UAAU,GAAGC,QAAQ,IAAI,CAAC,CAACA,QAAQ,CAACG,GAAG;GACxC,CAAC,OAAOC,KAAK,EAAE;IACd;EAAA;EAGF;EACA;EACA;EACA;EACA;EACA;EACA,IAAIL,UAAU,EAAE;IACd;;EAGF,IAAIM,IAAI;EACR,IAAI;IACFA,IAAI,GAAG,OAAOX,MAAM,CAACG,UAAU,CAAC;GACjC,CAAC,OAAOO,KAAK,EAAE;IACd;IACA;EAAA;EAGF,IAAIC,IAAI,KAAK,UAAU,EAAE;IACvB;IACA;;EAGF;EACAV,OAAO,CAACE,UAAU,CAAC,GAAG;IACpB,OAAO,IAAI,CAACD,MAAM,CAAC,CAACC,UAAU,CAAC,CAACS,KAAK,CAAC,IAAI,CAACV,MAAM,CAAC,EAAEW,SAAS,CAAC;EAChE,CAAC;AACH;AAEA;;;;;;;;;AASA,SAASC,eAAeA,CAACd,MAAM,EAAEC,OAAO,EAAEC,MAAM;EAC9C,KAAK,IAAMC,UAAU,IAAIH,MAAM,EAAE;IAC/BD,cAAc,CAACC,MAAM,EAAEC,OAAO,EAAEC,MAAM,EAAEC,UAAU,CAAC;;AAEvD;AAEA;;;;;;AAMA,SAASY,UAAUA,CAACC,KAAK,EAAEC,KAAK;EAC9BD,KAAK,GAAGE,KAAK,CAACC,OAAO,CAACH,KAAK,CAAC,GAAG,IAAII,GAAG,CAACJ,KAAK,CAAC,GAAG,IAAII,GAAG,CAACJ,KAAK,CAACK,MAAM,EAAE,CAAC;EACvEJ,KAAK,GAAGC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,GAAG,IAAIG,GAAG,CAACH,KAAK,CAAC,GAAG,IAAIG,GAAG,CAACH,KAAK,CAACI,MAAM,EAAE,CAAC;EAEvE,IAAMN,UAAU,GAAG,IAAIK,GAAG,EAAE;EAE5BJ,KAAK,CAACM,OAAO,CAAC,UAAAC,IAAI;IAChB,IAAI,CAACN,KAAK,CAACO,GAAG,CAACD,IAAI,CAAC,EAAE;MACpBR,UAAU,CAACU,GAAG,CAACF,IAAI,CAAC;;EAExB,CAAC,CAAC;EAEF,OAAOR,UAAU;AACnB;AAEA;;;;;;AAMA,SAASW,OAAOA,CAACC,IAAI,EAAEC,KAAK;EAC1B,IAAMC,SAAS,GAAGF,IAAI,YAAYG,GAAG,IAAIH,IAAI,YAAYP,GAAG,GACxDF,KAAK,CAACa,IAAI,CAACJ,IAAI,CAACN,MAAM,EAAE,CAAC,GACzBM,IAAI;EAER,OAAOE,SAAS,CAACG,MAAM,CAAC,UAACC,SAAS,EAAEV,IAAI;IAAK,OAAAU,SAAS,CAACC,MAAM,CAACN,KAAK,CAACL,IAAI,CAAC,CAAC;EAA7B,CAA6B,EAAE,EAAE,CAAC;AACjF;AAEA;;;;AAIA,SAASY,YAAYA,CAAA;EACnB,OAAO,OAAOC,SAAS,KAAK,WAAW,IAAI,OAAOA,SAAS,CAACC,SAAS,KAAK,QAAQ,GAC9ED,SAAS,CAACC,SAAS,GACnB,IAAI;AACV;AAEA;;;;;AAKA,SAASC,YAAYA,CAACD,SAAS;EAC7B,IAAI,OAAOA,SAAS,KAAK,WAAW,EAAE;IACpCA,SAAS,GAAGF,YAAY,EAAE;;EAE5B,IAAI,cAAc,CAACI,IAAI,CAACF,SAAS,CAAC,EAAE;IAClC,OAAO,QAAQ;;EAEjB,IAAI,eAAe,CAACE,IAAI,CAACF,SAAS,CAAC,EAAE;IACnC,OAAO,SAAS;;EAElB,IAAI,yBAAyB,CAACE,IAAI,CAACF,SAAS,CAAC,EAAE;IAC7C,OAAO,QAAQ;;EAEjB,OAAO,IAAI;AACb;AAEA;;;;;AAKA,SAASG,mBAAmBA,CAACH,SAAS;EACpC,IAAI,OAAOA,SAAS,KAAK,WAAW,EAAE;IACpCA,SAAS,GAAGF,YAAY,EAAE;;EAE5B,IAAMM,MAAM,GAAG;IACbC,MAAM,EAAE,cAAc;IACtBC,OAAO,EAAE,eAAe;IACxBC,MAAM,EAAE;GACT,CAACN,YAAY,CAACD,SAAS,CAAC,CAAC;EAE1B,IAAI,CAACI,MAAM,EAAE;IACX,OAAO,IAAI;;EAEb,IAAMI,KAAK,GAAG,IAAIC,MAAM,CAAC,MAAIL,MAAM,gBAAa,CAAC;EAC3C,IAAAM,EAAA,GAAAC,MAAA,CAAcX,SAAS,CAACjC,KAAK,CAACyC,KAAK,CAAC,IAAI,EAAE;IAArCzC,KAAK,GAAA2C,EAAA,GAAgC;EAEhD,IAAI,CAAC3C,KAAK,EAAE;IACV,OAAO,IAAI;;EAEb,IAAM6C,QAAQ,GAAG7C,KAAK,CAAC8C,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAACC,MAAM,CAAC;EAC7C,OAAO;IACLC,KAAK,EAAEC,KAAK,CAACL,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,GAAGA,QAAQ,CAAC,CAAC,CAAC;IAC9CM,KAAK,EAAED,KAAK,CAACL,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,GAAGA,QAAQ,CAAC,CAAC;GAC9C;AACH;AAEA;;;;;AAKA,SAASO,WAAWA,CAACnB,SAAS;EAC5B,IAAI,OAAOA,SAAS,KAAK,WAAW,EAAE;IACpCA,SAAS,GAAGF,YAAY,EAAE;;EAE5B,OAAQ,MAAM,CAACI,IAAI,CAACF,SAAS,CAAC,IAAIC,YAAY,EAAE,KAAK,QAAQ,IAAI,kBAAkB,CAACC,IAAI,CAACF,SAAS,CAAC;AACrG;AAEA;;;;;;AAMA,SAASoB,cAAcA,CAACvD,MAAM,EAAES,IAAI;EAClC,IAAI+C,eAAe,GAAG,IAAI;EAC1BnD,MAAM,CAACoD,cAAc,CAACzD,MAAM,EAAE,IAAI,GAAGS,IAAI,EAAE;IACzCF,GAAG,EAAE,SAAAA,CAAA;MACH,OAAOiD,eAAe;IACxB,CAAC;IACDE,GAAG,EAAE,SAAAA,CAASC,WAAW;MACvB,IAAIH,eAAe,EAAE;QACnB,IAAI,CAACI,mBAAmB,CAACnD,IAAI,EAAE+C,eAAe,CAAC;;MAGjD,IAAI,OAAOG,WAAW,KAAK,UAAU,EAAE;QACrCH,eAAe,GAAGG,WAAW;QAC7B,IAAI,CAACE,gBAAgB,CAACpD,IAAI,EAAE+C,eAAe,CAAC;OAC7C,MAAM;QACLA,eAAe,GAAG,IAAI;;IAE1B;GACD,CAAC;AACJ;AAEA;;;;;;;;AAQA,SAASM,aAAaA,CAACrE,OAAO,EAAEsE,SAAS,EAAEC,SAAS;EAClD,OAAOD,SAAS,GACZtE,OAAO,CAACwE,IAAI,CAACF,SAAS,EAAEC,SAAS,CAAC,GAClCvE,OAAO;AACb;AAEA;;;;AAIA,SAASyE,QAAQA,CAAA;EACf,OAAO,sCAAsC,CAACC,OAAO,CAAC,OAAO,EAAE,UAAAC,CAAC;IAC9D,IAAMC,CAAC,GAAGC,IAAI,CAACC,MAAM,EAAE,GAAG,EAAE,GAAG,CAAC;IAChC,IAAMC,CAAC,GAAGJ,CAAC,KAAK,GAAG,GAAGC,CAAC,GAAIA,CAAC,GAAG,GAAG,GAAG,GAAI;IACzC,OAAOG,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC;EACvB,CAAC,CAAC;AACJ;AAEA;;;;;;;;AAQA,SAASC,eAAeA,CAAC5E,MAAM,EAAEC,OAAO,EAAEC,MAAM;EAC9CK,MAAM,CAACsE,mBAAmB,CAAC7E,MAAM,CAAC,CAACsB,OAAO,CAAC,UAAAwD,YAAY;IACrDC,aAAa,CAAC/E,MAAM,EAAEC,OAAO,EAAEC,MAAM,EAAE4E,YAAY,CAAC;EACtD,CAAC,CAAC;AACJ;AAEA;;;;;;;;;AASA,SAASC,aAAaA,CAAC/E,MAAM,EAAEC,OAAO,EAAEC,MAAM,EAAE4E,YAAY;EAC1D,IAAIA,YAAY,IAAI7E,OAAO,EAAE;IAC3B;IACA;GACD,MAAM,IAAI6E,YAAY,CAAC1E,KAAK,CAAC,YAAY,CAAC,EAAE;IAC3CG,MAAM,CAACoD,cAAc,CAAC1D,OAAO,EAAE6E,YAAY,EAAE;MAC3CE,KAAK,EAAE,IAAI;MACXC,QAAQ,EAAE;KACX,CAAC;IAEF/E,MAAM,CAAC6D,gBAAgB,CACrBe,YAAY,CAACI,KAAK,CAAC,CAAC,CAAC,EACrB;MAAC,IAAAC,IAAA;WAAA,IAAAC,EAAA,IAAO,EAAPA,EAAA,GAAAvE,SAAA,CAAAwE,MAAO,EAAPD,EAAA,EAAO;QAAPD,IAAA,CAAAC,EAAA,IAAAvE,SAAA,CAAAuE,EAAA;;MAAY,OAAAnF,OAAO,CAACqF,aAAa,CAAA1E,KAAA,CAArBX,OAAO,EAAAsF,aAAA,KAAAvC,MAAA,CAAkBmC,IAAI;IAA7B,CAA8B,CAC5C;IAED;;EAGF5E,MAAM,CAACoD,cAAc,CAAC1D,OAAO,EAAE6E,YAAY,EAAE;IAC3CU,UAAU,EAAE,IAAI;IAChB/E,GAAG,EAAE,SAAAA,CAAA;MACH,OAAOP,MAAM,CAAC4E,YAAY,CAAC;IAC7B;GACD,CAAC;AACJ;AAEA;;;;AAIA,SAASW,OAAOA,CAAA;EACd,OAAO,OAAOrD,SAAS,KAAK,QAAQ,IAC/B,OAAOA,SAAS,CAACsD,YAAY,KAAK,QAAQ,IAC1C,OAAOtD,SAAS,CAACsD,YAAY,CAACC,YAAY,KAAK,UAAU,IACzD,OAAOC,iBAAiB,KAAK,UAAU;AAC9C;AAEA;;;;;AAKA,SAASC,wBAAwBA,CAACC,IAAI;EACpC,IAAI,OAAOC,YAAY,KAAK,WAAW,IAClC,OAAOA,YAAY,CAACC,eAAe,KAAK,UAAU,EAAE;IACvD,OAAOpG,OAAO,CAACC,OAAO,CAAC,IAAIuB,GAAG,CAC5B2E,YAAY,CACTC,eAAe,CAACF,IAAI,CAAC,CACrBG,MAAM,CACN9C,GAAG,CAAC,UAACJ,EAAY;UAAVmD,QAAQ,GAAAnD,EAAA,CAAAmD,QAAA;MAAO,OAAAA,QAAQ,CAAChD,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAACiD,WAAW,EAAE;IAApC,CAAoC,CAAC,CAC/D,CAAC;;EAEJ,IAAI,OAAOP,iBAAiB,KAAK,WAAW,IACvC,OAAOA,iBAAiB,CAACQ,SAAS,KAAK,WAAW,IAClD,OAAOR,iBAAiB,CAACQ,SAAS,CAACC,cAAc,KAAK,UAAU,IAChE,OAAOT,iBAAiB,CAACQ,SAAS,CAACE,KAAK,KAAK,UAAU,IACvD,OAAOV,iBAAiB,CAACQ,SAAS,CAACG,WAAW,KAAK,UAAU,EAAE;IAClE,OAAO3G,OAAO,CAACC,OAAO,CAAC,IAAIuB,GAAG,EAAE,CAAC;;EAEnC,IAAMoF,EAAE,GAAG,IAAIZ,iBAAiB,EAAE;EAClCY,EAAE,CAACH,cAAc,CAACP,IAAI,CAAC;EACvB,OAAOU,EAAE,CAACD,WAAW,EAAE,CAACpC,IAAI,CAAC,UAACpB,EAAO;QAAL0D,GAAG,GAAA1D,EAAA,CAAA0D,GAAA;IACjCD,EAAE,CAACF,KAAK,EAAE;IACV,OAAO,IAAIlF,GAAG,CAAC,CAACqF,GAAG,CAACrG,KAAK,CAAC,iBAAiB,CAAC,IAAI,EAAE,EAC/C+C,GAAG,CAAC,UAAAuD,IAAI;MAAI,OAAAA,IAAI,CAACtG,KAAK,CAAC,sBAAsB,CAAC,CAAC,CAAC,CAAC,CAAC+F,WAAW,EAAE;IAAnD,CAAmD,CAAC,CAAC;EACtE,CAAC,EAAE;IACDK,EAAE,CAACF,KAAK,EAAE;IACV,OAAO,IAAIlF,GAAG,EAAE;EAClB,CAAC,CAAC;AACJ;AAEA;AACA,IAAMuF,eAAe,GAAG,IAAI7E,GAAG,EAAE;AAEjC;;;;;;AAMA,SAAS8E,gBAAgBA,CAACC,KAAK,EAAEf,IAAI;EACnC,IAAMG,MAAM,GAAGU,eAAe,CAAClG,GAAG,CAACqF,IAAI,CAAC;EACxC,IAAIG,MAAM,EAAE;IACV,OAAOrG,OAAO,CAACC,OAAO,CAACoG,MAAM,CAACzE,GAAG,CAACqF,KAAK,CAACV,WAAW,EAAE,CAAC,CAAC;;EAEzD,OAAON,wBAAwB,CAACC,IAAI,CAAC,CAAC3B,IAAI,CAAC,UAAA8B,MAAM;IAC/CU,eAAe,CAAC/C,GAAG,CAACkC,IAAI,EAAEG,MAAM,CAAC;IACjC,OAAOA,MAAM,CAACzE,GAAG,CAACqF,KAAK,CAACV,WAAW,EAAE,CAAC;EACxC,CAAC,CAAC;AACJ;AAEA;;;AAGA,SAASW,0BAA0BA,CAAA;EACjCH,eAAe,CAACI,KAAK,EAAE;AACzB;AAEA;;;;;;AAOAC,OAAO,CAACF,0BAA0B,GAAGA,0BAA0B;AAC/DE,OAAO,CAACvH,KAAK,GAAGA,KAAK;AACrBuH,OAAO,CAAClG,eAAe,GAAGA,eAAe;AACzCkG,OAAO,CAACjG,UAAU,GAAGA,UAAU;AAC/BiG,OAAO,CAACtF,OAAO,GAAGA,OAAO;AACzBsF,OAAO,CAAC1E,YAAY,GAAGA,YAAY;AACnC0E,OAAO,CAACxE,mBAAmB,GAAGA,mBAAmB;AACjDwE,OAAO,CAACJ,gBAAgB,GAAGA,gBAAgB;AAC3CI,OAAO,CAACxD,WAAW,GAAGA,WAAW;AACjCwD,OAAO,CAACvD,cAAc,GAAGA,cAAc;AACvCuD,OAAO,CAAChD,aAAa,GAAGA,aAAa;AACrCgD,OAAO,CAAC5C,QAAQ,GAAGA,QAAQ;AAC3B4C,OAAO,CAACpC,eAAe,GAAGA,eAAe;AACzCoC,OAAO,CAACvB,OAAO,GAAGA,OAAO"},"metadata":{},"sourceType":"script","externalDependencies":[]}