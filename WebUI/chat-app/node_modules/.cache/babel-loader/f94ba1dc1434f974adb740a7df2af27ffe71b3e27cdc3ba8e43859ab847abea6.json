{"ast":null,"code":"'use strict';\n\nvar detectSilence = require('./detectsilence');\n/**\n * This function attempts to workaround WebKit Bug 180748. It does so by\n *\n *   1. Calling `getUserMedia`, and\n *   2. Checking to see if the resulting MediaStream is silent.\n *   3. If so, repeat Step 1; otherwise, return the MediaStream.\n *\n * The function only repeats up to `n` times, and it only waits `timeout`\n * milliseconds when detecting silence. Assuming `getUserMedia` is\n * instantaneous, in the best case, this function returns a Promise that\n * resolves immediately; in the worst case, this function returns a Promise that\n * resolves in `n` * `timeout` milliseconds.\n *\n * @param {Log} log\n * @param {function(MediaStreamConstraints): Promise<MediaStream>} getUserMedia\n * @param {MediaStreamConstraints} constraints\n * @param {number} [n=3]\n * @param {number} [timeout=250]\n * @returns Promise<MediaStream>\n */\nfunction workaround(log, getUserMedia, constraints, n, timeout) {\n  n = typeof n === 'number' ? n : 3;\n  var retry = 0;\n  // NOTE(mroberts): We have to delay require-ing AudioContextFactory, because\n  // it exports a default instance whose constructor calls Object.assign.\n  var AudioContextFactory = require('./audiocontext');\n  var holder = {};\n  var audioContext = AudioContextFactory.getOrCreate(holder);\n  /**\n   * We can't use async/await yet, so I need to factor this out.\n   * @returns {Promise<MediaStream>}\n   */\n  function doWorkaround() {\n    return getUserMedia(constraints).then(function (stream) {\n      var isSilentPromise = constraints.audio ? detectSilence(audioContext, stream, timeout).catch(function (err) {\n        log.warn('Encountered an error while detecting silence', err);\n        return true;\n      }) : Promise.resolve(false);\n      return isSilentPromise.then(function (isSilent) {\n        if (!isSilent) {\n          log.info('Got a non-silent audio MediaStreamTrack; returning it.');\n          return stream;\n        } else if (n <= 0) {\n          log.warn('Got a silent audio MediaStreamTrack. Normally we would try \\\nto get a new one, but we\\'ve run out of retries; returning it anyway.');\n          return stream;\n        }\n        log.warn(\"Got a silent audio MediaStreamTrack. Stopping all MediaStreamTracks and calling getUserMedia again. This is retry #\" + ++retry + \".\");\n        stream.getTracks().forEach(function (track) {\n          return track.stop();\n        });\n        n--;\n        return doWorkaround();\n      });\n    });\n  }\n  return doWorkaround().then(function (stream) {\n    AudioContextFactory.release(holder);\n    return stream;\n  }, function (error) {\n    AudioContextFactory.release(holder);\n    throw error;\n  });\n}\nmodule.exports = workaround;","map":{"version":3,"names":["detectSilence","require","workaround","log","getUserMedia","constraints","n","timeout","retry","AudioContextFactory","holder","audioContext","getOrCreate","doWorkaround","then","stream","isSilentPromise","audio","catch","err","warn","Promise","resolve","isSilent","info","getTracks","forEach","track","stop","release","error","module","exports"],"sources":["/home/denis/RiderProjects/ChatRoulette/WebUI/chat-app/node_modules/twilio-video/lib/webaudio/workaround180748.js"],"sourcesContent":["'use strict';\n\nconst detectSilence = require('./detectsilence');\n\n/**\n * This function attempts to workaround WebKit Bug 180748. It does so by\n *\n *   1. Calling `getUserMedia`, and\n *   2. Checking to see if the resulting MediaStream is silent.\n *   3. If so, repeat Step 1; otherwise, return the MediaStream.\n *\n * The function only repeats up to `n` times, and it only waits `timeout`\n * milliseconds when detecting silence. Assuming `getUserMedia` is\n * instantaneous, in the best case, this function returns a Promise that\n * resolves immediately; in the worst case, this function returns a Promise that\n * resolves in `n` * `timeout` milliseconds.\n *\n * @param {Log} log\n * @param {function(MediaStreamConstraints): Promise<MediaStream>} getUserMedia\n * @param {MediaStreamConstraints} constraints\n * @param {number} [n=3]\n * @param {number} [timeout=250]\n * @returns Promise<MediaStream>\n */\nfunction workaround(log, getUserMedia, constraints, n, timeout) {\n  n = typeof n === 'number' ? n : 3;\n  let retry = 0;\n\n  // NOTE(mroberts): We have to delay require-ing AudioContextFactory, because\n  // it exports a default instance whose constructor calls Object.assign.\n  const AudioContextFactory = require('./audiocontext');\n  const holder = {};\n  const audioContext = AudioContextFactory.getOrCreate(holder);\n\n  /**\n   * We can't use async/await yet, so I need to factor this out.\n   * @returns {Promise<MediaStream>}\n   */\n  function doWorkaround() {\n    return getUserMedia(constraints).then(stream => {\n      const isSilentPromise = constraints.audio\n        ? detectSilence(audioContext, stream, timeout).catch(err => {\n          log.warn('Encountered an error while detecting silence', err);\n          return true;\n        })\n        : Promise.resolve(false);\n      return isSilentPromise.then(isSilent => {\n        if (!isSilent) {\n          log.info('Got a non-silent audio MediaStreamTrack; returning it.');\n          return stream;\n        } else if (n <= 0) {\n          log.warn('Got a silent audio MediaStreamTrack. Normally we would try \\\nto get a new one, but we\\'ve run out of retries; returning it anyway.');\n          return stream;\n        }\n        log.warn(`Got a silent audio MediaStreamTrack. Stopping all \\\nMediaStreamTracks and calling getUserMedia again. This is retry \\\n#${++retry}.`);\n        stream.getTracks().forEach(track => track.stop());\n        n--;\n        return doWorkaround();\n      });\n    });\n  }\n\n  return doWorkaround().then(stream => {\n    AudioContextFactory.release(holder);\n    return stream;\n  }, error => {\n    AudioContextFactory.release(holder);\n    throw error;\n  });\n}\n\nmodule.exports = workaround;\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAMA,aAAa,GAAGC,OAAO,CAAC,iBAAiB,CAAC;AAEhD;;;;;;;;;;;;;;;;;;;;AAoBA,SAASC,UAAUA,CAACC,GAAG,EAAEC,YAAY,EAAEC,WAAW,EAAEC,CAAC,EAAEC,OAAO;EAC5DD,CAAC,GAAG,OAAOA,CAAC,KAAK,QAAQ,GAAGA,CAAC,GAAG,CAAC;EACjC,IAAIE,KAAK,GAAG,CAAC;EAEb;EACA;EACA,IAAMC,mBAAmB,GAAGR,OAAO,CAAC,gBAAgB,CAAC;EACrD,IAAMS,MAAM,GAAG,EAAE;EACjB,IAAMC,YAAY,GAAGF,mBAAmB,CAACG,WAAW,CAACF,MAAM,CAAC;EAE5D;;;;EAIA,SAASG,YAAYA,CAAA;IACnB,OAAOT,YAAY,CAACC,WAAW,CAAC,CAACS,IAAI,CAAC,UAAAC,MAAM;MAC1C,IAAMC,eAAe,GAAGX,WAAW,CAACY,KAAK,GACrCjB,aAAa,CAACW,YAAY,EAAEI,MAAM,EAAER,OAAO,CAAC,CAACW,KAAK,CAAC,UAAAC,GAAG;QACtDhB,GAAG,CAACiB,IAAI,CAAC,8CAA8C,EAAED,GAAG,CAAC;QAC7D,OAAO,IAAI;MACb,CAAC,CAAC,GACAE,OAAO,CAACC,OAAO,CAAC,KAAK,CAAC;MAC1B,OAAON,eAAe,CAACF,IAAI,CAAC,UAAAS,QAAQ;QAClC,IAAI,CAACA,QAAQ,EAAE;UACbpB,GAAG,CAACqB,IAAI,CAAC,wDAAwD,CAAC;UAClE,OAAOT,MAAM;SACd,MAAM,IAAIT,CAAC,IAAI,CAAC,EAAE;UACjBH,GAAG,CAACiB,IAAI,CAAC;sEACmD,CAAC;UAC7D,OAAOL,MAAM;;QAEfZ,GAAG,CAACiB,IAAI,CAAC,wHAEd,EAAEZ,KAAK,MAAG,CAAC;QACNO,MAAM,CAACU,SAAS,EAAE,CAACC,OAAO,CAAC,UAAAC,KAAK;UAAI,OAAAA,KAAK,CAACC,IAAI,EAAE;QAAZ,CAAY,CAAC;QACjDtB,CAAC,EAAE;QACH,OAAOO,YAAY,EAAE;MACvB,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EAEA,OAAOA,YAAY,EAAE,CAACC,IAAI,CAAC,UAAAC,MAAM;IAC/BN,mBAAmB,CAACoB,OAAO,CAACnB,MAAM,CAAC;IACnC,OAAOK,MAAM;EACf,CAAC,EAAE,UAAAe,KAAK;IACNrB,mBAAmB,CAACoB,OAAO,CAACnB,MAAM,CAAC;IACnC,MAAMoB,KAAK;EACb,CAAC,CAAC;AACJ;AAEAC,MAAM,CAACC,OAAO,GAAG9B,UAAU"},"metadata":{},"sourceType":"script","externalDependencies":[]}