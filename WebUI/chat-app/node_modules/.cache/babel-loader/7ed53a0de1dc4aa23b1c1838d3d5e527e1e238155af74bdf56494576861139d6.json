{"ast":null,"code":"'use strict';\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar _a = require('../'),\n  difference = _a.difference,\n  flatMap = _a.flatMap;\n/**\n * Create a random {@link SSRC}.\n * @returns {SSRC}\n */\nfunction createSSRC() {\n  var ssrcMax = 0xffffffff;\n  return String(Math.floor(Math.random() * ssrcMax));\n}\n/**\n * @property {string} cName\n * @property {boolean} isSimulcastEnabled\n * @property {Map<RtxSSRC, PrimarySSRC>} rtxPairs\n * @property {Set<PrimarySSRC>} primarySSRCs\n * @property {string} streamId\n * @property {Track.ID} trackId\n */\nvar TrackAttributes = /** @class */function () {\n  /**\n   * Construct a {@link MediaStreamTrack} attribute store.\n   * @param {Track.ID} trackId - The MediaStreamTrack ID\n   * @param {MediaStreamID} streamId - The MediaStream ID\n   * @param {string} cName - The MediaStream cname\n   */\n  function TrackAttributes(trackId, streamId, cName) {\n    Object.defineProperties(this, {\n      cName: {\n        enumerable: true,\n        value: cName\n      },\n      isSimulcastEnabled: {\n        enumerable: true,\n        value: false,\n        writable: true\n      },\n      primarySSRCs: {\n        enumerable: true,\n        value: new Set()\n      },\n      rtxPairs: {\n        enumerable: true,\n        value: new Map()\n      },\n      streamId: {\n        enumerable: true,\n        value: streamId\n      },\n      trackId: {\n        enumerable: true,\n        value: trackId\n      }\n    });\n  }\n  /**\n   * Add {@link SimSSRC}s to the {@link TrackAttributes}.\n   * @returns {void}\n   */\n  TrackAttributes.prototype.addSimulcastSSRCs = function () {\n    if (this.isSimulcastEnabled) {\n      return;\n    }\n    var simulcastSSRCs = [createSSRC(), createSSRC()];\n    simulcastSSRCs.forEach(function (ssrc) {\n      this.primarySSRCs.add(ssrc);\n    }, this);\n    if (this.rtxPairs.size) {\n      simulcastSSRCs.forEach(function (ssrc) {\n        this.rtxPairs.set(createSSRC(), ssrc);\n      }, this);\n    }\n  };\n  /**\n   * Add the given {@link PrimarySSRC} or {@link RtxSSRC} to the {@link TrackAttributes}\n   * and update the \"isSimulcastEnabled\" flag if it is also a {@link SimSSRC}.\n   * @param {SSRC} ssrc - The {@link SSRC} to be added\n   * @param {?PrimarySSRC} primarySSRC - The {@link PrimarySSRC}; if the given\n   *   {@link SSRC} itself is the {@link PrimarySSRC}, then this is set to null\n   * @param {boolean} isSimSSRC - true if the given {@link SSRC} is a\n   *   {@link SimSSRC}; false otherwise\n   * @returns {void}\n   */\n  TrackAttributes.prototype.addSSRC = function (ssrc, primarySSRC, isSimSSRC) {\n    if (primarySSRC) {\n      this.rtxPairs.set(ssrc, primarySSRC);\n    } else {\n      this.primarySSRCs.add(ssrc);\n    }\n    this.isSimulcastEnabled = this.isSimulcastEnabled || isSimSSRC;\n  };\n  /**\n   * Construct the SDP lines for the {@link TrackAttributes}.\n   * @param {boolean} [excludeRtx=false]\n   * @returns {Array<string>} Array of SDP lines\n   */\n  TrackAttributes.prototype.toSdpLines = function (excludeRtx) {\n    var _this = this;\n    var rtxPairs = excludeRtx ? [] : Array.from(this.rtxPairs.entries()).map(function (rtxPair) {\n      return rtxPair.reverse();\n    });\n    var simSSRCs = Array.from(this.primarySSRCs.values());\n    var ssrcs = rtxPairs.length ? flatMap(rtxPairs) : simSSRCs;\n    var attrLines = flatMap(ssrcs, function (ssrc) {\n      return [\"a=ssrc:\" + ssrc + \" cname:\" + _this.cName, \"a=ssrc:\" + ssrc + \" msid:\" + _this.streamId + \" \" + _this.trackId];\n    });\n    var rtxPairLines = rtxPairs.map(function (rtxPair) {\n      return \"a=ssrc-group:FID \" + rtxPair.join(' ');\n    });\n    var simGroupLines = [\"a=ssrc-group:SIM \" + simSSRCs.join(' ')];\n    return rtxPairLines.concat(attrLines).concat(simGroupLines);\n  };\n  return TrackAttributes;\n}();\n/**\n * Get the matches for a given RegEx pattern.\n * @param {string} section - SDP media section\n * @param {string} pattern - RegEx pattern\n * @returns {Array<Array<string>>} - Array of pattern matches\n */\nfunction getMatches(section, pattern) {\n  var matches = section.match(new RegExp(pattern, 'gm')) || [];\n  return matches.map(function (match) {\n    var matches = match.match(new RegExp(pattern)) || [];\n    return matches.slice(1);\n  });\n}\n/**\n * Get the {@link SimSSRC}s that belong to a simulcast group.\n * @param {string} section - SDP media section\n * @returns {Set<SimSSRC>} Set of simulcast {@link SSRC}s\n */\nfunction getSimulcastSSRCs(section) {\n  var simGroupPattern = '^a=ssrc-group:SIM ([0-9]+) ([0-9]+) ([0-9]+)$';\n  return new Set(flatMap(getMatches(section, simGroupPattern)));\n}\n/**\n * Get the value of the given attribute for an SSRC.\n * @param {string} section - SDP media section\n * @param {SSRC} ssrc - {@link SSRC} whose attribute's value is to be determinded\n * @param {string} attribute - {@link SSRC} attribute name\n * @param {string} - {@link SSRC} attribute value\n */\nfunction getSSRCAttribute(section, ssrc, attribute) {\n  var pattern = \"a=ssrc:\" + ssrc + \" \" + attribute + \":(.+)\";\n  return section.match(new RegExp(pattern))[1];\n}\n/**\n * Create a Map of {@link PrimarySSRC}s and their {@link RtxSSRC}s.\n * @param {string} section - SDP media section\n * @returns {Map<RtxSSRC, PrimarySSRC>} - Map of {@link RtxSSRC}s and their\n *   corresponding {@link PrimarySSRC}s\n */\nfunction getSSRCRtxPairs(section) {\n  var rtxPairPattern = '^a=ssrc-group:FID ([0-9]+) ([0-9]+)$';\n  return new Map(getMatches(section, rtxPairPattern).map(function (pair) {\n    return pair.reverse();\n  }));\n}\n/**\n * Create SSRC attribute tuples.\n * @param {string} section\n * @returns {Array<[SSRC, MediaStreamID, Track.ID]>}\n */\nfunction createSSRCAttributeTuples(section) {\n  var _a = __read(flatMap(getMatches(section, '^a=msid:(.+) (.+)$')), 2),\n    streamId = _a[0],\n    trackId = _a[1];\n  var ssrcs = flatMap(getMatches(section, '^a=ssrc:(.+) cname:.+$'));\n  return ssrcs.map(function (ssrc) {\n    return [ssrc, streamId, trackId];\n  });\n}\n/**\n * Create a Map of MediaStreamTrack IDs and their {@link TrackAttributes}.\n * @param {string} section - SDP media section\n * @returns {Map<Track.ID, TrackAttributes>}\n */\nfunction createTrackIdsToAttributes(section) {\n  var simSSRCs = getSimulcastSSRCs(section);\n  var rtxPairs = getSSRCRtxPairs(section);\n  var ssrcAttrTuples = createSSRCAttributeTuples(section);\n  return ssrcAttrTuples.reduce(function (trackIdsToSSRCs, tuple) {\n    var ssrc = tuple[0];\n    var streamId = tuple[1];\n    var trackId = tuple[2];\n    var trackAttributes = trackIdsToSSRCs.get(trackId) || new TrackAttributes(trackId, streamId, getSSRCAttribute(section, ssrc, 'cname'));\n    var primarySSRC = rtxPairs.get(ssrc) || null;\n    trackAttributes.addSSRC(ssrc, primarySSRC, simSSRCs.has(ssrc));\n    return trackIdsToSSRCs.set(trackId, trackAttributes);\n  }, new Map());\n}\n/**\n * Apply simulcast settings to the given SDP media section.\n * @param {string} section - SDP media section\n * @param {Map<Track.ID, TrackAttributes>} trackIdsToAttributes - Existing\n *   map which will be updated for new MediaStreamTrack IDs\n * @returns {string} - The transformed SDP media section\n */\nfunction setSimulcastInMediaSection(section, trackIdsToAttributes) {\n  var newTrackIdsToAttributes = createTrackIdsToAttributes(section);\n  var newTrackIds = Array.from(newTrackIdsToAttributes.keys());\n  var trackIds = Array.from(trackIdsToAttributes.keys());\n  var trackIdsToAdd = difference(newTrackIds, trackIds);\n  var trackIdsToIgnore = difference(trackIds, newTrackIds);\n  // Update \"trackIdsToAttributes\" with TrackAttributes for new\n  // MediaStreamTrack IDs.\n  var trackAttributesToAdd = flatMap(trackIdsToAdd, function (trackId) {\n    return newTrackIdsToAttributes.get(trackId);\n  });\n  trackAttributesToAdd.forEach(function (trackAttributes) {\n    trackAttributes.addSimulcastSSRCs();\n    trackIdsToAttributes.set(trackAttributes.trackId, trackAttributes);\n  });\n  // Get the SDP lines of the relevant MediaStreamTrack IDs from\n  // \"trackIdsToAttributes\".\n  trackIds = Array.from(trackIdsToAttributes.keys());\n  var relevantTrackIds = difference(trackIds, trackIdsToIgnore);\n  var relevantTrackAttributes = flatMap(relevantTrackIds, function (trackId) {\n    return trackIdsToAttributes.get(trackId);\n  });\n  var excludeRtx = !section.match(/a=rtpmap:[0-9]+ rtx/);\n  var relevantSdpLines = flatMap(relevantTrackAttributes, function (trackAttributes) {\n    return trackAttributes.toSdpLines(excludeRtx);\n  });\n  // Add the simulcast SSRC SDP lines to the media section. The Set ensures\n  // that the duplicates of the SSRC SDP lines that are in both \"section\" and\n  // \"relevantSdpLines\" are removed.\n  var sectionLines = flatMap(new Set(section.split('\\r\\n').concat(relevantSdpLines)));\n  var xGoogleFlagConference = 'a=x-google-flag:conference';\n  if (!section.match(xGoogleFlagConference)) {\n    sectionLines.push(xGoogleFlagConference);\n  }\n  return sectionLines.join('\\r\\n');\n}\n/**\n * String representing a MediaStream ID.\n * @typedef {string} MediaStreamID\n */\n/**\n * String representing the SSRC of a MediaStreamTrack.\n * @typedef {string} SSRC\n */\n/**\n * Primary SSRC.\n * @typedef {SSRC} PrimarySSRC\n */\n/**\n * Retransmission SSRC.\n * @typedef {SSRC} RtxSSRC\n */\n/**\n * Simulcast SSRC.\n * @typedef {SSRC} SimSSRC\n */\nmodule.exports = setSimulcastInMediaSection;","map":{"version":3,"names":["_a","require","difference","flatMap","createSSRC","ssrcMax","String","Math","floor","random","TrackAttributes","trackId","streamId","cName","Object","defineProperties","enumerable","value","isSimulcastEnabled","writable","primarySSRCs","Set","rtxPairs","Map","prototype","addSimulcastSSRCs","simulcastSSRCs","forEach","ssrc","add","size","set","addSSRC","primarySSRC","isSimSSRC","toSdpLines","excludeRtx","_this","Array","from","entries","map","rtxPair","reverse","simSSRCs","values","ssrcs","length","attrLines","rtxPairLines","join","simGroupLines","concat","getMatches","section","pattern","matches","match","RegExp","slice","getSimulcastSSRCs","simGroupPattern","getSSRCAttribute","attribute","getSSRCRtxPairs","rtxPairPattern","pair","createSSRCAttributeTuples","__read","createTrackIdsToAttributes","ssrcAttrTuples","reduce","trackIdsToSSRCs","tuple","trackAttributes","get","has","setSimulcastInMediaSection","trackIdsToAttributes","newTrackIdsToAttributes","newTrackIds","keys","trackIds","trackIdsToAdd","trackIdsToIgnore","trackAttributesToAdd","relevantTrackIds","relevantTrackAttributes","relevantSdpLines","sectionLines","split","xGoogleFlagConference","push","module","exports"],"sources":["/home/denis/RiderProjects/ChatRoulette/WebUI/chat-app/node_modules/twilio-video/lib/util/sdp/simulcast.js"],"sourcesContent":["'use strict';\n\nconst { difference, flatMap } = require('../');\n\n/**\n * Create a random {@link SSRC}.\n * @returns {SSRC}\n */\nfunction createSSRC() {\n  const ssrcMax = 0xffffffff;\n  return String(Math.floor(Math.random() * ssrcMax));\n}\n\n/**\n * @property {string} cName\n * @property {boolean} isSimulcastEnabled\n * @property {Map<RtxSSRC, PrimarySSRC>} rtxPairs\n * @property {Set<PrimarySSRC>} primarySSRCs\n * @property {string} streamId\n * @property {Track.ID} trackId\n */\nclass TrackAttributes {\n  /**\n   * Construct a {@link MediaStreamTrack} attribute store.\n   * @param {Track.ID} trackId - The MediaStreamTrack ID\n   * @param {MediaStreamID} streamId - The MediaStream ID\n   * @param {string} cName - The MediaStream cname\n   */\n  constructor(trackId, streamId, cName) {\n    Object.defineProperties(this, {\n      cName: {\n        enumerable: true,\n        value: cName\n      },\n      isSimulcastEnabled: {\n        enumerable: true,\n        value: false,\n        writable: true\n      },\n      primarySSRCs: {\n        enumerable: true,\n        value: new Set()\n      },\n      rtxPairs: {\n        enumerable: true,\n        value: new Map()\n      },\n      streamId: {\n        enumerable: true,\n        value: streamId\n      },\n      trackId: {\n        enumerable: true,\n        value: trackId\n      }\n    });\n  }\n\n  /**\n   * Add {@link SimSSRC}s to the {@link TrackAttributes}.\n   * @returns {void}\n   */\n  addSimulcastSSRCs() {\n    if (this.isSimulcastEnabled) {\n      return;\n    }\n    const simulcastSSRCs = [createSSRC(), createSSRC()];\n    simulcastSSRCs.forEach(function(ssrc) {\n      this.primarySSRCs.add(ssrc);\n    }, this);\n\n    if (this.rtxPairs.size) {\n      simulcastSSRCs.forEach(function(ssrc) {\n        this.rtxPairs.set(createSSRC(), ssrc);\n      }, this);\n    }\n  }\n\n  /**\n   * Add the given {@link PrimarySSRC} or {@link RtxSSRC} to the {@link TrackAttributes}\n   * and update the \"isSimulcastEnabled\" flag if it is also a {@link SimSSRC}.\n   * @param {SSRC} ssrc - The {@link SSRC} to be added\n   * @param {?PrimarySSRC} primarySSRC - The {@link PrimarySSRC}; if the given\n   *   {@link SSRC} itself is the {@link PrimarySSRC}, then this is set to null\n   * @param {boolean} isSimSSRC - true if the given {@link SSRC} is a\n   *   {@link SimSSRC}; false otherwise\n   * @returns {void}\n   */\n  addSSRC(ssrc, primarySSRC, isSimSSRC) {\n    if (primarySSRC) {\n      this.rtxPairs.set(ssrc, primarySSRC);\n    } else {\n      this.primarySSRCs.add(ssrc);\n    }\n    this.isSimulcastEnabled = this.isSimulcastEnabled || isSimSSRC;\n  }\n\n  /**\n   * Construct the SDP lines for the {@link TrackAttributes}.\n   * @param {boolean} [excludeRtx=false]\n   * @returns {Array<string>} Array of SDP lines\n   */\n  toSdpLines(excludeRtx) {\n    const rtxPairs = excludeRtx\n      ? []\n      : Array.from(this.rtxPairs.entries()).map(rtxPair => rtxPair.reverse());\n\n    const simSSRCs = Array.from(this.primarySSRCs.values());\n    const ssrcs = rtxPairs.length ? flatMap(rtxPairs) : simSSRCs;\n\n    const attrLines = flatMap(ssrcs, ssrc => [\n      `a=ssrc:${ssrc} cname:${this.cName}`,\n      `a=ssrc:${ssrc} msid:${this.streamId} ${this.trackId}`\n    ]);\n    const rtxPairLines = rtxPairs.map(rtxPair => `a=ssrc-group:FID ${rtxPair.join(' ')}`);\n    const simGroupLines = [\n      `a=ssrc-group:SIM ${simSSRCs.join(' ')}`\n    ];\n\n    return rtxPairLines.concat(attrLines).concat(simGroupLines);\n  }\n}\n\n/**\n * Get the matches for a given RegEx pattern.\n * @param {string} section - SDP media section\n * @param {string} pattern - RegEx pattern\n * @returns {Array<Array<string>>} - Array of pattern matches\n */\nfunction getMatches(section, pattern) {\n  const matches = section.match(new RegExp(pattern, 'gm')) || [];\n  return matches.map(match => {\n    const matches = match.match(new RegExp(pattern)) || [];\n    return matches.slice(1);\n  });\n}\n\n/**\n * Get the {@link SimSSRC}s that belong to a simulcast group.\n * @param {string} section - SDP media section\n * @returns {Set<SimSSRC>} Set of simulcast {@link SSRC}s\n */\nfunction getSimulcastSSRCs(section) {\n  const simGroupPattern = '^a=ssrc-group:SIM ([0-9]+) ([0-9]+) ([0-9]+)$';\n  return new Set(flatMap(getMatches(section, simGroupPattern)));\n}\n\n/**\n * Get the value of the given attribute for an SSRC.\n * @param {string} section - SDP media section\n * @param {SSRC} ssrc - {@link SSRC} whose attribute's value is to be determinded\n * @param {string} attribute - {@link SSRC} attribute name\n * @param {string} - {@link SSRC} attribute value\n */\nfunction getSSRCAttribute(section, ssrc, attribute) {\n  const pattern = `a=ssrc:${ssrc} ${attribute}:(.+)`;\n  return section.match(new RegExp(pattern))[1];\n}\n\n/**\n * Create a Map of {@link PrimarySSRC}s and their {@link RtxSSRC}s.\n * @param {string} section - SDP media section\n * @returns {Map<RtxSSRC, PrimarySSRC>} - Map of {@link RtxSSRC}s and their\n *   corresponding {@link PrimarySSRC}s\n */\nfunction getSSRCRtxPairs(section) {\n  const rtxPairPattern = '^a=ssrc-group:FID ([0-9]+) ([0-9]+)$';\n  return new Map(getMatches(section, rtxPairPattern).map(pair => pair.reverse()));\n}\n\n/**\n * Create SSRC attribute tuples.\n * @param {string} section\n * @returns {Array<[SSRC, MediaStreamID, Track.ID]>}\n */\nfunction createSSRCAttributeTuples(section) {\n  const [streamId, trackId] = flatMap(getMatches(section, '^a=msid:(.+) (.+)$'));\n  const ssrcs = flatMap(getMatches(section, '^a=ssrc:(.+) cname:.+$'));\n  return ssrcs.map(ssrc => [ssrc, streamId, trackId]);\n}\n\n/**\n * Create a Map of MediaStreamTrack IDs and their {@link TrackAttributes}.\n * @param {string} section - SDP media section\n * @returns {Map<Track.ID, TrackAttributes>}\n */\nfunction createTrackIdsToAttributes(section) {\n  const simSSRCs = getSimulcastSSRCs(section);\n  const rtxPairs = getSSRCRtxPairs(section);\n  const ssrcAttrTuples = createSSRCAttributeTuples(section);\n\n  return ssrcAttrTuples.reduce((trackIdsToSSRCs, tuple) => {\n    const ssrc = tuple[0];\n    const streamId = tuple[1];\n    const trackId = tuple[2];\n\n    const trackAttributes = trackIdsToSSRCs.get(trackId) || new TrackAttributes(\n      trackId,\n      streamId,\n      getSSRCAttribute(section, ssrc, 'cname'));\n\n    const primarySSRC = rtxPairs.get(ssrc) || null;\n    trackAttributes.addSSRC(ssrc, primarySSRC, simSSRCs.has(ssrc));\n    return trackIdsToSSRCs.set(trackId, trackAttributes);\n  }, new Map());\n}\n\n/**\n * Apply simulcast settings to the given SDP media section.\n * @param {string} section - SDP media section\n * @param {Map<Track.ID, TrackAttributes>} trackIdsToAttributes - Existing\n *   map which will be updated for new MediaStreamTrack IDs\n * @returns {string} - The transformed SDP media section\n */\nfunction setSimulcastInMediaSection(section, trackIdsToAttributes) {\n  const newTrackIdsToAttributes = createTrackIdsToAttributes(section);\n  const newTrackIds = Array.from(newTrackIdsToAttributes.keys());\n  let trackIds = Array.from(trackIdsToAttributes.keys());\n  const trackIdsToAdd = difference(newTrackIds, trackIds);\n  const trackIdsToIgnore = difference(trackIds, newTrackIds);\n\n  // Update \"trackIdsToAttributes\" with TrackAttributes for new\n  // MediaStreamTrack IDs.\n  const trackAttributesToAdd = flatMap(trackIdsToAdd, trackId => newTrackIdsToAttributes.get(trackId));\n  trackAttributesToAdd.forEach(trackAttributes => {\n    trackAttributes.addSimulcastSSRCs();\n    trackIdsToAttributes.set(trackAttributes.trackId, trackAttributes);\n  });\n\n  // Get the SDP lines of the relevant MediaStreamTrack IDs from\n  // \"trackIdsToAttributes\".\n  trackIds = Array.from(trackIdsToAttributes.keys());\n  const relevantTrackIds = difference(trackIds, trackIdsToIgnore);\n  const relevantTrackAttributes = flatMap(relevantTrackIds, trackId => trackIdsToAttributes.get(trackId));\n  const excludeRtx = !section.match(/a=rtpmap:[0-9]+ rtx/);\n  const relevantSdpLines = flatMap(relevantTrackAttributes, trackAttributes => trackAttributes.toSdpLines(excludeRtx));\n\n  // Add the simulcast SSRC SDP lines to the media section. The Set ensures\n  // that the duplicates of the SSRC SDP lines that are in both \"section\" and\n  // \"relevantSdpLines\" are removed.\n  const sectionLines = flatMap(new Set(section.split('\\r\\n').concat(relevantSdpLines)));\n\n  const xGoogleFlagConference = 'a=x-google-flag:conference';\n  if (!section.match(xGoogleFlagConference)) {\n    sectionLines.push(xGoogleFlagConference);\n  }\n\n  return sectionLines.join('\\r\\n');\n}\n\n/**\n * String representing a MediaStream ID.\n * @typedef {string} MediaStreamID\n */\n\n/**\n * String representing the SSRC of a MediaStreamTrack.\n * @typedef {string} SSRC\n */\n\n/**\n * Primary SSRC.\n * @typedef {SSRC} PrimarySSRC\n */\n\n/**\n * Retransmission SSRC.\n * @typedef {SSRC} RtxSSRC\n */\n\n/**\n * Simulcast SSRC.\n * @typedef {SSRC} SimSSRC\n */\n\nmodule.exports = setSimulcastInMediaSection;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}