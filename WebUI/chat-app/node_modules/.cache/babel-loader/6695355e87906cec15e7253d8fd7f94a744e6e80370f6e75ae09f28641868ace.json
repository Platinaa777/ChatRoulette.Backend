{"ast":null,"code":"/* globals chrome, navigator */\n'use strict';\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\n/**\n * Check whether the current browser is an Android device.\n * @returns {boolean}\n */\nfunction isAndroid() {\n  return /Android/.test(navigator.userAgent);\n}\n/**\n * Detects whether or not a device is an Apple touch screen device.\n * @returns {boolean}\n */\nfunction hasTouchScreen() {\n  return !!(navigator && navigator.maxTouchPoints && navigator.maxTouchPoints > 2);\n}\n/**\n * Detects whether or not a device is an iPad.\n * @returns {boolean}\n */\nfunction isIpad() {\n  return hasTouchScreen() && window.screen.width >= 744 && (/Macintosh/i.test(navigator.userAgent) || /iPad/.test(navigator.userAgent) || /iPad/.test(navigator.platform));\n}\n/**\n * Detects whether or not a device is an iPhone.\n * @returns {boolean}\n */\nfunction isIphone() {\n  return hasTouchScreen() && window.screen.width <= 476 && (/Macintosh/i.test(navigator.userAgent) || /iPhone/.test(navigator.userAgent) || /iPhone/.test(navigator.platform));\n}\n/**\n * Check whether the current device is an iOS device.\n * @returns {boolean}\n */\nfunction isIOS() {\n  return isIpad() || isIphone();\n}\n/**\n * Check whether the current browser is a mobile browser\n * @returns {boolean}\n */\nfunction isMobile() {\n  return /Mobi/.test(navigator.userAgent);\n}\n/**\n * Check whether the current browser is non-Chromium Edge.\n * @param {string} browser\n * @returns {boolean}\n */\nfunction isNonChromiumEdge(browser) {\n  return browser === 'chrome' && /Edge/.test(navigator.userAgent) && (typeof chrome === 'undefined' || typeof chrome.runtime === 'undefined');\n}\n/**\n * Get the name of the rebranded Chromium browser, if any. Re-branded Chrome's user\n * agent has the following format:\n * <source>/<version> (<os>) <engine>/<version> (<engine_name>) Chrome/<version> [Mobile] Safari/<version>\n * @param browser\n * @returns {?string} Name of the rebranded Chrome browser, or null if the browser\n *   is either not Chrome or vanilla Chrome.\n */\nfunction rebrandedChromeBrowser(browser) {\n  // If the browser is not Chrome based, then it is not a rebranded Chrome browser.\n  if (browser !== 'chrome') {\n    return null;\n  }\n  // Latest desktop Brave browser has a \"brave\" property in navigator.\n  if ('brave' in navigator) {\n    return 'brave';\n  }\n  // Remove the \"(.+)\" entries from the user agent thereby retaining only the\n  // <name>[/<version>] entries.\n  var parenthesizedSubstrings = getParenthesizedSubstrings(navigator.userAgent);\n  var nameAndVersions = parenthesizedSubstrings.reduce(function (userAgent, substring) {\n    return userAgent.replace(substring, '');\n  }, navigator.userAgent);\n  // Extract the potential browser <name>s by ignoring the first two names, which\n  // point to <source> and <engine>.\n  var matches = nameAndVersions.match(/[^\\s]+/g) || [];\n  var _a = __read(matches.map(function (nameAndVersion) {\n      return nameAndVersion.split('/')[0].toLowerCase();\n    })),\n    browserNames = _a.slice(2);\n  // Extract the <name> that is not expected to be present in the vanilla Chrome\n  // browser, which indicates the rebranded name (ex: \"edg[e]\", \"electron\"). If null,\n  // then this is a vanilla Chrome browser.\n  return browserNames.find(function (name) {\n    return !['chrome', 'mobile', 'safari'].includes(name);\n  }) || null;\n}\n/**\n * Get the name of the mobile webkit based browser, if any.\n * @param browser\n * @returns {?string} Name of the mobile webkit based browser, or null if the browser\n *   is either not webkit based or mobile safari.\n */\nfunction mobileWebKitBrowser(browser) {\n  if (browser !== 'safari') {\n    return null;\n  }\n  if ('brave' in navigator) {\n    return 'brave';\n  }\n  return ['edge', 'edg'].find(function (name) {\n    return navigator.userAgent.toLowerCase().includes(name);\n  }) || null;\n}\n/**\n * Get the top level parenthesized substrings within a given string. Unmatched\n * parentheses are ignored.\n * Ex: \"abc) (def) gh(ij) (kl (mn)o) (pqr\" => [\"(def)\", \"(ij)\", \"(kl (mn)o)\"]\n * @param {string} string\n * @returns {string[]}\n */\nfunction getParenthesizedSubstrings(string) {\n  var openParenthesisPositions = [];\n  var substrings = [];\n  for (var i = 0; i < string.length; i++) {\n    if (string[i] === '(') {\n      openParenthesisPositions.push(i);\n    } else if (string[i] === ')' && openParenthesisPositions.length > 0) {\n      var openParenthesisPosition = openParenthesisPositions.pop();\n      if (openParenthesisPositions.length === 0) {\n        substrings.push(string.substring(openParenthesisPosition, i + 1));\n      }\n    }\n  }\n  return substrings;\n}\nmodule.exports = {\n  isAndroid: isAndroid,\n  isIOS: isIOS,\n  isIpad: isIpad,\n  isIphone: isIphone,\n  isMobile: isMobile,\n  isNonChromiumEdge: isNonChromiumEdge,\n  mobileWebKitBrowser: mobileWebKitBrowser,\n  rebrandedChromeBrowser: rebrandedChromeBrowser\n};","map":{"version":3,"names":["isAndroid","test","navigator","userAgent","hasTouchScreen","maxTouchPoints","isIpad","window","screen","width","platform","isIphone","isIOS","isMobile","isNonChromiumEdge","browser","chrome","runtime","rebrandedChromeBrowser","parenthesizedSubstrings","getParenthesizedSubstrings","nameAndVersions","reduce","substring","replace","matches","match","_a","__read","map","nameAndVersion","split","toLowerCase","browserNames","slice","find","name","includes","mobileWebKitBrowser","string","openParenthesisPositions","substrings","i","length","push","openParenthesisPosition","pop","module","exports"],"sources":["/home/denis/RiderProjects/ChatRoulette/WebUI/chat-app/node_modules/twilio-video/lib/util/browserdetection.js"],"sourcesContent":["/* globals chrome, navigator */\n'use strict';\n\n/**\n * Check whether the current browser is an Android device.\n * @returns {boolean}\n */\nfunction isAndroid() {\n  return /Android/.test(navigator.userAgent);\n}\n\n/**\n * Detects whether or not a device is an Apple touch screen device.\n * @returns {boolean}\n */\nfunction hasTouchScreen() {\n  return !!(navigator && navigator.maxTouchPoints && navigator.maxTouchPoints > 2);\n}\n\n/**\n * Detects whether or not a device is an iPad.\n * @returns {boolean}\n */\nfunction isIpad() {\n  return hasTouchScreen() && window.screen.width >= 744 && (/Macintosh/i.test(navigator.userAgent)\n    || /iPad/.test(navigator.userAgent)\n    || /iPad/.test(navigator.platform));\n}\n\n/**\n * Detects whether or not a device is an iPhone.\n * @returns {boolean}\n */\nfunction isIphone() {\n  return hasTouchScreen() && window.screen.width <= 476 && (/Macintosh/i.test(navigator.userAgent)\n    || /iPhone/.test(navigator.userAgent)\n    || /iPhone/.test(navigator.platform));\n}\n\n/**\n * Check whether the current device is an iOS device.\n * @returns {boolean}\n */\nfunction isIOS() {\n  return isIpad() || isIphone();\n}\n\n/**\n * Check whether the current browser is a mobile browser\n * @returns {boolean}\n */\nfunction isMobile() {\n  return /Mobi/.test(navigator.userAgent);\n}\n\n/**\n * Check whether the current browser is non-Chromium Edge.\n * @param {string} browser\n * @returns {boolean}\n */\nfunction isNonChromiumEdge(browser) {\n  return browser === 'chrome' && /Edge/.test(navigator.userAgent) && (\n    typeof chrome === 'undefined' || typeof chrome.runtime === 'undefined'\n  );\n}\n\n/**\n * Get the name of the rebranded Chromium browser, if any. Re-branded Chrome's user\n * agent has the following format:\n * <source>/<version> (<os>) <engine>/<version> (<engine_name>) Chrome/<version> [Mobile] Safari/<version>\n * @param browser\n * @returns {?string} Name of the rebranded Chrome browser, or null if the browser\n *   is either not Chrome or vanilla Chrome.\n */\nfunction rebrandedChromeBrowser(browser) {\n  // If the browser is not Chrome based, then it is not a rebranded Chrome browser.\n  if (browser !== 'chrome') {\n    return null;\n  }\n\n  // Latest desktop Brave browser has a \"brave\" property in navigator.\n  if ('brave' in navigator) {\n    return 'brave';\n  }\n\n  // Remove the \"(.+)\" entries from the user agent thereby retaining only the\n  // <name>[/<version>] entries.\n  const parenthesizedSubstrings = getParenthesizedSubstrings(navigator.userAgent);\n  const nameAndVersions = parenthesizedSubstrings.reduce(\n    (userAgent, substring) => userAgent.replace(substring, ''),\n    navigator.userAgent\n  );\n\n  // Extract the potential browser <name>s by ignoring the first two names, which\n  // point to <source> and <engine>.\n  const matches = nameAndVersions.match(/[^\\s]+/g) || [];\n  const [/* source */, /* engine */, ...browserNames] = matches.map(nameAndVersion => {\n    return nameAndVersion.split('/')[0].toLowerCase();\n  });\n\n  // Extract the <name> that is not expected to be present in the vanilla Chrome\n  // browser, which indicates the rebranded name (ex: \"edg[e]\", \"electron\"). If null,\n  // then this is a vanilla Chrome browser.\n  return browserNames.find(name => {\n    return !['chrome', 'mobile', 'safari'].includes(name);\n  }) || null;\n}\n\n/**\n * Get the name of the mobile webkit based browser, if any.\n * @param browser\n * @returns {?string} Name of the mobile webkit based browser, or null if the browser\n *   is either not webkit based or mobile safari.\n */\nfunction mobileWebKitBrowser(browser) {\n  if (browser !== 'safari') {\n    return null;\n  }\n  if ('brave' in navigator) {\n    return 'brave';\n  }\n\n  return ['edge', 'edg'].find(name => {\n    return navigator.userAgent.toLowerCase().includes(name);\n  }) || null;\n}\n\n/**\n * Get the top level parenthesized substrings within a given string. Unmatched\n * parentheses are ignored.\n * Ex: \"abc) (def) gh(ij) (kl (mn)o) (pqr\" => [\"(def)\", \"(ij)\", \"(kl (mn)o)\"]\n * @param {string} string\n * @returns {string[]}\n */\nfunction getParenthesizedSubstrings(string) {\n  const openParenthesisPositions = [];\n  const substrings = [];\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === '(') {\n      openParenthesisPositions.push(i);\n    } else if (string[i] === ')' && openParenthesisPositions.length > 0) {\n      const openParenthesisPosition = openParenthesisPositions.pop();\n      if (openParenthesisPositions.length === 0) {\n        substrings.push(string.substring(openParenthesisPosition, i + 1));\n      }\n    }\n  }\n  return substrings;\n}\n\nmodule.exports = {\n  isAndroid,\n  isIOS,\n  isIpad,\n  isIphone,\n  isMobile,\n  isNonChromiumEdge,\n  mobileWebKitBrowser,\n  rebrandedChromeBrowser\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}