{"ast":null,"code":"/* eslint new-cap:0 */\n'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar getUserMedia = require('../../webrtc').getUserMedia;\nvar isIOS = require('../../util/browserdetection').isIOS;\nvar _a = require('../../util'),\n  capitalize = _a.capitalize,\n  defer = _a.defer,\n  waitForSometime = _a.waitForSometime,\n  waitForEvent = _a.waitForEvent;\nvar ILLEGAL_INVOKE = require('../../util/constants').typeErrors.ILLEGAL_INVOKE;\nvar detectSilentAudio = require('../../util/detectsilentaudio');\nvar detectSilentVideo = require('../../util/detectsilentvideo');\nvar documentVisibilityMonitor = require('../../util/documentvisibilitymonitor.js');\nvar localMediaRestartDeferreds = require('../../util/localmediarestartdeferreds');\nvar gUMSilentTrackWorkaround = require('../../webaudio/workaround180748');\nvar MediaTrackSender = require('./sender');\nfunction mixinLocalMediaTrack(AudioOrVideoTrack) {\n  /**\n   * A {@link LocalMediaTrack} represents audio or video that your\n   * {@link LocalParticipant} is sending to a {@link Room}. As such, it can be\n   * enabled and disabled with {@link LocalMediaTrack#enable} and\n   * {@link LocalMediaTrack#disable} or stopped completely with\n   * {@link LocalMediaTrack#stop}.\n   * @emits LocalMediaTrack#muted\n   * @emits LocalMediaTrack#stopped\n   * @emits LocalMediaTrack#unmuted\n   */\n  return (/** @class */function (_super) {\n      __extends(LocalMediaTrack, _super);\n      /**\n       * Construct a {@link LocalMediaTrack} from a MediaStreamTrack.\n       * @param {MediaStreamTrack} mediaStreamTrack - The underlying MediaStreamTrack\n       * @param {LocalTrackOptions} [options] - {@link LocalTrack} options\n       */\n      function LocalMediaTrack(mediaStreamTrack, options) {\n        var _this = this;\n        var workaroundWebKitBug1208516 = isIOS() && typeof document === 'object' && typeof document.addEventListener === 'function' && typeof document.visibilityState === 'string';\n        options = Object.assign({\n          getUserMedia: getUserMedia,\n          isCreatedByCreateLocalTracks: false,\n          workaroundWebKitBug1208516: workaroundWebKitBug1208516,\n          gUMSilentTrackWorkaround: gUMSilentTrackWorkaround\n        }, options);\n        var mediaTrackSender = new MediaTrackSender(mediaStreamTrack);\n        var kind = mediaTrackSender.kind;\n        _this = _super.call(this, mediaTrackSender, options) || this;\n        Object.defineProperties(_this, {\n          _constraints: {\n            value: typeof options[kind] === 'object' ? options[kind] : {},\n            writable: true\n          },\n          _getUserMedia: {\n            value: options.getUserMedia\n          },\n          _gUMSilentTrackWorkaround: {\n            value: options.gUMSilentTrackWorkaround\n          },\n          _eventsToReemitters: {\n            value: new Map([['muted', function () {\n              return _this.emit('muted', _this);\n            }], ['unmuted', function () {\n              return _this.emit('unmuted', _this);\n            }]])\n          },\n          _workaroundWebKitBug1208516: {\n            value: options.workaroundWebKitBug1208516\n          },\n          _workaroundWebKitBug1208516Cleanup: {\n            value: null,\n            writable: true\n          },\n          _didCallEnd: {\n            value: false,\n            writable: true\n          },\n          _isCreatedByCreateLocalTracks: {\n            value: options.isCreatedByCreateLocalTracks\n          },\n          _noiseCancellation: {\n            value: options.noiseCancellation || null\n          },\n          _trackSender: {\n            value: mediaTrackSender\n          },\n          id: {\n            enumerable: true,\n            value: mediaTrackSender.id\n          },\n          isEnabled: {\n            enumerable: true,\n            get: function () {\n              return mediaTrackSender.enabled;\n            }\n          },\n          isMuted: {\n            enumerable: true,\n            get: function () {\n              return mediaTrackSender.muted;\n            }\n          },\n          isStopped: {\n            enumerable: true,\n            get: function () {\n              return mediaTrackSender.readyState === 'ended';\n            }\n          }\n        });\n        // NOTE(mpatwardhan): As a workaround for WebKit bug: https://bugs.webkit.org/show_bug.cgi?id=208516,\n        // upon foregrounding, re-acquire new MediaStreamTrack if the existing one is ended or muted.\n        if (_this._workaroundWebKitBug1208516) {\n          _this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(_this);\n        }\n        _this._reemitTrackSenderEvents();\n        return _this;\n      }\n      /**\n       * @private\n       */\n      LocalMediaTrack.prototype._end = function () {\n        var _this = this;\n        if (this._didCallEnd) {\n          return;\n        }\n        _super.prototype._end.call(this);\n        this._didCallEnd = true;\n        this._eventsToReemitters.forEach(function (reemitter, event) {\n          return _this._trackSender.removeListener(event, reemitter);\n        });\n        this.emit('stopped', this);\n      };\n      /**\n       * @private\n       */\n      LocalMediaTrack.prototype._initialize = function () {\n        if (this._didCallEnd) {\n          this._didCallEnd = false;\n        }\n        if (this._eventsToReemitters) {\n          this._reemitTrackSenderEvents();\n        }\n        _super.prototype._initialize.call(this);\n      };\n      /**\n       * @private\n       */\n      LocalMediaTrack.prototype._reacquireTrack = function (constraints) {\n        var _a;\n        var _b = this,\n          getUserMedia = _b._getUserMedia,\n          gUMSilentTrackWorkaround = _b._gUMSilentTrackWorkaround,\n          log = _b._log,\n          kind = _b.mediaStreamTrack.kind;\n        log.info('Re-acquiring the MediaStreamTrack');\n        log.debug('Constraints:', constraints);\n        var gUMConstraints = Object.assign({\n          audio: false,\n          video: false\n        }, (_a = {}, _a[kind] = constraints, _a));\n        var gUMPromise = this._workaroundWebKitBug1208516Cleanup ? gUMSilentTrackWorkaround(log, getUserMedia, gUMConstraints) : getUserMedia(gUMConstraints);\n        return gUMPromise.then(function (mediaStream) {\n          return mediaStream.getTracks()[0];\n        });\n      };\n      /**\n       * @private\n       */\n      LocalMediaTrack.prototype._reemitTrackSenderEvents = function () {\n        var _this = this;\n        this._eventsToReemitters.forEach(function (reemitter, event) {\n          return _this._trackSender.on(event, reemitter);\n        });\n        this._trackSender.dequeue('muted');\n        this._trackSender.dequeue('unmuted');\n      };\n      /**\n       * @private\n       */\n      LocalMediaTrack.prototype._restart = function (constraints) {\n        var _this = this;\n        var log = this._log;\n        constraints = constraints || this._constraints;\n        // NOTE(mmalavalli): If we try and restart a silent MediaStreamTrack\n        // without stopping it first, then a NotReadableError is raised in case of\n        // video, or the restarted audio will still be silent. Hence, we stop the\n        // MediaStreamTrack here.\n        this._stop();\n        return this._reacquireTrack(constraints).catch(function (error) {\n          log.error('Failed to re-acquire the MediaStreamTrack:', {\n            error: error,\n            constraints: constraints\n          });\n          throw error;\n        }).then(function (newMediaStreamTrack) {\n          log.info('Re-acquired the MediaStreamTrack');\n          log.debug('MediaStreamTrack:', newMediaStreamTrack);\n          _this._constraints = Object.assign({}, constraints);\n          return _this._setMediaStreamTrack(newMediaStreamTrack);\n        });\n      };\n      /**\n       * @private\n       */\n      LocalMediaTrack.prototype._setMediaStreamTrack = function (mediaStreamTrack) {\n        var _this = this;\n        // NOTE(mpatwardhan): Preserve the value of the \"enabled\" flag.\n        mediaStreamTrack.enabled = this.mediaStreamTrack.enabled;\n        // NOTE(mmalavalli): Stop the current MediaStreamTrack. If not already\n        // stopped, this should fire a \"stopped\" event.\n        this._stop();\n        // NOTE(csantos): If there's an unprocessedTrack, this means RTCRtpSender has\n        // the processedTrack already set, we don't want to replace that.\n        return (this._unprocessedTrack ? Promise.resolve().then(function () {\n          _this._unprocessedTrack = mediaStreamTrack;\n        }) : this._trackSender.setMediaStreamTrack(mediaStreamTrack).catch(function (error) {\n          _this._log.warn('setMediaStreamTrack failed:', {\n            error: error,\n            mediaStreamTrack: mediaStreamTrack\n          });\n        })).then(function () {\n          _this._initialize();\n          _this._getAllAttachedElements().forEach(function (el) {\n            return _this._attach(el);\n          });\n        });\n      };\n      /**\n       * @private\n       */\n      LocalMediaTrack.prototype._stop = function () {\n        this.mediaStreamTrack.stop();\n        this._end();\n        return this;\n      };\n      LocalMediaTrack.prototype.enable = function (enabled) {\n        enabled = typeof enabled === 'boolean' ? enabled : true;\n        if (enabled !== this.mediaStreamTrack.enabled) {\n          this._log.info((enabled ? 'En' : 'Dis') + \"abling\");\n          this.mediaStreamTrack.enabled = enabled;\n          this.emit(enabled ? 'enabled' : 'disabled', this);\n        }\n        return this;\n      };\n      LocalMediaTrack.prototype.disable = function () {\n        return this.enable(false);\n      };\n      LocalMediaTrack.prototype.restart = function (constraints) {\n        var _this = this;\n        var kind = this.kind;\n        if (!this._isCreatedByCreateLocalTracks) {\n          return Promise.reject(ILLEGAL_INVOKE('restart', 'can only be called on a' + (\" Local\" + capitalize(kind) + \"Track that is created using createLocalTracks\") + (\" or createLocal\" + capitalize(kind) + \"Track.\")));\n        }\n        if (this._workaroundWebKitBug1208516Cleanup) {\n          this._workaroundWebKitBug1208516Cleanup();\n          this._workaroundWebKitBug1208516Cleanup = null;\n        }\n        var promise = this._restart(constraints);\n        if (this._workaroundWebKitBug1208516) {\n          promise = promise.finally(function () {\n            _this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(_this);\n          });\n        }\n        return promise;\n      };\n      LocalMediaTrack.prototype.stop = function () {\n        this._log.info('Stopping');\n        if (this._workaroundWebKitBug1208516Cleanup) {\n          this._workaroundWebKitBug1208516Cleanup();\n          this._workaroundWebKitBug1208516Cleanup = null;\n        }\n        return this._stop();\n      };\n      return LocalMediaTrack;\n    }(AudioOrVideoTrack)\n  );\n}\n/**\n * Restart the given {@link LocalMediaTrack} if it has been inadvertently stopped.\n * @private\n * @param {LocalAudioTrack|LocalVideoTrack} localMediaTrack\n * @returns {function} Clean up listeners attached by the workaround\n */\nfunction restartWhenInadvertentlyStopped(localMediaTrack) {\n  var log = localMediaTrack._log,\n    kind = localMediaTrack.kind,\n    noiseCancellation = localMediaTrack._noiseCancellation;\n  var detectSilence = {\n    audio: detectSilentAudio,\n    video: detectSilentVideo\n  }[kind];\n  var getSourceMediaStreamTrack = function () {\n    return noiseCancellation ? noiseCancellation.sourceTrack : localMediaTrack.mediaStreamTrack;\n  };\n  var el = localMediaTrack._dummyEl;\n  var mediaStreamTrack = getSourceMediaStreamTrack();\n  var trackChangeInProgress = null;\n  function checkSilence() {\n    // The dummy element is paused, so play it and then detect silence.\n    return el.play().then(function () {\n      return detectSilence(el);\n    }).then(function (isSilent) {\n      if (isSilent) {\n        log.warn('Silence detected');\n      } else {\n        log.info('Non-silence detected');\n      }\n      return isSilent;\n    }).catch(function (error) {\n      log.warn('Failed to detect silence:', error);\n    }).finally(function () {\n      // Pause the dummy element again, if there is no processed track.\n      if (!localMediaTrack.processedTrack) {\n        el.pause();\n      }\n    });\n  }\n  function shouldReacquireTrack() {\n    var _workaroundWebKitBug1208516Cleanup = localMediaTrack._workaroundWebKitBug1208516Cleanup,\n      isStopped = localMediaTrack.isStopped;\n    var isInadvertentlyStopped = isStopped && !!_workaroundWebKitBug1208516Cleanup;\n    var muted = getSourceMediaStreamTrack().muted;\n    // NOTE(mmalavalli): Restart the LocalMediaTrack if:\n    // 1. The app is foregrounded, and\n    // 2. A restart is not already in progress, and\n    // 3. The LocalMediaTrack is either muted, inadvertently stopped or silent\n    return Promise.resolve().then(function () {\n      return document.visibilityState === 'visible' && !trackChangeInProgress && (muted || isInadvertentlyStopped || checkSilence());\n    });\n  }\n  function maybeRestart() {\n    return Promise.race([waitForEvent(mediaStreamTrack, 'unmute'), waitForSometime(50)]).then(function () {\n      return shouldReacquireTrack();\n    }).then(function (shouldReacquire) {\n      if (shouldReacquire && !trackChangeInProgress) {\n        trackChangeInProgress = defer();\n        localMediaTrack._restart().finally(function () {\n          el = localMediaTrack._dummyEl;\n          removeMediaStreamTrackListeners();\n          mediaStreamTrack = getSourceMediaStreamTrack();\n          addMediaStreamTrackListeners();\n          trackChangeInProgress.resolve();\n          trackChangeInProgress = null;\n        }).catch(function (error) {\n          log.error('failed to restart track: ', error);\n        });\n      }\n      // NOTE(mmalavalli): If the MediaStreamTrack ends before the DOM is visible,\n      // then this makes sure that visibility callback for phase 2 is called only\n      // after the MediaStreamTrack is re-acquired.\n      var promise = trackChangeInProgress && trackChangeInProgress.promise || Promise.resolve();\n      return promise.finally(function () {\n        return localMediaRestartDeferreds.resolveDeferred(kind);\n      });\n    }).catch(function (ex) {\n      log.error(\"error in maybeRestart: \" + ex.message);\n    });\n  }\n  function onMute() {\n    var log = localMediaTrack._log,\n      kind = localMediaTrack.kind;\n    log.info('Muted');\n    log.debug('LocalMediaTrack:', localMediaTrack);\n    // NOTE(mmalavalli): When a LocalMediaTrack is muted without the app being\n    // backgrounded, and the inadvertently paused elements are played before it\n    // is restarted, it never gets unmuted due to the WebKit Bug 213853. Hence,\n    // setting this Deferred will make sure that the inadvertently paused elements\n    // are played only after the LocalMediaTrack is unmuted.\n    //\n    // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853\n    //\n    localMediaRestartDeferreds.startDeferred(kind);\n  }\n  function addMediaStreamTrackListeners() {\n    mediaStreamTrack.addEventListener('ended', maybeRestart);\n    mediaStreamTrack.addEventListener('mute', onMute);\n    mediaStreamTrack.addEventListener('unmute', maybeRestart);\n  }\n  function removeMediaStreamTrackListeners() {\n    mediaStreamTrack.removeEventListener('ended', maybeRestart);\n    mediaStreamTrack.removeEventListener('mute', onMute);\n    mediaStreamTrack.removeEventListener('unmute', maybeRestart);\n  }\n  // NOTE(mpatwardhan): listen for document visibility callback on phase 1.\n  // this ensures that we acquire media tracks before RemoteMediaTrack\n  // tries to `play` them (in phase 2). This order is important because\n  // play can fail on safari if audio is not being captured.\n  var onVisibilityChange = function (isVisible) {\n    return isVisible ? maybeRestart() : false;\n  };\n  documentVisibilityMonitor.onVisibilityChange(1, onVisibilityChange);\n  addMediaStreamTrackListeners();\n  return function () {\n    documentVisibilityMonitor.offVisibilityChange(1, onVisibilityChange);\n    removeMediaStreamTrackListeners();\n  };\n}\nmodule.exports = mixinLocalMediaTrack;","map":{"version":3,"names":["getUserMedia","require","isIOS","_a","capitalize","defer","waitForSometime","waitForEvent","ILLEGAL_INVOKE","typeErrors","detectSilentAudio","detectSilentVideo","documentVisibilityMonitor","localMediaRestartDeferreds","gUMSilentTrackWorkaround","MediaTrackSender","mixinLocalMediaTrack","AudioOrVideoTrack","_super","__extends","LocalMediaTrack","mediaStreamTrack","options","_this","workaroundWebKitBug1208516","document","addEventListener","visibilityState","Object","assign","isCreatedByCreateLocalTracks","mediaTrackSender","kind","call","defineProperties","_constraints","value","writable","_getUserMedia","_gUMSilentTrackWorkaround","_eventsToReemitters","Map","emit","_workaroundWebKitBug1208516","_workaroundWebKitBug1208516Cleanup","_didCallEnd","_isCreatedByCreateLocalTracks","_noiseCancellation","noiseCancellation","_trackSender","id","enumerable","isEnabled","get","enabled","isMuted","muted","isStopped","readyState","restartWhenInadvertentlyStopped","_reemitTrackSenderEvents","prototype","_end","forEach","reemitter","event","removeListener","_initialize","_reacquireTrack","constraints","_b","log","_log","info","debug","gUMConstraints","audio","video","gUMPromise","then","mediaStream","getTracks","on","dequeue","_restart","_stop","catch","error","newMediaStreamTrack","_setMediaStreamTrack","_unprocessedTrack","Promise","resolve","setMediaStreamTrack","warn","_getAllAttachedElements","el","_attach","stop","enable","disable","restart","reject","promise","finally","localMediaTrack","detectSilence","getSourceMediaStreamTrack","sourceTrack","_dummyEl","trackChangeInProgress","checkSilence","play","isSilent","processedTrack","pause","shouldReacquireTrack","isInadvertentlyStopped","maybeRestart","race","shouldReacquire","removeMediaStreamTrackListeners","addMediaStreamTrackListeners","resolveDeferred","ex","message","onMute","startDeferred","removeEventListener","onVisibilityChange","isVisible","offVisibilityChange","module","exports"],"sources":["/home/denis/RiderProjects/ChatRoulette/WebUI/chat-app/node_modules/twilio-video/lib/media/track/localmediatrack.js"],"sourcesContent":["/* eslint new-cap:0 */\n'use strict';\n\nconst { getUserMedia } = require('../../webrtc');\nconst { isIOS } = require('../../util/browserdetection');\n\nconst { capitalize, defer, waitForSometime, waitForEvent } = require('../../util');\nconst { typeErrors: { ILLEGAL_INVOKE } } = require('../../util/constants');\nconst detectSilentAudio = require('../../util/detectsilentaudio');\nconst detectSilentVideo = require('../../util/detectsilentvideo');\nconst documentVisibilityMonitor = require('../../util/documentvisibilitymonitor.js');\nconst localMediaRestartDeferreds = require('../../util/localmediarestartdeferreds');\nconst gUMSilentTrackWorkaround = require('../../webaudio/workaround180748');\nconst MediaTrackSender = require('./sender');\n\nfunction mixinLocalMediaTrack(AudioOrVideoTrack) {\n  /**\n   * A {@link LocalMediaTrack} represents audio or video that your\n   * {@link LocalParticipant} is sending to a {@link Room}. As such, it can be\n   * enabled and disabled with {@link LocalMediaTrack#enable} and\n   * {@link LocalMediaTrack#disable} or stopped completely with\n   * {@link LocalMediaTrack#stop}.\n   * @emits LocalMediaTrack#muted\n   * @emits LocalMediaTrack#stopped\n   * @emits LocalMediaTrack#unmuted\n   */\n  return class LocalMediaTrack extends AudioOrVideoTrack {\n    /**\n     * Construct a {@link LocalMediaTrack} from a MediaStreamTrack.\n     * @param {MediaStreamTrack} mediaStreamTrack - The underlying MediaStreamTrack\n     * @param {LocalTrackOptions} [options] - {@link LocalTrack} options\n     */\n    constructor(mediaStreamTrack, options) {\n      const workaroundWebKitBug1208516 = isIOS()\n        && typeof document === 'object'\n        && typeof document.addEventListener === 'function'\n        && typeof document.visibilityState === 'string';\n\n      options = Object.assign({\n        getUserMedia,\n        isCreatedByCreateLocalTracks: false,\n        workaroundWebKitBug1208516,\n        gUMSilentTrackWorkaround\n      }, options);\n\n      const mediaTrackSender = new MediaTrackSender(mediaStreamTrack);\n      const { kind } = mediaTrackSender;\n\n      super(mediaTrackSender, options);\n\n      Object.defineProperties(this, {\n        _constraints: {\n          value: typeof options[kind] === 'object'\n            ? options[kind]\n            : {},\n          writable: true\n        },\n        _getUserMedia: {\n          value: options.getUserMedia\n        },\n        _gUMSilentTrackWorkaround: {\n          value: options.gUMSilentTrackWorkaround\n        },\n        _eventsToReemitters: {\n          value: new Map([\n            ['muted', () => this.emit('muted', this)],\n            ['unmuted', () => this.emit('unmuted', this)]\n          ])\n        },\n        _workaroundWebKitBug1208516: {\n          value: options.workaroundWebKitBug1208516\n        },\n        _workaroundWebKitBug1208516Cleanup: {\n          value: null,\n          writable: true\n        },\n        _didCallEnd: {\n          value: false,\n          writable: true\n        },\n        _isCreatedByCreateLocalTracks: {\n          value: options.isCreatedByCreateLocalTracks\n        },\n        _noiseCancellation: {\n          value: options.noiseCancellation || null\n        },\n        _trackSender: {\n          value: mediaTrackSender\n        },\n        id: {\n          enumerable: true,\n          value: mediaTrackSender.id\n        },\n        isEnabled: {\n          enumerable: true,\n          get() {\n            return mediaTrackSender.enabled;\n          }\n        },\n        isMuted: {\n          enumerable: true,\n          get() {\n            return mediaTrackSender.muted;\n          }\n        },\n        isStopped: {\n          enumerable: true,\n          get() {\n            return mediaTrackSender.readyState === 'ended';\n          }\n        }\n      });\n\n      // NOTE(mpatwardhan): As a workaround for WebKit bug: https://bugs.webkit.org/show_bug.cgi?id=208516,\n      // upon foregrounding, re-acquire new MediaStreamTrack if the existing one is ended or muted.\n      if (this._workaroundWebKitBug1208516) {\n        this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(this);\n      }\n\n      this._reemitTrackSenderEvents();\n    }\n\n    /**\n     * @private\n     */\n    _end() {\n      if (this._didCallEnd) {\n        return;\n      }\n      super._end.call(this);\n      this._didCallEnd = true;\n      this._eventsToReemitters.forEach((reemitter, event) => this._trackSender.removeListener(event, reemitter));\n      this.emit('stopped', this);\n    }\n\n    /**\n     * @private\n     */\n    _initialize() {\n      if (this._didCallEnd) {\n        this._didCallEnd = false;\n      }\n      if (this._eventsToReemitters) {\n        this._reemitTrackSenderEvents();\n      }\n      super._initialize.call(this);\n    }\n\n    /**\n     * @private\n     */\n    _reacquireTrack(constraints) {\n      const {\n        _getUserMedia: getUserMedia,\n        _gUMSilentTrackWorkaround: gUMSilentTrackWorkaround,\n        _log: log,\n        mediaStreamTrack: { kind }\n      } = this;\n\n      log.info('Re-acquiring the MediaStreamTrack');\n      log.debug('Constraints:', constraints);\n\n      const gUMConstraints = Object.assign({\n        audio: false,\n        video: false\n      }, { [kind]: constraints });\n\n      const gUMPromise = this._workaroundWebKitBug1208516Cleanup\n        ? gUMSilentTrackWorkaround(log, getUserMedia, gUMConstraints)\n        : getUserMedia(gUMConstraints);\n\n      return gUMPromise.then(mediaStream => {\n        return mediaStream.getTracks()[0];\n      });\n    }\n\n    /**\n     * @private\n     */\n    _reemitTrackSenderEvents() {\n      this._eventsToReemitters.forEach((reemitter, event) => this._trackSender.on(event, reemitter));\n      this._trackSender.dequeue('muted');\n      this._trackSender.dequeue('unmuted');\n    }\n\n    /**\n     * @private\n     */\n    _restart(constraints) {\n      const { _log: log } = this;\n      constraints = constraints || this._constraints;\n\n      // NOTE(mmalavalli): If we try and restart a silent MediaStreamTrack\n      // without stopping it first, then a NotReadableError is raised in case of\n      // video, or the restarted audio will still be silent. Hence, we stop the\n      // MediaStreamTrack here.\n      this._stop();\n\n      return this._reacquireTrack(constraints).catch(error => {\n        log.error('Failed to re-acquire the MediaStreamTrack:', { error, constraints });\n        throw error;\n      }).then(newMediaStreamTrack => {\n        log.info('Re-acquired the MediaStreamTrack');\n        log.debug('MediaStreamTrack:', newMediaStreamTrack);\n        this._constraints = Object.assign({}, constraints);\n        return this._setMediaStreamTrack(newMediaStreamTrack);\n      });\n    }\n\n    /**\n     * @private\n     */\n    _setMediaStreamTrack(mediaStreamTrack) {\n      // NOTE(mpatwardhan): Preserve the value of the \"enabled\" flag.\n      mediaStreamTrack.enabled = this.mediaStreamTrack.enabled;\n\n      // NOTE(mmalavalli): Stop the current MediaStreamTrack. If not already\n      // stopped, this should fire a \"stopped\" event.\n      this._stop();\n\n      // NOTE(csantos): If there's an unprocessedTrack, this means RTCRtpSender has\n      // the processedTrack already set, we don't want to replace that.\n      return (this._unprocessedTrack ? Promise.resolve().then(() => {\n        this._unprocessedTrack = mediaStreamTrack;\n      }) : this._trackSender.setMediaStreamTrack(mediaStreamTrack).catch(error => {\n        this._log.warn('setMediaStreamTrack failed:', { error, mediaStreamTrack });\n      })).then(() => {\n        this._initialize();\n        this._getAllAttachedElements().forEach(el => this._attach(el));\n      });\n    }\n\n    /**\n     * @private\n     */\n    _stop() {\n      this.mediaStreamTrack.stop();\n      this._end();\n      return this;\n    }\n\n    enable(enabled) {\n      enabled = typeof enabled === 'boolean' ? enabled : true;\n      if (enabled !== this.mediaStreamTrack.enabled) {\n        this._log.info(`${enabled ? 'En' : 'Dis'}abling`);\n        this.mediaStreamTrack.enabled = enabled;\n        this.emit(enabled ? 'enabled' : 'disabled', this);\n      }\n      return this;\n    }\n\n    disable() {\n      return this.enable(false);\n    }\n\n    restart(constraints) {\n      const { kind } = this;\n      if (!this._isCreatedByCreateLocalTracks) {\n        return Promise.reject(ILLEGAL_INVOKE('restart', 'can only be called on a'\n          + ` Local${capitalize(kind)}Track that is created using createLocalTracks`\n          + ` or createLocal${capitalize(kind)}Track.`));\n      }\n      if (this._workaroundWebKitBug1208516Cleanup) {\n        this._workaroundWebKitBug1208516Cleanup();\n        this._workaroundWebKitBug1208516Cleanup = null;\n      }\n      let promise = this._restart(constraints);\n\n      if (this._workaroundWebKitBug1208516) {\n        promise = promise.finally(() => {\n          this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(this);\n        });\n      }\n      return promise;\n    }\n\n    stop() {\n      this._log.info('Stopping');\n      if (this._workaroundWebKitBug1208516Cleanup) {\n        this._workaroundWebKitBug1208516Cleanup();\n        this._workaroundWebKitBug1208516Cleanup = null;\n      }\n      return this._stop();\n    }\n  };\n}\n\n/**\n * Restart the given {@link LocalMediaTrack} if it has been inadvertently stopped.\n * @private\n * @param {LocalAudioTrack|LocalVideoTrack} localMediaTrack\n * @returns {function} Clean up listeners attached by the workaround\n */\nfunction restartWhenInadvertentlyStopped(localMediaTrack) {\n  const {\n    _log: log,\n    kind,\n    _noiseCancellation: noiseCancellation\n  } = localMediaTrack;\n\n  const detectSilence = {\n    audio: detectSilentAudio,\n    video: detectSilentVideo\n  }[kind];\n\n  const getSourceMediaStreamTrack = () => noiseCancellation\n    ? noiseCancellation.sourceTrack\n    : localMediaTrack.mediaStreamTrack;\n\n  let { _dummyEl: el } = localMediaTrack;\n  let mediaStreamTrack = getSourceMediaStreamTrack();\n  let trackChangeInProgress = null;\n\n  function checkSilence() {\n    // The dummy element is paused, so play it and then detect silence.\n    return el.play().then(() => detectSilence(el)).then(isSilent => {\n      if (isSilent) {\n        log.warn('Silence detected');\n      } else {\n        log.info('Non-silence detected');\n      }\n      return isSilent;\n    }).catch(error => {\n      log.warn('Failed to detect silence:', error);\n    }).finally(() => {\n      // Pause the dummy element again, if there is no processed track.\n      if (!localMediaTrack.processedTrack) {\n        el.pause();\n      }\n    });\n  }\n\n  function shouldReacquireTrack() {\n    const {\n      _workaroundWebKitBug1208516Cleanup,\n      isStopped\n    } = localMediaTrack;\n\n    const isInadvertentlyStopped = isStopped && !!_workaroundWebKitBug1208516Cleanup;\n    const { muted } = getSourceMediaStreamTrack();\n\n    // NOTE(mmalavalli): Restart the LocalMediaTrack if:\n    // 1. The app is foregrounded, and\n    // 2. A restart is not already in progress, and\n    // 3. The LocalMediaTrack is either muted, inadvertently stopped or silent\n    return Promise.resolve().then(() => {\n      return document.visibilityState === 'visible'\n        && !trackChangeInProgress\n        && (muted || isInadvertentlyStopped || checkSilence());\n    });\n  }\n\n  function maybeRestart() {\n    return Promise.race([\n      waitForEvent(mediaStreamTrack, 'unmute'),\n      waitForSometime(50)\n    ]).then(() => shouldReacquireTrack()).then(shouldReacquire => {\n      if (shouldReacquire && !trackChangeInProgress) {\n        trackChangeInProgress = defer();\n        localMediaTrack._restart().finally(() => {\n          el = localMediaTrack._dummyEl;\n          removeMediaStreamTrackListeners();\n          mediaStreamTrack = getSourceMediaStreamTrack();\n          addMediaStreamTrackListeners();\n          trackChangeInProgress.resolve();\n          trackChangeInProgress = null;\n        }).catch(error => {\n          log.error('failed to restart track: ', error);\n        });\n      }\n\n      // NOTE(mmalavalli): If the MediaStreamTrack ends before the DOM is visible,\n      // then this makes sure that visibility callback for phase 2 is called only\n      // after the MediaStreamTrack is re-acquired.\n      const promise = (trackChangeInProgress && trackChangeInProgress.promise) || Promise.resolve();\n      return promise.finally(() => localMediaRestartDeferreds.resolveDeferred(kind));\n    }).catch(ex => {\n      log.error(`error in maybeRestart: ${ex.message}`);\n    });\n  }\n\n  function onMute() {\n    const { _log: log, kind } = localMediaTrack;\n    log.info('Muted');\n    log.debug('LocalMediaTrack:', localMediaTrack);\n\n    // NOTE(mmalavalli): When a LocalMediaTrack is muted without the app being\n    // backgrounded, and the inadvertently paused elements are played before it\n    // is restarted, it never gets unmuted due to the WebKit Bug 213853. Hence,\n    // setting this Deferred will make sure that the inadvertently paused elements\n    // are played only after the LocalMediaTrack is unmuted.\n    //\n    // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853\n    //\n    localMediaRestartDeferreds.startDeferred(kind);\n  }\n\n  function addMediaStreamTrackListeners() {\n    mediaStreamTrack.addEventListener('ended', maybeRestart);\n    mediaStreamTrack.addEventListener('mute', onMute);\n    mediaStreamTrack.addEventListener('unmute', maybeRestart);\n  }\n\n  function removeMediaStreamTrackListeners() {\n    mediaStreamTrack.removeEventListener('ended', maybeRestart);\n    mediaStreamTrack.removeEventListener('mute', onMute);\n    mediaStreamTrack.removeEventListener('unmute', maybeRestart);\n  }\n\n  // NOTE(mpatwardhan): listen for document visibility callback on phase 1.\n  // this ensures that we acquire media tracks before RemoteMediaTrack\n  // tries to `play` them (in phase 2). This order is important because\n  // play can fail on safari if audio is not being captured.\n  let onVisibilityChange = isVisible => {\n    return isVisible ? maybeRestart() : false;\n  };\n  documentVisibilityMonitor.onVisibilityChange(1, onVisibilityChange);\n  addMediaStreamTrackListeners();\n\n  return () => {\n    documentVisibilityMonitor.offVisibilityChange(1, onVisibilityChange);\n    removeMediaStreamTrackListeners();\n  };\n}\n\nmodule.exports = mixinLocalMediaTrack;\n"],"mappings":"AAAA;AACA,YAAY;;;;;;;;;;;;;;;;;;;;;;AAEJ,IAAAA,YAAY,GAAKC,OAAO,CAAC,cAAc,CAAC,CAAAD,YAA5B;AACZ,IAAAE,KAAK,GAAKD,OAAO,CAAC,6BAA6B,CAAC,CAAAC,KAA3C;AAEP,IAAAC,EAAA,GAAuDF,OAAO,CAAC,YAAY,CAAC;EAA1EG,UAAU,GAAAD,EAAA,CAAAC,UAAA;EAAEC,KAAK,GAAAF,EAAA,CAAAE,KAAA;EAAEC,eAAe,GAAAH,EAAA,CAAAG,eAAA;EAAEC,YAAY,GAAAJ,EAAA,CAAAI,YAA0B;AAC5D,IAAAC,cAAc,GAAOP,OAAO,CAAC,sBAAsB,CAAC,CAAAQ,UAAA,CAAAD,cAAtC;AACpC,IAAME,iBAAiB,GAAGT,OAAO,CAAC,8BAA8B,CAAC;AACjE,IAAMU,iBAAiB,GAAGV,OAAO,CAAC,8BAA8B,CAAC;AACjE,IAAMW,yBAAyB,GAAGX,OAAO,CAAC,yCAAyC,CAAC;AACpF,IAAMY,0BAA0B,GAAGZ,OAAO,CAAC,uCAAuC,CAAC;AACnF,IAAMa,wBAAwB,GAAGb,OAAO,CAAC,iCAAiC,CAAC;AAC3E,IAAMc,gBAAgB,GAAGd,OAAO,CAAC,UAAU,CAAC;AAE5C,SAASe,oBAAoBA,CAACC,iBAAiB;EAC7C;;;;;;;;;;EAUA,+BAAAC,MAAA;MAAqCC,SAAA,CAAAC,eAAA,EAAAF,MAAA;MACnC;;;;;MAKA,SAAAE,gBAAYC,gBAAgB,EAAEC,OAAO;QAArC,IAAAC,KAAA;QACE,IAAMC,0BAA0B,GAAGtB,KAAK,EAAE,IACrC,OAAOuB,QAAQ,KAAK,QAAQ,IAC5B,OAAOA,QAAQ,CAACC,gBAAgB,KAAK,UAAU,IAC/C,OAAOD,QAAQ,CAACE,eAAe,KAAK,QAAQ;QAEjDL,OAAO,GAAGM,MAAM,CAACC,MAAM,CAAC;UACtB7B,YAAY,EAAAA,YAAA;UACZ8B,4BAA4B,EAAE,KAAK;UACnCN,0BAA0B,EAAAA,0BAAA;UAC1BV,wBAAwB,EAAAA;SACzB,EAAEQ,OAAO,CAAC;QAEX,IAAMS,gBAAgB,GAAG,IAAIhB,gBAAgB,CAACM,gBAAgB,CAAC;QACvD,IAAAW,IAAI,GAAKD,gBAAgB,CAAAC,IAArB;QAEZT,KAAA,GAAAL,MAAA,CAAAe,IAAA,OAAMF,gBAAgB,EAAET,OAAO,CAAC;QAEhCM,MAAM,CAACM,gBAAgB,CAACX,KAAI,EAAE;UAC5BY,YAAY,EAAE;YACZC,KAAK,EAAE,OAAOd,OAAO,CAACU,IAAI,CAAC,KAAK,QAAQ,GACpCV,OAAO,CAACU,IAAI,CAAC,GACb,EAAE;YACNK,QAAQ,EAAE;WACX;UACDC,aAAa,EAAE;YACbF,KAAK,EAAEd,OAAO,CAACtB;WAChB;UACDuC,yBAAyB,EAAE;YACzBH,KAAK,EAAEd,OAAO,CAACR;WAChB;UACD0B,mBAAmB,EAAE;YACnBJ,KAAK,EAAE,IAAIK,GAAG,CAAC,CACb,CAAC,OAAO,EAAE;cAAM,OAAAlB,KAAI,CAACmB,IAAI,CAAC,OAAO,EAAEnB,KAAI,CAAC;YAAxB,CAAwB,CAAC,EACzC,CAAC,SAAS,EAAE;cAAM,OAAAA,KAAI,CAACmB,IAAI,CAAC,SAAS,EAAEnB,KAAI,CAAC;YAA1B,CAA0B,CAAC,CAC9C;WACF;UACDoB,2BAA2B,EAAE;YAC3BP,KAAK,EAAEd,OAAO,CAACE;WAChB;UACDoB,kCAAkC,EAAE;YAClCR,KAAK,EAAE,IAAI;YACXC,QAAQ,EAAE;WACX;UACDQ,WAAW,EAAE;YACXT,KAAK,EAAE,KAAK;YACZC,QAAQ,EAAE;WACX;UACDS,6BAA6B,EAAE;YAC7BV,KAAK,EAAEd,OAAO,CAACQ;WAChB;UACDiB,kBAAkB,EAAE;YAClBX,KAAK,EAAEd,OAAO,CAAC0B,iBAAiB,IAAI;WACrC;UACDC,YAAY,EAAE;YACZb,KAAK,EAAEL;WACR;UACDmB,EAAE,EAAE;YACFC,UAAU,EAAE,IAAI;YAChBf,KAAK,EAAEL,gBAAgB,CAACmB;WACzB;UACDE,SAAS,EAAE;YACTD,UAAU,EAAE,IAAI;YAChBE,GAAG,WAAAA,CAAA;cACD,OAAOtB,gBAAgB,CAACuB,OAAO;YACjC;WACD;UACDC,OAAO,EAAE;YACPJ,UAAU,EAAE,IAAI;YAChBE,GAAG,WAAAA,CAAA;cACD,OAAOtB,gBAAgB,CAACyB,KAAK;YAC/B;WACD;UACDC,SAAS,EAAE;YACTN,UAAU,EAAE,IAAI;YAChBE,GAAG,WAAAA,CAAA;cACD,OAAOtB,gBAAgB,CAAC2B,UAAU,KAAK,OAAO;YAChD;;SAEH,CAAC;QAEF;QACA;QACA,IAAInC,KAAI,CAACoB,2BAA2B,EAAE;UACpCpB,KAAI,CAACqB,kCAAkC,GAAGe,+BAA+B,CAACpC,KAAI,CAAC;;QAGjFA,KAAI,CAACqC,wBAAwB,EAAE;;MACjC;MAEA;;;MAGAxC,eAAA,CAAAyC,SAAA,CAAAC,IAAI,GAAJ;QAAA,IAAAvC,KAAA;QACE,IAAI,IAAI,CAACsB,WAAW,EAAE;UACpB;;QAEF3B,MAAA,CAAA2C,SAAA,CAAMC,IAAI,CAAC7B,IAAI,CAAC,IAAI,CAAC;QACrB,IAAI,CAACY,WAAW,GAAG,IAAI;QACvB,IAAI,CAACL,mBAAmB,CAACuB,OAAO,CAAC,UAACC,SAAS,EAAEC,KAAK;UAAK,OAAA1C,KAAI,CAAC0B,YAAY,CAACiB,cAAc,CAACD,KAAK,EAAED,SAAS,CAAC;QAAlD,CAAkD,CAAC;QAC1G,IAAI,CAACtB,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC;MAC5B,CAAC;MAED;;;MAGAtB,eAAA,CAAAyC,SAAA,CAAAM,WAAW,GAAX;QACE,IAAI,IAAI,CAACtB,WAAW,EAAE;UACpB,IAAI,CAACA,WAAW,GAAG,KAAK;;QAE1B,IAAI,IAAI,CAACL,mBAAmB,EAAE;UAC5B,IAAI,CAACoB,wBAAwB,EAAE;;QAEjC1C,MAAA,CAAA2C,SAAA,CAAMM,WAAW,CAAClC,IAAI,CAAC,IAAI,CAAC;MAC9B,CAAC;MAED;;;MAGAb,eAAA,CAAAyC,SAAA,CAAAO,eAAe,GAAf,UAAgBC,WAAW;;QACnB,IAAAC,EAAA,GAKF,IAAI;UAJStE,YAAY,GAAAsE,EAAA,CAAAhC,aAAA;UACAxB,wBAAwB,GAAAwD,EAAA,CAAA/B,yBAAA;UAC7CgC,GAAG,GAAAD,EAAA,CAAAE,IAAA;UACWxC,IAAI,GAAAsC,EAAA,CAAAjD,gBAAA,CAAAW,IAClB;QAERuC,GAAG,CAACE,IAAI,CAAC,mCAAmC,CAAC;QAC7CF,GAAG,CAACG,KAAK,CAAC,cAAc,EAAEL,WAAW,CAAC;QAEtC,IAAMM,cAAc,GAAG/C,MAAM,CAACC,MAAM,CAAC;UACnC+C,KAAK,EAAE,KAAK;UACZC,KAAK,EAAE;SACR,GAAA1E,EAAA,OAAIA,EAAA,CAAC6B,IAAI,IAAGqC,WAAW,EAAAlE,EAAA,EAAG;QAE3B,IAAM2E,UAAU,GAAG,IAAI,CAAClC,kCAAkC,GACtD9B,wBAAwB,CAACyD,GAAG,EAAEvE,YAAY,EAAE2E,cAAc,CAAC,GAC3D3E,YAAY,CAAC2E,cAAc,CAAC;QAEhC,OAAOG,UAAU,CAACC,IAAI,CAAC,UAAAC,WAAW;UAChC,OAAOA,WAAW,CAACC,SAAS,EAAE,CAAC,CAAC,CAAC;QACnC,CAAC,CAAC;MACJ,CAAC;MAED;;;MAGA7D,eAAA,CAAAyC,SAAA,CAAAD,wBAAwB,GAAxB;QAAA,IAAArC,KAAA;QACE,IAAI,CAACiB,mBAAmB,CAACuB,OAAO,CAAC,UAACC,SAAS,EAAEC,KAAK;UAAK,OAAA1C,KAAI,CAAC0B,YAAY,CAACiC,EAAE,CAACjB,KAAK,EAAED,SAAS,CAAC;QAAtC,CAAsC,CAAC;QAC9F,IAAI,CAACf,YAAY,CAACkC,OAAO,CAAC,OAAO,CAAC;QAClC,IAAI,CAAClC,YAAY,CAACkC,OAAO,CAAC,SAAS,CAAC;MACtC,CAAC;MAED;;;MAGA/D,eAAA,CAAAyC,SAAA,CAAAuB,QAAQ,GAAR,UAASf,WAAW;QAApB,IAAA9C,KAAA;QACU,IAAMgD,GAAG,GAAK,IAAI,CAAAC,IAAT;QACjBH,WAAW,GAAGA,WAAW,IAAI,IAAI,CAAClC,YAAY;QAE9C;QACA;QACA;QACA;QACA,IAAI,CAACkD,KAAK,EAAE;QAEZ,OAAO,IAAI,CAACjB,eAAe,CAACC,WAAW,CAAC,CAACiB,KAAK,CAAC,UAAAC,KAAK;UAClDhB,GAAG,CAACgB,KAAK,CAAC,4CAA4C,EAAE;YAAEA,KAAK,EAAAA,KAAA;YAAElB,WAAW,EAAAA;UAAA,CAAE,CAAC;UAC/E,MAAMkB,KAAK;QACb,CAAC,CAAC,CAACR,IAAI,CAAC,UAAAS,mBAAmB;UACzBjB,GAAG,CAACE,IAAI,CAAC,kCAAkC,CAAC;UAC5CF,GAAG,CAACG,KAAK,CAAC,mBAAmB,EAAEc,mBAAmB,CAAC;UACnDjE,KAAI,CAACY,YAAY,GAAGP,MAAM,CAACC,MAAM,CAAC,EAAE,EAAEwC,WAAW,CAAC;UAClD,OAAO9C,KAAI,CAACkE,oBAAoB,CAACD,mBAAmB,CAAC;QACvD,CAAC,CAAC;MACJ,CAAC;MAED;;;MAGApE,eAAA,CAAAyC,SAAA,CAAA4B,oBAAoB,GAApB,UAAqBpE,gBAAgB;QAArC,IAAAE,KAAA;QACE;QACAF,gBAAgB,CAACiC,OAAO,GAAG,IAAI,CAACjC,gBAAgB,CAACiC,OAAO;QAExD;QACA;QACA,IAAI,CAAC+B,KAAK,EAAE;QAEZ;QACA;QACA,OAAO,CAAC,IAAI,CAACK,iBAAiB,GAAGC,OAAO,CAACC,OAAO,EAAE,CAACb,IAAI,CAAC;UACtDxD,KAAI,CAACmE,iBAAiB,GAAGrE,gBAAgB;QAC3C,CAAC,CAAC,GAAG,IAAI,CAAC4B,YAAY,CAAC4C,mBAAmB,CAACxE,gBAAgB,CAAC,CAACiE,KAAK,CAAC,UAAAC,KAAK;UACtEhE,KAAI,CAACiD,IAAI,CAACsB,IAAI,CAAC,6BAA6B,EAAE;YAAEP,KAAK,EAAAA,KAAA;YAAElE,gBAAgB,EAAAA;UAAA,CAAE,CAAC;QAC5E,CAAC,CAAC,EAAE0D,IAAI,CAAC;UACPxD,KAAI,CAAC4C,WAAW,EAAE;UAClB5C,KAAI,CAACwE,uBAAuB,EAAE,CAAChC,OAAO,CAAC,UAAAiC,EAAE;YAAI,OAAAzE,KAAI,CAAC0E,OAAO,CAACD,EAAE,CAAC;UAAhB,CAAgB,CAAC;QAChE,CAAC,CAAC;MACJ,CAAC;MAED;;;MAGA5E,eAAA,CAAAyC,SAAA,CAAAwB,KAAK,GAAL;QACE,IAAI,CAAChE,gBAAgB,CAAC6E,IAAI,EAAE;QAC5B,IAAI,CAACpC,IAAI,EAAE;QACX,OAAO,IAAI;MACb,CAAC;MAED1C,eAAA,CAAAyC,SAAA,CAAAsC,MAAM,GAAN,UAAO7C,OAAO;QACZA,OAAO,GAAG,OAAOA,OAAO,KAAK,SAAS,GAAGA,OAAO,GAAG,IAAI;QACvD,IAAIA,OAAO,KAAK,IAAI,CAACjC,gBAAgB,CAACiC,OAAO,EAAE;UAC7C,IAAI,CAACkB,IAAI,CAACC,IAAI,CAAC,CAAGnB,OAAO,GAAG,IAAI,GAAG,KAAK,YAAQ,CAAC;UACjD,IAAI,CAACjC,gBAAgB,CAACiC,OAAO,GAAGA,OAAO;UACvC,IAAI,CAACZ,IAAI,CAACY,OAAO,GAAG,SAAS,GAAG,UAAU,EAAE,IAAI,CAAC;;QAEnD,OAAO,IAAI;MACb,CAAC;MAEDlC,eAAA,CAAAyC,SAAA,CAAAuC,OAAO,GAAP;QACE,OAAO,IAAI,CAACD,MAAM,CAAC,KAAK,CAAC;MAC3B,CAAC;MAED/E,eAAA,CAAAyC,SAAA,CAAAwC,OAAO,GAAP,UAAQhC,WAAW;QAAnB,IAAA9C,KAAA;QACU,IAAAS,IAAI,GAAK,IAAI,CAAAA,IAAT;QACZ,IAAI,CAAC,IAAI,CAACc,6BAA6B,EAAE;UACvC,OAAO6C,OAAO,CAACW,MAAM,CAAC9F,cAAc,CAAC,SAAS,EAAE,yBAAyB,IACrE,WAASJ,UAAU,CAAC4B,IAAI,CAAC,kDAA+C,KACxE,oBAAkB5B,UAAU,CAAC4B,IAAI,CAAC,WAAQ,EAAC,CAAC;;QAElD,IAAI,IAAI,CAACY,kCAAkC,EAAE;UAC3C,IAAI,CAACA,kCAAkC,EAAE;UACzC,IAAI,CAACA,kCAAkC,GAAG,IAAI;;QAEhD,IAAI2D,OAAO,GAAG,IAAI,CAACnB,QAAQ,CAACf,WAAW,CAAC;QAExC,IAAI,IAAI,CAAC1B,2BAA2B,EAAE;UACpC4D,OAAO,GAAGA,OAAO,CAACC,OAAO,CAAC;YACxBjF,KAAI,CAACqB,kCAAkC,GAAGe,+BAA+B,CAACpC,KAAI,CAAC;UACjF,CAAC,CAAC;;QAEJ,OAAOgF,OAAO;MAChB,CAAC;MAEDnF,eAAA,CAAAyC,SAAA,CAAAqC,IAAI,GAAJ;QACE,IAAI,CAAC1B,IAAI,CAACC,IAAI,CAAC,UAAU,CAAC;QAC1B,IAAI,IAAI,CAAC7B,kCAAkC,EAAE;UAC3C,IAAI,CAACA,kCAAkC,EAAE;UACzC,IAAI,CAACA,kCAAkC,GAAG,IAAI;;QAEhD,OAAO,IAAI,CAACyC,KAAK,EAAE;MACrB,CAAC;MACH,OAAAjE,eAAC;IAAD,CAAC,CAlQoCH,iBAAiB;EAAA;AAmQxD;AAEA;;;;;;AAMA,SAAS0C,+BAA+BA,CAAC8C,eAAe;EAEpD,IAAMlC,GAAG,GAGPkC,eAAe,CAAAjC,IAHR;IACTxC,IAAI,GAEFyE,eAAe,CAAAzE,IAFb;IACgBgB,iBAAiB,GACnCyD,eAAe,CAAA1D,kBADoB;EAGvC,IAAM2D,aAAa,GAAG;IACpB9B,KAAK,EAAElE,iBAAiB;IACxBmE,KAAK,EAAElE;GACR,CAACqB,IAAI,CAAC;EAEP,IAAM2E,yBAAyB,GAAG,SAAAA,CAAA;IAAM,OAAA3D,iBAAiB,GACrDA,iBAAiB,CAAC4D,WAAW,GAC7BH,eAAe,CAACpF,gBAAgB;EAFI,CAEJ;EAE9B,IAAU2E,EAAE,GAAKS,eAAe,CAAAI,QAApB;EAClB,IAAIxF,gBAAgB,GAAGsF,yBAAyB,EAAE;EAClD,IAAIG,qBAAqB,GAAG,IAAI;EAEhC,SAASC,YAAYA,CAAA;IACnB;IACA,OAAOf,EAAE,CAACgB,IAAI,EAAE,CAACjC,IAAI,CAAC;MAAM,OAAA2B,aAAa,CAACV,EAAE,CAAC;IAAjB,CAAiB,CAAC,CAACjB,IAAI,CAAC,UAAAkC,QAAQ;MAC1D,IAAIA,QAAQ,EAAE;QACZ1C,GAAG,CAACuB,IAAI,CAAC,kBAAkB,CAAC;OAC7B,MAAM;QACLvB,GAAG,CAACE,IAAI,CAAC,sBAAsB,CAAC;;MAElC,OAAOwC,QAAQ;IACjB,CAAC,CAAC,CAAC3B,KAAK,CAAC,UAAAC,KAAK;MACZhB,GAAG,CAACuB,IAAI,CAAC,2BAA2B,EAAEP,KAAK,CAAC;IAC9C,CAAC,CAAC,CAACiB,OAAO,CAAC;MACT;MACA,IAAI,CAACC,eAAe,CAACS,cAAc,EAAE;QACnClB,EAAE,CAACmB,KAAK,EAAE;;IAEd,CAAC,CAAC;EACJ;EAEA,SAASC,oBAAoBA,CAAA;IAEzB,IAAAxE,kCAAkC,GAEhC6D,eAAe,CAAA7D,kCAFiB;MAClCa,SAAS,GACPgD,eAAe,CAAAhD,SADR;IAGX,IAAM4D,sBAAsB,GAAG5D,SAAS,IAAI,CAAC,CAACb,kCAAkC;IACxE,IAAAY,KAAK,GAAKmD,yBAAyB,EAAE,CAAAnD,KAAhC;IAEb;IACA;IACA;IACA;IACA,OAAOmC,OAAO,CAACC,OAAO,EAAE,CAACb,IAAI,CAAC;MAC5B,OAAOtD,QAAQ,CAACE,eAAe,KAAK,SAAS,IACxC,CAACmF,qBAAqB,KACrBtD,KAAK,IAAI6D,sBAAsB,IAAIN,YAAY,EAAE,CAAC;IAC1D,CAAC,CAAC;EACJ;EAEA,SAASO,YAAYA,CAAA;IACnB,OAAO3B,OAAO,CAAC4B,IAAI,CAAC,CAClBhH,YAAY,CAACc,gBAAgB,EAAE,QAAQ,CAAC,EACxCf,eAAe,CAAC,EAAE,CAAC,CACpB,CAAC,CAACyE,IAAI,CAAC;MAAM,OAAAqC,oBAAoB,EAAE;IAAtB,CAAsB,CAAC,CAACrC,IAAI,CAAC,UAAAyC,eAAe;MACxD,IAAIA,eAAe,IAAI,CAACV,qBAAqB,EAAE;QAC7CA,qBAAqB,GAAGzG,KAAK,EAAE;QAC/BoG,eAAe,CAACrB,QAAQ,EAAE,CAACoB,OAAO,CAAC;UACjCR,EAAE,GAAGS,eAAe,CAACI,QAAQ;UAC7BY,+BAA+B,EAAE;UACjCpG,gBAAgB,GAAGsF,yBAAyB,EAAE;UAC9Ce,4BAA4B,EAAE;UAC9BZ,qBAAqB,CAAClB,OAAO,EAAE;UAC/BkB,qBAAqB,GAAG,IAAI;QAC9B,CAAC,CAAC,CAACxB,KAAK,CAAC,UAAAC,KAAK;UACZhB,GAAG,CAACgB,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;QAC/C,CAAC,CAAC;;MAGJ;MACA;MACA;MACA,IAAMgB,OAAO,GAAIO,qBAAqB,IAAIA,qBAAqB,CAACP,OAAO,IAAKZ,OAAO,CAACC,OAAO,EAAE;MAC7F,OAAOW,OAAO,CAACC,OAAO,CAAC;QAAM,OAAA3F,0BAA0B,CAAC8G,eAAe,CAAC3F,IAAI,CAAC;MAAhD,CAAgD,CAAC;IAChF,CAAC,CAAC,CAACsD,KAAK,CAAC,UAAAsC,EAAE;MACTrD,GAAG,CAACgB,KAAK,CAAC,4BAA0BqC,EAAE,CAACC,OAAS,CAAC;IACnD,CAAC,CAAC;EACJ;EAEA,SAASC,MAAMA,CAAA;IACL,IAAMvD,GAAG,GAAWkC,eAAe,CAAAjC,IAA1B;MAAExC,IAAI,GAAKyE,eAAe,CAAAzE,IAApB;IACvBuC,GAAG,CAACE,IAAI,CAAC,OAAO,CAAC;IACjBF,GAAG,CAACG,KAAK,CAAC,kBAAkB,EAAE+B,eAAe,CAAC;IAE9C;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA5F,0BAA0B,CAACkH,aAAa,CAAC/F,IAAI,CAAC;EAChD;EAEA,SAAS0F,4BAA4BA,CAAA;IACnCrG,gBAAgB,CAACK,gBAAgB,CAAC,OAAO,EAAE4F,YAAY,CAAC;IACxDjG,gBAAgB,CAACK,gBAAgB,CAAC,MAAM,EAAEoG,MAAM,CAAC;IACjDzG,gBAAgB,CAACK,gBAAgB,CAAC,QAAQ,EAAE4F,YAAY,CAAC;EAC3D;EAEA,SAASG,+BAA+BA,CAAA;IACtCpG,gBAAgB,CAAC2G,mBAAmB,CAAC,OAAO,EAAEV,YAAY,CAAC;IAC3DjG,gBAAgB,CAAC2G,mBAAmB,CAAC,MAAM,EAAEF,MAAM,CAAC;IACpDzG,gBAAgB,CAAC2G,mBAAmB,CAAC,QAAQ,EAAEV,YAAY,CAAC;EAC9D;EAEA;EACA;EACA;EACA;EACA,IAAIW,kBAAkB,GAAG,SAAAA,CAAAC,SAAS;IAChC,OAAOA,SAAS,GAAGZ,YAAY,EAAE,GAAG,KAAK;EAC3C,CAAC;EACD1G,yBAAyB,CAACqH,kBAAkB,CAAC,CAAC,EAAEA,kBAAkB,CAAC;EACnEP,4BAA4B,EAAE;EAE9B,OAAO;IACL9G,yBAAyB,CAACuH,mBAAmB,CAAC,CAAC,EAAEF,kBAAkB,CAAC;IACpER,+BAA+B,EAAE;EACnC,CAAC;AACH;AAEAW,MAAM,CAACC,OAAO,GAAGrH,oBAAoB"},"metadata":{},"sourceType":"script","externalDependencies":[]}