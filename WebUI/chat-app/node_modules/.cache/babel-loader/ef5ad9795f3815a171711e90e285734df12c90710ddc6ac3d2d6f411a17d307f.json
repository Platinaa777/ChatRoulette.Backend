{"ast":null,"code":"'use strict';\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar _a = require('../'),\n  difference = _a.difference,\n  flatMap = _a.flatMap;\nvar setSimulcastInMediaSection = require('./simulcast');\nvar ptToFixedBitrateAudioCodecName = {\n  0: 'PCMU',\n  8: 'PCMA'\n};\n/**\n * A payload type\n * @typedef {number} PT\n */\n/**\n * An {@link AudioCodec} or {@link VideoCodec}\n * @typedef {AudioCodec|VideoCodec} Codec\n */\n/**\n * Create a Codec Map for the given m= section.\n * @param {string} section - The given m= section\n * @returns {Map<Codec, Array<PT>>}\n */\nfunction createCodecMapForMediaSection(section) {\n  return Array.from(createPtToCodecName(section)).reduce(function (codecMap, pair) {\n    var pt = pair[0];\n    var codecName = pair[1];\n    var pts = codecMap.get(codecName) || [];\n    return codecMap.set(codecName, pts.concat(pt));\n  }, new Map());\n}\n/**\n * Create a Map of MIDs to m= sections for the given SDP.\n * @param {string} sdp\n * @returns {Map<string, string>}\n */\nfunction createMidToMediaSectionMap(sdp) {\n  return getMediaSections(sdp).reduce(function (midsToMediaSections, mediaSection) {\n    var mid = getMidForMediaSection(mediaSection);\n    return mid ? midsToMediaSections.set(mid, mediaSection) : midsToMediaSections;\n  }, new Map());\n}\n/**\n * Create a Map from PTs to codec names for the given m= section.\n * @param {string} mediaSection - The given m= section.\n * @returns {Map<PT, Codec>} ptToCodecName\n */\nfunction createPtToCodecName(mediaSection) {\n  return getPayloadTypesInMediaSection(mediaSection).reduce(function (ptToCodecName, pt) {\n    var rtpmapPattern = new RegExp(\"a=rtpmap:\" + pt + \" ([^/]+)\");\n    var matches = mediaSection.match(rtpmapPattern);\n    var codecName = matches ? matches[1].toLowerCase() : ptToFixedBitrateAudioCodecName[pt] ? ptToFixedBitrateAudioCodecName[pt].toLowerCase() : '';\n    return ptToCodecName.set(pt, codecName);\n  }, new Map());\n}\n/**\n * Get the associated fmtp attributes for the given Payload Type in an m= section.\n * @param {PT} pt\n * @param {string} mediaSection\n * @returns {?object}\n */\nfunction getFmtpAttributesForPt(pt, mediaSection) {\n  // In \"a=fmtp:<pt> <name>=<value>[;<name>=<value>]*\", the regex matches the codec\n  // profile parameters expressed as name/value pairs separated by \";\".\n  var fmtpRegex = new RegExp(\"^a=fmtp:\" + pt + \" (.+)$\", 'm');\n  var matches = mediaSection.match(fmtpRegex);\n  return matches && matches[1].split(';').reduce(function (attrs, nvPair) {\n    var _a = __read(nvPair.split('='), 2),\n      name = _a[0],\n      value = _a[1];\n    attrs[name] = isNaN(value) ? value : parseInt(value, 10);\n    return attrs;\n  }, {});\n}\n/**\n * Get the MID for the given m= section.\n * @param {string} mediaSection\n * @return {?string}\n */\nfunction getMidForMediaSection(mediaSection) {\n  // In \"a=mid:<mid>\", the regex matches <mid>.\n  var midMatches = mediaSection.match(/^a=mid:(.+)$/m);\n  return midMatches && midMatches[1];\n}\n/**\n * Get the m= sections of a particular kind and direction from an sdp.\n * @param {string} sdp - SDP string\n * @param {string} [kind] - Pattern for matching kind\n * @param {string} [direction] - Pattern for matching direction\n * @returns {Array<string>} mediaSections\n */\nfunction getMediaSections(sdp, kind, direction) {\n  return sdp.replace(/\\r\\n\\r\\n$/, '\\r\\n').split('\\r\\nm=').slice(1).map(function (mediaSection) {\n    return \"m=\" + mediaSection;\n  }).filter(function (mediaSection) {\n    var kindPattern = new RegExp(\"m=\" + (kind || '.*'), 'gm');\n    var directionPattern = new RegExp(\"a=\" + (direction || '.*'), 'gm');\n    return kindPattern.test(mediaSection) && directionPattern.test(mediaSection);\n  });\n}\n/**\n * Get the Codec Payload Types present in the first line of the given m= section\n * @param {string} section - The m= section\n * @returns {Array<PT>} Payload Types\n */\nfunction getPayloadTypesInMediaSection(section) {\n  var mLine = section.split('\\r\\n')[0];\n  // In \"m=<kind> <port> <proto> <payload_type_1> <payload_type_2> ... <payload_type_n>\",\n  // the regex matches <port> and the Payload Types.\n  var matches = mLine.match(/([0-9]+)/g);\n  // This should not happen, but in case there are no Payload Types in\n  // the m= line, return an empty array.\n  if (!matches) {\n    return [];\n  }\n  // Since only the Payload Types are needed, we discard the <port>.\n  return matches.slice(1).map(function (match) {\n    return parseInt(match, 10);\n  });\n}\n/**\n * Create the reordered Codec Payload Types based on the preferred Codec Names.\n * @param {Map<Codec, Array<PT>>} codecMap - Codec Map\n * @param {Array<AudioCodecSettings|VideoCodecSettings>} preferredCodecs - Preferred Codecs\n * @returns {Array<PT>} Reordered Payload Types\n */\nfunction getReorderedPayloadTypes(codecMap, preferredCodecs) {\n  preferredCodecs = preferredCodecs.map(function (_a) {\n    var codec = _a.codec;\n    return codec.toLowerCase();\n  });\n  var preferredPayloadTypes = flatMap(preferredCodecs, function (codecName) {\n    return codecMap.get(codecName) || [];\n  });\n  var remainingCodecs = difference(Array.from(codecMap.keys()), preferredCodecs);\n  var remainingPayloadTypes = flatMap(remainingCodecs, function (codecName) {\n    return codecMap.get(codecName);\n  });\n  return preferredPayloadTypes.concat(remainingPayloadTypes);\n}\n/**\n * Set the given Codec Payload Types in the first line of the given m= section.\n * @param {Array<PT>} payloadTypes - Payload Types\n * @param {string} section - Given m= section\n * @returns {string} - Updated m= section\n */\nfunction setPayloadTypesInMediaSection(payloadTypes, section) {\n  var lines = section.split('\\r\\n');\n  var mLine = lines[0];\n  var otherLines = lines.slice(1);\n  mLine = mLine.replace(/([0-9]+\\s?)+$/, payloadTypes.join(' '));\n  return [mLine].concat(otherLines).join('\\r\\n');\n}\n/**\n * Return a new SDP string with the re-ordered codec preferences.\n * @param {string} sdp\n * @param {Array<AudioCodec>} preferredAudioCodecs - If empty, the existing order\n *   of audio codecs is preserved\n * @param {Array<VideoCodecSettings>} preferredVideoCodecs - If empty, the\n *   existing order of video codecs is preserved\n * @returns {string} Updated SDP string\n */\nfunction setCodecPreferences(sdp, preferredAudioCodecs, preferredVideoCodecs) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    // Codec preferences should not be applied to m=application sections.\n    if (!/^m=(audio|video)/.test(section)) {\n      return section;\n    }\n    var kind = section.match(/^m=(audio|video)/)[1];\n    var codecMap = createCodecMapForMediaSection(section);\n    var preferredCodecs = kind === 'audio' ? preferredAudioCodecs : preferredVideoCodecs;\n    var payloadTypes = getReorderedPayloadTypes(codecMap, preferredCodecs);\n    var newSection = setPayloadTypesInMediaSection(payloadTypes, section);\n    var pcmaPayloadTypes = codecMap.get('pcma') || [];\n    var pcmuPayloadTypes = codecMap.get('pcmu') || [];\n    var fixedBitratePayloadTypes = kind === 'audio' ? new Set(pcmaPayloadTypes.concat(pcmuPayloadTypes)) : new Set();\n    return fixedBitratePayloadTypes.has(payloadTypes[0]) ? newSection.replace(/\\r\\nb=(AS|TIAS):([0-9]+)/g, '') : newSection;\n  })).join('\\r\\n');\n}\n/**\n * Return a new SDP string with simulcast settings.\n * @param {string} sdp\n * @param {Map<Track.ID, TrackAttributes>} trackIdsToAttributes\n * @returns {string} Updated SDP string\n */\nfunction setSimulcast(sdp, trackIdsToAttributes) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    section = section.replace(/\\r\\n$/, '');\n    if (!/^m=video/.test(section)) {\n      return section;\n    }\n    var codecMap = createCodecMapForMediaSection(section);\n    var payloadTypes = getPayloadTypesInMediaSection(section);\n    var vp8PayloadTypes = new Set(codecMap.get('vp8') || []);\n    var hasVP8PayloadType = payloadTypes.some(function (payloadType) {\n      return vp8PayloadTypes.has(payloadType);\n    });\n    return hasVP8PayloadType ? setSimulcastInMediaSection(section, trackIdsToAttributes) : section;\n  })).concat('').join('\\r\\n');\n}\n/**\n * Get the matching Payload Types in an m= section for a particular peer codec.\n * @param {Codec} peerCodec\n * @param {PT} peerPt\n * @param {Map<Codec, PT>} codecsToPts\n * @param {string} section\n * @param {string} peerSection\n * @returns {Array<PT>}\n */\nfunction getMatchingPayloadTypes(peerCodec, peerPt, codecsToPts, section, peerSection) {\n  // If there is at most one local Payload Type that matches the remote codec, retain it.\n  var matchingPts = codecsToPts.get(peerCodec) || [];\n  if (matchingPts.length <= 1) {\n    return matchingPts;\n  }\n  // If there are no fmtp attributes for the codec in the peer m= section, then we\n  // cannot get a match in the  m= section. In that case, retain all matching Payload\n  // Types.\n  var peerFmtpAttrs = getFmtpAttributesForPt(peerPt, peerSection);\n  if (!peerFmtpAttrs) {\n    return matchingPts;\n  }\n  // Among the matched local Payload Types, find the one that matches the remote\n  // fmtp attributes.\n  var matchingPt = matchingPts.find(function (pt) {\n    var fmtpAttrs = getFmtpAttributesForPt(pt, section);\n    return fmtpAttrs && Object.keys(peerFmtpAttrs).every(function (attr) {\n      return peerFmtpAttrs[attr] === fmtpAttrs[attr];\n    });\n  });\n  // If none of the matched Payload Types also have matching fmtp attributes,\n  // then retain all of them, otherwise retain only the Payload Type that\n  // matches the peer fmtp attributes.\n  return typeof matchingPt === 'number' ? [matchingPt] : matchingPts;\n}\n/**\n * Filter codecs in an m= section based on its peer m= section from the other peer.\n * @param {string} section\n * @param {Map<string, string>} peerMidsToMediaSections\n * @param {Array<string>} codecsToRemove\n * @returns {string}\n */\nfunction filterCodecsInMediaSection(section, peerMidsToMediaSections, codecsToRemove) {\n  // Do nothing if the m= section represents neither audio nor video.\n  if (!/^m=(audio|video)/.test(section)) {\n    return section;\n  }\n  // Do nothing if the m= section does not have an equivalent remote m= section.\n  var mid = getMidForMediaSection(section);\n  var peerSection = mid && peerMidsToMediaSections.get(mid);\n  if (!peerSection) {\n    return section;\n  }\n  // Construct a Map of the peer Payload Types to their codec names.\n  var peerPtToCodecs = createPtToCodecName(peerSection);\n  // Construct a Map of the codec names to their Payload Types.\n  var codecsToPts = createCodecMapForMediaSection(section);\n  // Maintain a list of non-rtx Payload Types to retain.\n  var pts = flatMap(Array.from(peerPtToCodecs), function (_a) {\n    var _b = __read(_a, 2),\n      peerPt = _b[0],\n      peerCodec = _b[1];\n    return peerCodec !== 'rtx' && !codecsToRemove.includes(peerCodec) ? getMatchingPayloadTypes(peerCodec, peerPt, codecsToPts, section, peerSection) : [];\n  });\n  // For each Payload Type that will be retained, retain their corresponding rtx\n  // Payload Type if present.\n  var rtxPts = codecsToPts.get('rtx') || [];\n  // In \"a=fmtp:<rtxPt> apt=<apt>\", extract the codec PT <apt> associated with rtxPt.\n  pts = pts.concat(rtxPts.filter(function (rtxPt) {\n    var fmtpAttrs = getFmtpAttributesForPt(rtxPt, section);\n    return fmtpAttrs && pts.includes(fmtpAttrs.apt);\n  }));\n  // Filter out the below mentioned attribute lines in the m= section that do not\n  // belong to one of the Payload Types that are to be retained.\n  // 1. \"a=rtpmap:<pt> <codec>\"\n  // 2. \"a=rtcp-fb:<pt> <attr>[ <attr>]*\"\n  // 3. \"a=fmtp:<pt> <name>=<value>[;<name>=<value>]*\"\n  var lines = section.split('\\r\\n').filter(function (line) {\n    var ptMatches = line.match(/^a=(rtpmap|fmtp|rtcp-fb):(.+) .+$/);\n    var pt = ptMatches && ptMatches[2];\n    return !ptMatches || pt && pts.includes(parseInt(pt, 10));\n  });\n  // Filter the list of Payload Types in the first line of the m= section.\n  var orderedPts = getPayloadTypesInMediaSection(section).filter(function (pt) {\n    return pts.includes(pt);\n  });\n  return setPayloadTypesInMediaSection(orderedPts, lines.join('\\r\\n'));\n}\n/**\n * Filter local codecs based on the remote SDP.\n * @param {string} localSdp\n * @param {string} remoteSdp\n * @returns {string} - Updated local SDP\n */\nfunction filterLocalCodecs(localSdp, remoteSdp) {\n  var localMediaSections = getMediaSections(localSdp);\n  var localSession = localSdp.split('\\r\\nm=')[0];\n  var remoteMidsToMediaSections = createMidToMediaSectionMap(remoteSdp);\n  return [localSession].concat(localMediaSections.map(function (localSection) {\n    return filterCodecsInMediaSection(localSection, remoteMidsToMediaSections, []);\n  })).join('\\r\\n');\n}\n/**\n * Return a new SDP string after reverting simulcast for non vp8 sections in remote sdp.\n * @param localSdp - simulcast enabled local sdp\n * @param localSdpWithoutSimulcast - local sdp before simulcast was set\n * @param remoteSdp - remote sdp\n * @param revertForAll - when true simulcast will be reverted for all codecs. when false it will be reverted\n *  only for non-vp8 codecs.\n * @return {string} Updated SDP string\n */\nfunction revertSimulcast(localSdp, localSdpWithoutSimulcast, remoteSdp, revertForAll) {\n  if (revertForAll === void 0) {\n    revertForAll = false;\n  }\n  var remoteMidToMediaSections = createMidToMediaSectionMap(remoteSdp);\n  var localMidToMediaSectionsWithoutSimulcast = createMidToMediaSectionMap(localSdpWithoutSimulcast);\n  var mediaSections = getMediaSections(localSdp);\n  var session = localSdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    section = section.replace(/\\r\\n$/, '');\n    if (!/^m=video/.test(section)) {\n      return section;\n    }\n    var midMatches = section.match(/^a=mid:(.+)$/m);\n    var mid = midMatches && midMatches[1];\n    if (!mid) {\n      return section;\n    }\n    var remoteSection = remoteMidToMediaSections.get(mid);\n    var remotePtToCodecs = createPtToCodecName(remoteSection);\n    var remotePayloadTypes = getPayloadTypesInMediaSection(remoteSection);\n    var isVP8ThePreferredCodec = remotePayloadTypes.length && remotePtToCodecs.get(remotePayloadTypes[0]) === 'vp8';\n    var shouldRevertSimulcast = revertForAll || !isVP8ThePreferredCodec;\n    return shouldRevertSimulcast ? localMidToMediaSectionsWithoutSimulcast.get(mid).replace(/\\r\\n$/, '') : section;\n  })).concat('').join('\\r\\n');\n}\n/**\n * Add or rewrite MSIDs for new m= sections in the given SDP with their corresponding\n * local MediaStreamTrack IDs. These can be different when previously removed MediaStreamTracks\n * are added back (or Track IDs may not be present in the SDPs at all once browsers implement\n * the latest WebRTC spec).\n * @param {string} sdp\n * @param {Map<string, Track.ID>} activeMidsToTrackIds\n * @param {Map<Track.Kind, Array<Track.ID>>} trackIdsByKind\n * @returns {string}\n */\nfunction addOrRewriteNewTrackIds(sdp, activeMidsToTrackIds, trackIdsByKind) {\n  // NOTE(mmalavalli): The m= sections for the new MediaStreamTracks are usually\n  // present after the m= sections for the existing MediaStreamTracks, in order\n  // of addition.\n  var newMidsToTrackIds = Array.from(trackIdsByKind).reduce(function (midsToTrackIds, _a) {\n    var _b = __read(_a, 2),\n      kind = _b[0],\n      trackIds = _b[1];\n    var mediaSections = getMediaSections(sdp, kind, 'send(only|recv)');\n    var newMids = mediaSections.map(getMidForMediaSection).filter(function (mid) {\n      return !activeMidsToTrackIds.has(mid);\n    });\n    newMids.forEach(function (mid, i) {\n      return midsToTrackIds.set(mid, trackIds[i]);\n    });\n    return midsToTrackIds;\n  }, new Map());\n  return addOrRewriteTrackIds(sdp, newMidsToTrackIds);\n}\n/**\n * Add or rewrite MSIDs in the given SDP with their corresponding local MediaStreamTrack IDs.\n * These IDs need not be the same (or Track IDs may not be present in the SDPs at all once\n * browsers implement the latest WebRTC spec).\n * @param {string} sdp\n * @param {Map<string, Track.ID>} midsToTrackIds\n * @returns {string}\n */\nfunction addOrRewriteTrackIds(sdp, midsToTrackIds) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (mediaSection) {\n    // Do nothing if the m= section represents neither audio nor video.\n    if (!/^m=(audio|video)/.test(mediaSection)) {\n      return mediaSection;\n    }\n    // This shouldn't happen, but in case there is no MID for the m= section, do nothing.\n    var mid = getMidForMediaSection(mediaSection);\n    if (!mid) {\n      return mediaSection;\n    }\n    // In case there is no Track ID for the given MID in the map, do nothing.\n    var trackId = midsToTrackIds.get(mid);\n    if (!trackId) {\n      return mediaSection;\n    }\n    // This shouldn't happen, but in case there is no a=msid: line, do nothing.\n    var attributes = (mediaSection.match(/^a=msid:(.+)$/m) || [])[1];\n    if (!attributes) {\n      return mediaSection;\n    }\n    // If the a=msid: line contains the \"appdata\" field, then replace it with the Track ID,\n    // otherwise append the Track ID.\n    var _a = __read(attributes.split(' '), 2),\n      msid = _a[0],\n      trackIdToRewrite = _a[1];\n    var msidRegex = new RegExp(\"msid:\" + msid + (trackIdToRewrite ? \" \" + trackIdToRewrite : '') + \"$\", 'gm');\n    return mediaSection.replace(msidRegex, \"msid:\" + msid + \" \" + trackId);\n  })).join('\\r\\n');\n}\n/**\n * Removes specified ssrc attributes from given sdp.\n * @param {string} sdp\n * @param {Array<string>} ssrcAttributesToRemove\n * @returns {string}\n */\nfunction removeSSRCAttributes(sdp, ssrcAttributesToRemove) {\n  return sdp.split('\\r\\n').filter(function (line) {\n    return !ssrcAttributesToRemove.find(function (srcAttribute) {\n      return new RegExp('a=ssrc:.*' + srcAttribute + ':', 'g').test(line);\n    });\n  }).join('\\r\\n');\n}\n/**\n * Disable RTX in a given sdp.\n * @param {string} sdp\n * @returns {string} sdp without RTX\n */\nfunction disableRtx(sdp) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (mediaSection) {\n    // Do nothing if the m= section does not represent a video track.\n    if (!/^m=video/.test(mediaSection)) {\n      return mediaSection;\n    }\n    // Create a map of codecs to payload types.\n    var codecsToPts = createCodecMapForMediaSection(mediaSection);\n    // Get the RTX payload types.\n    var rtxPts = codecsToPts.get('rtx');\n    // Do nothing if there are no RTX payload types.\n    if (!rtxPts) {\n      return mediaSection;\n    }\n    // Remove the RTX payload types.\n    var pts = new Set(getPayloadTypesInMediaSection(mediaSection));\n    rtxPts.forEach(function (rtxPt) {\n      return pts.delete(rtxPt);\n    });\n    // Get the RTX SSRC.\n    var rtxSSRCMatches = mediaSection.match(/a=ssrc-group:FID [0-9]+ ([0-9]+)/);\n    var rtxSSRC = rtxSSRCMatches && rtxSSRCMatches[1];\n    // Remove the following lines associated with the RTX payload types:\n    // 1. \"a=fmtp:<rtxPt> apt=<pt>\"\n    // 2. \"a=rtpmap:<rtxPt> rtx/...\"\n    // 3. \"a=ssrc:<rtxSSRC> cname:...\"\n    // 4. \"a=ssrc-group:FID <SSRC> <rtxSSRC>\"\n    var filterRegexes = [/^a=fmtp:.+ apt=.+$/, /^a=rtpmap:.+ rtx\\/.+$/, /^a=ssrc-group:.+$/].concat(rtxSSRC ? [new RegExp(\"^a=ssrc:\" + rtxSSRC + \" .+$\")] : []);\n    mediaSection = mediaSection.split('\\r\\n').filter(function (line) {\n      return filterRegexes.every(function (regex) {\n        return !regex.test(line);\n      });\n    }).join('\\r\\n');\n    // Reconstruct the m= section without the RTX payload types.\n    return setPayloadTypesInMediaSection(Array.from(pts), mediaSection);\n  })).join('\\r\\n');\n}\n/**\n * Generate an a=fmtp: line from the given payload type and attributes.\n * @param {PT} pt\n * @param {*} fmtpAttrs\n * @returns {string}\n */\nfunction generateFmtpLineFromPtAndAttributes(pt, fmtpAttrs) {\n  var serializedFmtpAttrs = Object.entries(fmtpAttrs).map(function (_a) {\n    var _b = __read(_a, 2),\n      name = _b[0],\n      value = _b[1];\n    return name + \"=\" + value;\n  }).join(';');\n  return \"a=fmtp:\" + pt + \" \" + serializedFmtpAttrs;\n}\n/**\n * Enable DTX for opus in the m= sections for the given MIDs.`\n * @param {string} sdp\n * @param {Array<string>} [mids] - If not specified, enables opus DTX for all\n *   audio m= lines.\n * @returns {string}\n */\nfunction enableDtxForOpus(sdp, mids) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  mids = mids || mediaSections.filter(function (section) {\n    return /^m=audio/.test(section);\n  }).map(getMidForMediaSection);\n  return [session].concat(mediaSections.map(function (section) {\n    // Do nothing if the m= section is not audio.\n    if (!/^m=audio/.test(section)) {\n      return section;\n    }\n    // Build a map codecs to payload types.\n    var codecsToPts = createCodecMapForMediaSection(section);\n    // Do nothing if a payload type for opus does not exist.\n    var opusPt = codecsToPts.get('opus');\n    if (!opusPt) {\n      return section;\n    }\n    // If no fmtp attributes are found for opus, do nothing.\n    var opusFmtpAttrs = getFmtpAttributesForPt(opusPt, section);\n    if (!opusFmtpAttrs) {\n      return section;\n    }\n    // Add usedtx=1 to the a=fmtp: line for opus.\n    var origOpusFmtpLine = generateFmtpLineFromPtAndAttributes(opusPt, opusFmtpAttrs);\n    var origOpusFmtpRegex = new RegExp(origOpusFmtpLine);\n    // If the m= section's MID is in the list of MIDs, then enable dtx. Otherwise disable it.\n    var mid = getMidForMediaSection(section);\n    if (mids.includes(mid)) {\n      opusFmtpAttrs.usedtx = 1;\n    } else {\n      delete opusFmtpAttrs.usedtx;\n    }\n    var opusFmtpLineWithDtx = generateFmtpLineFromPtAndAttributes(opusPt, opusFmtpAttrs);\n    return section.replace(origOpusFmtpRegex, opusFmtpLineWithDtx);\n  })).join('\\r\\n');\n}\nexports.addOrRewriteNewTrackIds = addOrRewriteNewTrackIds;\nexports.addOrRewriteTrackIds = addOrRewriteTrackIds;\nexports.createCodecMapForMediaSection = createCodecMapForMediaSection;\nexports.createPtToCodecName = createPtToCodecName;\nexports.disableRtx = disableRtx;\nexports.enableDtxForOpus = enableDtxForOpus;\nexports.filterLocalCodecs = filterLocalCodecs;\nexports.getMediaSections = getMediaSections;\nexports.removeSSRCAttributes = removeSSRCAttributes;\nexports.revertSimulcast = revertSimulcast;\nexports.setCodecPreferences = setCodecPreferences;\nexports.setSimulcast = setSimulcast;","map":{"version":3,"names":["_a","require","difference","flatMap","setSimulcastInMediaSection","ptToFixedBitrateAudioCodecName","createCodecMapForMediaSection","section","Array","from","createPtToCodecName","reduce","codecMap","pair","pt","codecName","pts","get","set","concat","Map","createMidToMediaSectionMap","sdp","getMediaSections","midsToMediaSections","mediaSection","mid","getMidForMediaSection","getPayloadTypesInMediaSection","ptToCodecName","rtpmapPattern","RegExp","matches","match","toLowerCase","getFmtpAttributesForPt","fmtpRegex","split","attrs","nvPair","__read","name","value","isNaN","parseInt","midMatches","kind","direction","replace","slice","map","filter","kindPattern","directionPattern","test","mLine","getReorderedPayloadTypes","preferredCodecs","codec","preferredPayloadTypes","remainingCodecs","keys","remainingPayloadTypes","setPayloadTypesInMediaSection","payloadTypes","lines","otherLines","join","setCodecPreferences","preferredAudioCodecs","preferredVideoCodecs","mediaSections","session","newSection","pcmaPayloadTypes","pcmuPayloadTypes","fixedBitratePayloadTypes","Set","has","setSimulcast","trackIdsToAttributes","vp8PayloadTypes","hasVP8PayloadType","some","payloadType","getMatchingPayloadTypes","peerCodec","peerPt","codecsToPts","peerSection","matchingPts","length","peerFmtpAttrs","matchingPt","find","fmtpAttrs","Object","every","attr","filterCodecsInMediaSection","peerMidsToMediaSections","codecsToRemove","peerPtToCodecs","_b","includes","rtxPts","rtxPt","apt","line","ptMatches","orderedPts","filterLocalCodecs","localSdp","remoteSdp","localMediaSections","localSession","remoteMidsToMediaSections","localSection","revertSimulcast","localSdpWithoutSimulcast","revertForAll","remoteMidToMediaSections","localMidToMediaSectionsWithoutSimulcast","remoteSection","remotePtToCodecs","remotePayloadTypes","isVP8ThePreferredCodec","shouldRevertSimulcast","addOrRewriteNewTrackIds","activeMidsToTrackIds","trackIdsByKind","newMidsToTrackIds","midsToTrackIds","trackIds","newMids","forEach","i","addOrRewriteTrackIds","trackId","attributes","msid","trackIdToRewrite","msidRegex","removeSSRCAttributes","ssrcAttributesToRemove","srcAttribute","disableRtx","delete","rtxSSRCMatches","rtxSSRC","filterRegexes","regex","generateFmtpLineFromPtAndAttributes","serializedFmtpAttrs","entries","enableDtxForOpus","mids","opusPt","opusFmtpAttrs","origOpusFmtpLine","origOpusFmtpRegex","usedtx","opusFmtpLineWithDtx","exports"],"sources":["/home/denis/RiderProjects/ChatRoulette/WebUI/chat-app/node_modules/twilio-video/lib/util/sdp/index.js"],"sourcesContent":["'use strict';\n\nconst { difference, flatMap } = require('../');\nconst setSimulcastInMediaSection = require('./simulcast');\n\nconst ptToFixedBitrateAudioCodecName = {\n  0: 'PCMU',\n  8: 'PCMA'\n};\n\n/**\n * A payload type\n * @typedef {number} PT\n */\n\n/**\n * An {@link AudioCodec} or {@link VideoCodec}\n * @typedef {AudioCodec|VideoCodec} Codec\n */\n\n/**\n * Create a Codec Map for the given m= section.\n * @param {string} section - The given m= section\n * @returns {Map<Codec, Array<PT>>}\n */\nfunction createCodecMapForMediaSection(section) {\n  return Array.from(createPtToCodecName(section)).reduce((codecMap, pair) => {\n    const pt = pair[0];\n    const codecName = pair[1];\n    const pts = codecMap.get(codecName) || [];\n    return codecMap.set(codecName, pts.concat(pt));\n  }, new Map());\n}\n\n/**\n * Create a Map of MIDs to m= sections for the given SDP.\n * @param {string} sdp\n * @returns {Map<string, string>}\n */\nfunction createMidToMediaSectionMap(sdp) {\n  return getMediaSections(sdp).reduce((midsToMediaSections, mediaSection) => {\n    const mid = getMidForMediaSection(mediaSection);\n    return mid ? midsToMediaSections.set(mid, mediaSection) : midsToMediaSections;\n  }, new Map());\n}\n\n/**\n * Create a Map from PTs to codec names for the given m= section.\n * @param {string} mediaSection - The given m= section.\n * @returns {Map<PT, Codec>} ptToCodecName\n */\nfunction createPtToCodecName(mediaSection) {\n  return getPayloadTypesInMediaSection(mediaSection).reduce((ptToCodecName, pt) => {\n    const rtpmapPattern = new RegExp(`a=rtpmap:${pt} ([^/]+)`);\n    const matches = mediaSection.match(rtpmapPattern);\n    const codecName = matches\n      ? matches[1].toLowerCase()\n      : ptToFixedBitrateAudioCodecName[pt]\n        ? ptToFixedBitrateAudioCodecName[pt].toLowerCase()\n        : '';\n    return ptToCodecName.set(pt, codecName);\n  }, new Map());\n}\n\n/**\n * Get the associated fmtp attributes for the given Payload Type in an m= section.\n * @param {PT} pt\n * @param {string} mediaSection\n * @returns {?object}\n */\nfunction getFmtpAttributesForPt(pt, mediaSection) {\n  // In \"a=fmtp:<pt> <name>=<value>[;<name>=<value>]*\", the regex matches the codec\n  // profile parameters expressed as name/value pairs separated by \";\".\n  const fmtpRegex = new RegExp(`^a=fmtp:${pt} (.+)$`, 'm');\n  const matches = mediaSection.match(fmtpRegex);\n  return matches && matches[1].split(';').reduce((attrs, nvPair) => {\n    const [name, value] = nvPair.split('=');\n    attrs[name] = isNaN(value) ? value : parseInt(value, 10);\n    return attrs;\n  }, {});\n}\n\n/**\n * Get the MID for the given m= section.\n * @param {string} mediaSection\n * @return {?string}\n */\nfunction getMidForMediaSection(mediaSection) {\n  // In \"a=mid:<mid>\", the regex matches <mid>.\n  const midMatches = mediaSection.match(/^a=mid:(.+)$/m);\n  return midMatches && midMatches[1];\n}\n\n/**\n * Get the m= sections of a particular kind and direction from an sdp.\n * @param {string} sdp - SDP string\n * @param {string} [kind] - Pattern for matching kind\n * @param {string} [direction] - Pattern for matching direction\n * @returns {Array<string>} mediaSections\n */\nfunction getMediaSections(sdp, kind, direction) {\n  return sdp.replace(/\\r\\n\\r\\n$/, '\\r\\n').split('\\r\\nm=').slice(1).map(mediaSection => `m=${mediaSection}`).filter(mediaSection => {\n    const kindPattern = new RegExp(`m=${kind || '.*'}`, 'gm');\n    const directionPattern = new RegExp(`a=${direction || '.*'}`, 'gm');\n    return kindPattern.test(mediaSection) && directionPattern.test(mediaSection);\n  });\n}\n\n/**\n * Get the Codec Payload Types present in the first line of the given m= section\n * @param {string} section - The m= section\n * @returns {Array<PT>} Payload Types\n */\nfunction getPayloadTypesInMediaSection(section) {\n  const mLine = section.split('\\r\\n')[0];\n\n  // In \"m=<kind> <port> <proto> <payload_type_1> <payload_type_2> ... <payload_type_n>\",\n  // the regex matches <port> and the Payload Types.\n  const matches = mLine.match(/([0-9]+)/g);\n\n  // This should not happen, but in case there are no Payload Types in\n  // the m= line, return an empty array.\n  if (!matches) {\n    return [];\n  }\n\n  // Since only the Payload Types are needed, we discard the <port>.\n  return matches.slice(1).map(match => parseInt(match, 10));\n}\n\n/**\n * Create the reordered Codec Payload Types based on the preferred Codec Names.\n * @param {Map<Codec, Array<PT>>} codecMap - Codec Map\n * @param {Array<AudioCodecSettings|VideoCodecSettings>} preferredCodecs - Preferred Codecs\n * @returns {Array<PT>} Reordered Payload Types\n */\nfunction getReorderedPayloadTypes(codecMap, preferredCodecs) {\n  preferredCodecs = preferredCodecs.map(({ codec }) => codec.toLowerCase());\n  const preferredPayloadTypes = flatMap(preferredCodecs, codecName => codecMap.get(codecName) || []);\n  const remainingCodecs = difference(Array.from(codecMap.keys()), preferredCodecs);\n  const remainingPayloadTypes = flatMap(remainingCodecs, codecName => codecMap.get(codecName));\n  return preferredPayloadTypes.concat(remainingPayloadTypes);\n}\n\n/**\n * Set the given Codec Payload Types in the first line of the given m= section.\n * @param {Array<PT>} payloadTypes - Payload Types\n * @param {string} section - Given m= section\n * @returns {string} - Updated m= section\n */\nfunction setPayloadTypesInMediaSection(payloadTypes, section) {\n  const lines = section.split('\\r\\n');\n  let mLine = lines[0];\n  const otherLines = lines.slice(1);\n  mLine = mLine.replace(/([0-9]+\\s?)+$/, payloadTypes.join(' '));\n  return [mLine].concat(otherLines).join('\\r\\n');\n}\n\n/**\n * Return a new SDP string with the re-ordered codec preferences.\n * @param {string} sdp\n * @param {Array<AudioCodec>} preferredAudioCodecs - If empty, the existing order\n *   of audio codecs is preserved\n * @param {Array<VideoCodecSettings>} preferredVideoCodecs - If empty, the\n *   existing order of video codecs is preserved\n * @returns {string} Updated SDP string\n */\nfunction setCodecPreferences(sdp, preferredAudioCodecs, preferredVideoCodecs) {\n  const mediaSections = getMediaSections(sdp);\n  const session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(section => {\n    // Codec preferences should not be applied to m=application sections.\n    if (!/^m=(audio|video)/.test(section)) {\n      return section;\n    }\n    const kind = section.match(/^m=(audio|video)/)[1];\n    const codecMap = createCodecMapForMediaSection(section);\n    const preferredCodecs = kind === 'audio' ? preferredAudioCodecs : preferredVideoCodecs;\n    const payloadTypes = getReorderedPayloadTypes(codecMap, preferredCodecs);\n    const newSection = setPayloadTypesInMediaSection(payloadTypes, section);\n\n    const pcmaPayloadTypes = codecMap.get('pcma') || [];\n    const pcmuPayloadTypes = codecMap.get('pcmu') || [];\n    const fixedBitratePayloadTypes = kind === 'audio'\n      ? new Set(pcmaPayloadTypes.concat(pcmuPayloadTypes))\n      : new Set();\n\n    return fixedBitratePayloadTypes.has(payloadTypes[0])\n      ? newSection.replace(/\\r\\nb=(AS|TIAS):([0-9]+)/g, '')\n      : newSection;\n  })).join('\\r\\n');\n}\n\n/**\n * Return a new SDP string with simulcast settings.\n * @param {string} sdp\n * @param {Map<Track.ID, TrackAttributes>} trackIdsToAttributes\n * @returns {string} Updated SDP string\n */\nfunction setSimulcast(sdp, trackIdsToAttributes) {\n  const mediaSections = getMediaSections(sdp);\n  const session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(section => {\n    section = section.replace(/\\r\\n$/, '');\n    if (!/^m=video/.test(section)) {\n      return section;\n    }\n    const codecMap = createCodecMapForMediaSection(section);\n    const payloadTypes = getPayloadTypesInMediaSection(section);\n    const vp8PayloadTypes = new Set(codecMap.get('vp8') || []);\n\n    const hasVP8PayloadType = payloadTypes.some(payloadType => vp8PayloadTypes.has(payloadType));\n    return hasVP8PayloadType\n      ? setSimulcastInMediaSection(section, trackIdsToAttributes)\n      : section;\n  })).concat('').join('\\r\\n');\n}\n\n/**\n * Get the matching Payload Types in an m= section for a particular peer codec.\n * @param {Codec} peerCodec\n * @param {PT} peerPt\n * @param {Map<Codec, PT>} codecsToPts\n * @param {string} section\n * @param {string} peerSection\n * @returns {Array<PT>}\n */\nfunction getMatchingPayloadTypes(peerCodec, peerPt, codecsToPts, section, peerSection) {\n  // If there is at most one local Payload Type that matches the remote codec, retain it.\n  const matchingPts = codecsToPts.get(peerCodec) || [];\n  if (matchingPts.length <= 1) {\n    return matchingPts;\n  }\n\n  // If there are no fmtp attributes for the codec in the peer m= section, then we\n  // cannot get a match in the  m= section. In that case, retain all matching Payload\n  // Types.\n  const peerFmtpAttrs = getFmtpAttributesForPt(peerPt, peerSection);\n  if (!peerFmtpAttrs) {\n    return matchingPts;\n  }\n\n  // Among the matched local Payload Types, find the one that matches the remote\n  // fmtp attributes.\n  const matchingPt = matchingPts.find(pt => {\n    const fmtpAttrs = getFmtpAttributesForPt(pt, section);\n    return fmtpAttrs && Object.keys(peerFmtpAttrs).every(attr => {\n      return peerFmtpAttrs[attr] === fmtpAttrs[attr];\n    });\n  });\n\n  // If none of the matched Payload Types also have matching fmtp attributes,\n  // then retain all of them, otherwise retain only the Payload Type that\n  // matches the peer fmtp attributes.\n  return typeof matchingPt === 'number' ? [matchingPt] : matchingPts;\n}\n\n/**\n * Filter codecs in an m= section based on its peer m= section from the other peer.\n * @param {string} section\n * @param {Map<string, string>} peerMidsToMediaSections\n * @param {Array<string>} codecsToRemove\n * @returns {string}\n */\nfunction filterCodecsInMediaSection(section, peerMidsToMediaSections, codecsToRemove) {\n  // Do nothing if the m= section represents neither audio nor video.\n  if (!/^m=(audio|video)/.test(section)) {\n    return section;\n  }\n\n  // Do nothing if the m= section does not have an equivalent remote m= section.\n  const mid = getMidForMediaSection(section);\n  const peerSection = mid && peerMidsToMediaSections.get(mid);\n  if (!peerSection) {\n    return section;\n  }\n\n  // Construct a Map of the peer Payload Types to their codec names.\n  const peerPtToCodecs = createPtToCodecName(peerSection);\n  // Construct a Map of the codec names to their Payload Types.\n  const codecsToPts = createCodecMapForMediaSection(section);\n  // Maintain a list of non-rtx Payload Types to retain.\n  let pts = flatMap(Array.from(peerPtToCodecs), ([peerPt, peerCodec]) =>\n    peerCodec !== 'rtx' && !codecsToRemove.includes(peerCodec)\n      ? getMatchingPayloadTypes(\n        peerCodec,\n        peerPt,\n        codecsToPts,\n        section,\n        peerSection)\n      : []);\n\n  // For each Payload Type that will be retained, retain their corresponding rtx\n  // Payload Type if present.\n  const rtxPts = codecsToPts.get('rtx') || [];\n  // In \"a=fmtp:<rtxPt> apt=<apt>\", extract the codec PT <apt> associated with rtxPt.\n  pts = pts.concat(rtxPts.filter(rtxPt => {\n    const fmtpAttrs = getFmtpAttributesForPt(rtxPt, section);\n    return fmtpAttrs && pts.includes(fmtpAttrs.apt);\n  }));\n\n  // Filter out the below mentioned attribute lines in the m= section that do not\n  // belong to one of the Payload Types that are to be retained.\n  // 1. \"a=rtpmap:<pt> <codec>\"\n  // 2. \"a=rtcp-fb:<pt> <attr>[ <attr>]*\"\n  // 3. \"a=fmtp:<pt> <name>=<value>[;<name>=<value>]*\"\n  const lines = section.split('\\r\\n').filter(line => {\n    const ptMatches = line.match(/^a=(rtpmap|fmtp|rtcp-fb):(.+) .+$/);\n    const pt = ptMatches && ptMatches[2];\n    return !ptMatches || (pt && pts.includes(parseInt(pt, 10)));\n  });\n\n  // Filter the list of Payload Types in the first line of the m= section.\n  const orderedPts = getPayloadTypesInMediaSection(section).filter(pt => pts.includes(pt));\n  return setPayloadTypesInMediaSection(orderedPts, lines.join('\\r\\n'));\n}\n\n/**\n * Filter local codecs based on the remote SDP.\n * @param {string} localSdp\n * @param {string} remoteSdp\n * @returns {string} - Updated local SDP\n */\nfunction filterLocalCodecs(localSdp, remoteSdp) {\n  const localMediaSections = getMediaSections(localSdp);\n  const localSession = localSdp.split('\\r\\nm=')[0];\n  const remoteMidsToMediaSections = createMidToMediaSectionMap(remoteSdp);\n  return [localSession].concat(localMediaSections.map(localSection => {\n    return filterCodecsInMediaSection(localSection, remoteMidsToMediaSections, []);\n  })).join('\\r\\n');\n}\n\n/**\n * Return a new SDP string after reverting simulcast for non vp8 sections in remote sdp.\n * @param localSdp - simulcast enabled local sdp\n * @param localSdpWithoutSimulcast - local sdp before simulcast was set\n * @param remoteSdp - remote sdp\n * @param revertForAll - when true simulcast will be reverted for all codecs. when false it will be reverted\n *  only for non-vp8 codecs.\n * @return {string} Updated SDP string\n */\nfunction revertSimulcast(localSdp, localSdpWithoutSimulcast, remoteSdp, revertForAll = false) {\n  const remoteMidToMediaSections = createMidToMediaSectionMap(remoteSdp);\n  const localMidToMediaSectionsWithoutSimulcast = createMidToMediaSectionMap(localSdpWithoutSimulcast);\n  const mediaSections = getMediaSections(localSdp);\n  const session = localSdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(section => {\n    section = section.replace(/\\r\\n$/, '');\n    if (!/^m=video/.test(section)) {\n      return section;\n    }\n    const midMatches = section.match(/^a=mid:(.+)$/m);\n    const mid = midMatches && midMatches[1];\n    if (!mid) {\n      return section;\n    }\n\n    const remoteSection = remoteMidToMediaSections.get(mid);\n    const remotePtToCodecs = createPtToCodecName(remoteSection);\n    const remotePayloadTypes = getPayloadTypesInMediaSection(remoteSection);\n\n    const isVP8ThePreferredCodec = remotePayloadTypes.length && remotePtToCodecs.get(remotePayloadTypes[0]) === 'vp8';\n    const shouldRevertSimulcast = revertForAll || !isVP8ThePreferredCodec;\n    return shouldRevertSimulcast ? localMidToMediaSectionsWithoutSimulcast.get(mid).replace(/\\r\\n$/, '') : section;\n  })).concat('').join('\\r\\n');\n}\n\n/**\n * Add or rewrite MSIDs for new m= sections in the given SDP with their corresponding\n * local MediaStreamTrack IDs. These can be different when previously removed MediaStreamTracks\n * are added back (or Track IDs may not be present in the SDPs at all once browsers implement\n * the latest WebRTC spec).\n * @param {string} sdp\n * @param {Map<string, Track.ID>} activeMidsToTrackIds\n * @param {Map<Track.Kind, Array<Track.ID>>} trackIdsByKind\n * @returns {string}\n */\nfunction addOrRewriteNewTrackIds(sdp, activeMidsToTrackIds, trackIdsByKind) {\n  // NOTE(mmalavalli): The m= sections for the new MediaStreamTracks are usually\n  // present after the m= sections for the existing MediaStreamTracks, in order\n  // of addition.\n  const newMidsToTrackIds = Array.from(trackIdsByKind).reduce((midsToTrackIds, [kind, trackIds]) => {\n    const mediaSections = getMediaSections(sdp, kind, 'send(only|recv)');\n    const newMids = mediaSections.map(getMidForMediaSection).filter(mid => !activeMidsToTrackIds.has(mid));\n    newMids.forEach((mid, i) => midsToTrackIds.set(mid, trackIds[i]));\n    return midsToTrackIds;\n  }, new Map());\n  return addOrRewriteTrackIds(sdp, newMidsToTrackIds);\n}\n\n/**\n * Add or rewrite MSIDs in the given SDP with their corresponding local MediaStreamTrack IDs.\n * These IDs need not be the same (or Track IDs may not be present in the SDPs at all once\n * browsers implement the latest WebRTC spec).\n * @param {string} sdp\n * @param {Map<string, Track.ID>} midsToTrackIds\n * @returns {string}\n */\nfunction addOrRewriteTrackIds(sdp, midsToTrackIds) {\n  const mediaSections = getMediaSections(sdp);\n  const session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(mediaSection => {\n    // Do nothing if the m= section represents neither audio nor video.\n    if (!/^m=(audio|video)/.test(mediaSection)) {\n      return mediaSection;\n    }\n    // This shouldn't happen, but in case there is no MID for the m= section, do nothing.\n    const mid = getMidForMediaSection(mediaSection);\n    if (!mid) {\n      return mediaSection;\n    }\n    // In case there is no Track ID for the given MID in the map, do nothing.\n    const trackId = midsToTrackIds.get(mid);\n    if (!trackId) {\n      return mediaSection;\n    }\n    // This shouldn't happen, but in case there is no a=msid: line, do nothing.\n    const attributes = (mediaSection.match(/^a=msid:(.+)$/m) || [])[1];\n    if (!attributes) {\n      return mediaSection;\n    }\n    // If the a=msid: line contains the \"appdata\" field, then replace it with the Track ID,\n    // otherwise append the Track ID.\n    const [msid, trackIdToRewrite] = attributes.split(' ');\n    const msidRegex = new RegExp(`msid:${msid}${trackIdToRewrite ? ` ${trackIdToRewrite}` : ''}$`, 'gm');\n    return mediaSection.replace(msidRegex, `msid:${msid} ${trackId}`);\n  })).join('\\r\\n');\n}\n\n/**\n * Removes specified ssrc attributes from given sdp.\n * @param {string} sdp\n * @param {Array<string>} ssrcAttributesToRemove\n * @returns {string}\n */\nfunction removeSSRCAttributes(sdp, ssrcAttributesToRemove) {\n  return sdp.split('\\r\\n').filter(line =>\n    !ssrcAttributesToRemove.find(srcAttribute => new RegExp('a=ssrc:.*' + srcAttribute + ':', 'g').test(line))\n  ).join('\\r\\n');\n}\n\n/**\n * Disable RTX in a given sdp.\n * @param {string} sdp\n * @returns {string} sdp without RTX\n */\nfunction disableRtx(sdp) {\n  const mediaSections = getMediaSections(sdp);\n  const session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(mediaSection => {\n    // Do nothing if the m= section does not represent a video track.\n    if (!/^m=video/.test(mediaSection)) {\n      return mediaSection;\n    }\n\n    // Create a map of codecs to payload types.\n    const codecsToPts = createCodecMapForMediaSection(mediaSection);\n    // Get the RTX payload types.\n    const rtxPts = codecsToPts.get('rtx');\n\n    // Do nothing if there are no RTX payload types.\n    if (!rtxPts) {\n      return mediaSection;\n    }\n\n    // Remove the RTX payload types.\n    const pts = new Set(getPayloadTypesInMediaSection(mediaSection));\n    rtxPts.forEach(rtxPt => pts.delete(rtxPt));\n\n    // Get the RTX SSRC.\n    const rtxSSRCMatches = mediaSection.match(/a=ssrc-group:FID [0-9]+ ([0-9]+)/);\n    const rtxSSRC = rtxSSRCMatches && rtxSSRCMatches[1];\n\n    // Remove the following lines associated with the RTX payload types:\n    // 1. \"a=fmtp:<rtxPt> apt=<pt>\"\n    // 2. \"a=rtpmap:<rtxPt> rtx/...\"\n    // 3. \"a=ssrc:<rtxSSRC> cname:...\"\n    // 4. \"a=ssrc-group:FID <SSRC> <rtxSSRC>\"\n    const filterRegexes = [\n      /^a=fmtp:.+ apt=.+$/,\n      /^a=rtpmap:.+ rtx\\/.+$/,\n      /^a=ssrc-group:.+$/\n    ].concat(rtxSSRC\n      ? [new RegExp(`^a=ssrc:${rtxSSRC} .+$`)]\n      : []);\n\n    mediaSection = mediaSection.split('\\r\\n')\n      .filter(line => filterRegexes.every(regex => !regex.test(line)))\n      .join('\\r\\n');\n\n    // Reconstruct the m= section without the RTX payload types.\n    return setPayloadTypesInMediaSection(Array.from(pts), mediaSection);\n  })).join('\\r\\n');\n}\n\n/**\n * Generate an a=fmtp: line from the given payload type and attributes.\n * @param {PT} pt\n * @param {*} fmtpAttrs\n * @returns {string}\n */\nfunction generateFmtpLineFromPtAndAttributes(pt, fmtpAttrs) {\n  const serializedFmtpAttrs = Object.entries(fmtpAttrs).map(([name, value]) => {\n    return `${name}=${value}`;\n  }).join(';');\n  return `a=fmtp:${pt} ${serializedFmtpAttrs}`;\n}\n\n/**\n * Enable DTX for opus in the m= sections for the given MIDs.`\n * @param {string} sdp\n * @param {Array<string>} [mids] - If not specified, enables opus DTX for all\n *   audio m= lines.\n * @returns {string}\n */\nfunction enableDtxForOpus(sdp, mids) {\n  const mediaSections = getMediaSections(sdp);\n  const session = sdp.split('\\r\\nm=')[0];\n\n  mids = mids || mediaSections\n    .filter(section => /^m=audio/.test(section))\n    .map(getMidForMediaSection);\n\n  return [session].concat(mediaSections.map(section => {\n    // Do nothing if the m= section is not audio.\n    if (!/^m=audio/.test(section)) {\n      return section;\n    }\n\n    // Build a map codecs to payload types.\n    const codecsToPts = createCodecMapForMediaSection(section);\n\n    // Do nothing if a payload type for opus does not exist.\n    const opusPt = codecsToPts.get('opus');\n    if (!opusPt) {\n      return section;\n    }\n\n    // If no fmtp attributes are found for opus, do nothing.\n    const opusFmtpAttrs = getFmtpAttributesForPt(opusPt, section);\n    if (!opusFmtpAttrs) {\n      return section;\n    }\n\n    // Add usedtx=1 to the a=fmtp: line for opus.\n    const origOpusFmtpLine = generateFmtpLineFromPtAndAttributes(opusPt, opusFmtpAttrs);\n    const origOpusFmtpRegex = new RegExp(origOpusFmtpLine);\n\n    // If the m= section's MID is in the list of MIDs, then enable dtx. Otherwise disable it.\n    const mid = getMidForMediaSection(section);\n    if (mids.includes(mid)) {\n      opusFmtpAttrs.usedtx = 1;\n    } else {\n      delete opusFmtpAttrs.usedtx;\n    }\n\n    const opusFmtpLineWithDtx = generateFmtpLineFromPtAndAttributes(opusPt, opusFmtpAttrs);\n    return section.replace(origOpusFmtpRegex, opusFmtpLineWithDtx);\n  })).join('\\r\\n');\n}\n\nexports.addOrRewriteNewTrackIds = addOrRewriteNewTrackIds;\nexports.addOrRewriteTrackIds = addOrRewriteTrackIds;\nexports.createCodecMapForMediaSection = createCodecMapForMediaSection;\nexports.createPtToCodecName = createPtToCodecName;\nexports.disableRtx = disableRtx;\nexports.enableDtxForOpus = enableDtxForOpus;\nexports.filterLocalCodecs = filterLocalCodecs;\nexports.getMediaSections = getMediaSections;\nexports.removeSSRCAttributes = removeSSRCAttributes;\nexports.revertSimulcast = revertSimulcast;\nexports.setCodecPreferences = setCodecPreferences;\nexports.setSimulcast = setSimulcast;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}