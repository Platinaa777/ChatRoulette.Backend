{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nvar guessBrowser = require('../../webrtc/util').guessBrowser;\nvar PeerConnectionV2 = require('./peerconnection');\nvar MediaTrackSender = require('../../media/track/sender');\nvar QueueingEventEmitter = require('../../queueingeventemitter');\nvar util = require('../../util');\nvar MediaConnectionError = require('../../util/twilio-video-errors').MediaConnectionError;\nvar isFirefox = guessBrowser() === 'firefox';\n/**\n * {@link PeerConnectionManager} manages multiple {@link PeerConnectionV2}s.\n * @extends QueueingEventEmitter\n * @emits PeerConnectionManager#candidates\n * @emits PeerConnectionManager#connectionStateChanged\n * @emits PeerConnectionManager#description\n * @emits PeerConnectionManager#iceConnectionStateChanged\n * @emits PeerConnectionManager#trackAdded\n */\nvar PeerConnectionManager = /** @class */function (_super) {\n  __extends(PeerConnectionManager, _super);\n  /**\n   * Construct {@link PeerConnectionManager}.\n   * @param {EncodingParametersImpl} encodingParameters\n   * @param {PreferredCodecs} preferredCodecs\n   * @param {object} options\n   */\n  function PeerConnectionManager(encodingParameters, preferredCodecs, options) {\n    var _this = _super.call(this) || this;\n    options = Object.assign({\n      audioContextFactory: isFirefox ? require('../../webaudio/audiocontext') : null,\n      PeerConnectionV2: PeerConnectionV2\n    }, options);\n    var audioContext = options.audioContextFactory ? options.audioContextFactory.getOrCreate(_this) : null;\n    // NOTE(mroberts): If we're using an AudioContext, we don't need to specify\n    // `offerToReceiveAudio` in RTCOfferOptions.\n    var offerOptions = audioContext ? {\n      offerToReceiveVideo: true\n    } : {\n      offerToReceiveAudio: true,\n      offerToReceiveVideo: true\n    };\n    Object.defineProperties(_this, {\n      _audioContextFactory: {\n        value: options.audioContextFactory\n      },\n      _closedPeerConnectionIds: {\n        value: new Set()\n      },\n      _configuration: {\n        writable: true,\n        value: null\n      },\n      _configurationDeferred: {\n        writable: true,\n        value: util.defer()\n      },\n      _connectionState: {\n        value: 'new',\n        writable: true\n      },\n      _dummyAudioTrackSender: {\n        value: audioContext ? new MediaTrackSender(createDummyAudioMediaStreamTrack(audioContext)) : null\n      },\n      _encodingParameters: {\n        value: encodingParameters\n      },\n      _iceConnectionState: {\n        writable: true,\n        value: 'new'\n      },\n      _dataTrackSenders: {\n        writable: true,\n        value: new Set()\n      },\n      _lastConnectionState: {\n        value: 'new',\n        writable: true\n      },\n      _lastIceConnectionState: {\n        writable: true,\n        value: 'new'\n      },\n      _mediaTrackSenders: {\n        writable: true,\n        value: new Set()\n      },\n      _offerOptions: {\n        value: offerOptions\n      },\n      _peerConnections: {\n        value: new Map()\n      },\n      _preferredCodecs: {\n        value: preferredCodecs\n      },\n      _sessionTimeout: {\n        value: null,\n        writable: true\n      },\n      _PeerConnectionV2: {\n        value: options.PeerConnectionV2\n      }\n    });\n    return _this;\n  }\n  PeerConnectionManager.prototype.setEffectiveAdaptiveSimulcast = function (effectiveAdaptiveSimulcast) {\n    this._peerConnections.forEach(function (pc) {\n      return pc.setEffectiveAdaptiveSimulcast(effectiveAdaptiveSimulcast);\n    });\n    this._preferredCodecs.video.forEach(function (cs) {\n      if ('adaptiveSimulcast' in cs) {\n        cs.adaptiveSimulcast = effectiveAdaptiveSimulcast;\n      }\n    });\n  };\n  Object.defineProperty(PeerConnectionManager.prototype, \"connectionState\", {\n    /**\n     * A summarized RTCPeerConnectionState across all the\n     * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.\n     * @property {RTCPeerConnectionState}\n     */\n    get: function () {\n      return this._connectionState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PeerConnectionManager.prototype, \"iceConnectionState\", {\n    /**\n     * A summarized RTCIceConnectionState across all the\n     * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.\n     * @property {RTCIceConnectionState}\n     */\n    get: function () {\n      return this._iceConnectionState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Close the {@link PeerConnectionV2}s which are no longer relevant.\n   * @param {Array<object>} peerConnectionStates\n   * @returns {this}\n   */\n  PeerConnectionManager.prototype._closeAbsentPeerConnections = function (peerConnectionStates) {\n    var peerConnectionIds = new Set(peerConnectionStates.map(function (peerConnectionState) {\n      return peerConnectionState.id;\n    }));\n    this._peerConnections.forEach(function (peerConnection) {\n      if (!peerConnectionIds.has(peerConnection.id)) {\n        peerConnection._close();\n      }\n    });\n    return this;\n  };\n  /**\n   * Get the {@link PeerConnectionManager}'s configuration.\n   * @private\n   * @returns {Promise<object>}\n   */\n  PeerConnectionManager.prototype._getConfiguration = function () {\n    return this._configurationDeferred.promise;\n  };\n  /**\n   * Get or create a {@link PeerConnectionV2}.\n   * @private\n   * @param {string} id\n   * @param {object} [configuration]\n   * @returns {PeerConnectionV2}\n   */\n  PeerConnectionManager.prototype._getOrCreate = function (id, configuration) {\n    var _this = this;\n    var self = this;\n    var peerConnection = this._peerConnections.get(id);\n    if (!peerConnection) {\n      var PeerConnectionV2_1 = this._PeerConnectionV2;\n      var options = Object.assign({\n        dummyAudioMediaStreamTrack: this._dummyAudioTrackSender ? this._dummyAudioTrackSender.track : null,\n        offerOptions: this._offerOptions\n      }, this._sessionTimeout ? {\n        sessionTimeout: this._sessionTimeout\n      } : {}, configuration);\n      try {\n        peerConnection = new PeerConnectionV2_1(id, this._encodingParameters, this._preferredCodecs, options);\n      } catch (e) {\n        throw new MediaConnectionError();\n      }\n      this._peerConnections.set(peerConnection.id, peerConnection);\n      peerConnection.on('candidates', this.queue.bind(this, 'candidates'));\n      peerConnection.on('description', this.queue.bind(this, 'description'));\n      peerConnection.on('trackAdded', this.queue.bind(this, 'trackAdded'));\n      peerConnection.on('stateChanged', function stateChanged(state) {\n        if (state === 'closed') {\n          peerConnection.removeListener('stateChanged', stateChanged);\n          self._dataTrackSenders.forEach(function (sender) {\n            return peerConnection.removeDataTrackSender(sender);\n          });\n          self._mediaTrackSenders.forEach(function (sender) {\n            return peerConnection.removeMediaTrackSender(sender);\n          });\n          self._peerConnections.delete(peerConnection.id);\n          self._closedPeerConnectionIds.add(peerConnection.id);\n          updateConnectionState(self);\n          updateIceConnectionState(self);\n        }\n      });\n      peerConnection.on('connectionStateChanged', function () {\n        return updateConnectionState(_this);\n      });\n      peerConnection.on('iceConnectionStateChanged', function () {\n        return updateIceConnectionState(_this);\n      });\n      this._dataTrackSenders.forEach(peerConnection.addDataTrackSender, peerConnection);\n      this._mediaTrackSenders.forEach(peerConnection.addMediaTrackSender, peerConnection);\n      updateIceConnectionState(this);\n    }\n    return peerConnection;\n  };\n  /**\n   * Close all the {@link PeerConnectionV2}s in this {@link PeerConnectionManager}.\n   * @returns {this}\n   */\n  PeerConnectionManager.prototype.close = function () {\n    this._peerConnections.forEach(function (peerConnection) {\n      peerConnection.close();\n    });\n    if (this._dummyAudioTrackSender) {\n      this._dummyAudioTrackSender.stop();\n    }\n    if (this._audioContextFactory) {\n      this._audioContextFactory.release(this);\n    }\n    updateIceConnectionState(this);\n    return this;\n  };\n  /**\n   * Create a new {@link PeerConnectionV2} on this {@link PeerConnectionManager}.\n   * Then, create a new offer with the newly-created {@link PeerConnectionV2}.\n   * @return {Promise<this>}\n   */\n  PeerConnectionManager.prototype.createAndOffer = function () {\n    var _this = this;\n    return this._getConfiguration().then(function (configuration) {\n      var id;\n      do {\n        id = util.makeUUID();\n      } while (_this._peerConnections.has(id));\n      return _this._getOrCreate(id, configuration);\n    }).then(function (peerConnection) {\n      return peerConnection.offer();\n    }).then(function () {\n      return _this;\n    });\n  };\n  /**\n   * Get the {@link DataTrackReceiver}s and {@link MediaTrackReceiver}s of all\n   * the {@link PeerConnectionV2}s.\n   * @returns {Array<DataTrackReceiver|MediaTrackReceiver>} trackReceivers\n   */\n  PeerConnectionManager.prototype.getTrackReceivers = function () {\n    return util.flatMap(this._peerConnections, function (peerConnection) {\n      return peerConnection.getTrackReceivers();\n    });\n  };\n  /**\n   * Get the states of all {@link PeerConnectionV2}s.\n   * @returns {Array<object>}\n   */\n  PeerConnectionManager.prototype.getStates = function () {\n    var peerConnectionStates = [];\n    this._peerConnections.forEach(function (peerConnection) {\n      var peerConnectionState = peerConnection.getState();\n      if (peerConnectionState) {\n        peerConnectionStates.push(peerConnectionState);\n      }\n    });\n    return peerConnectionStates;\n  };\n  /**\n   * Set the {@link PeerConnectionManager}'s configuration.\n   * @param {object} configuration\n   * @returns {this}\n   */\n  PeerConnectionManager.prototype.setConfiguration = function (configuration) {\n    if (this._configuration) {\n      this._configurationDeferred = util.defer();\n      this._peerConnections.forEach(function (peerConnection) {\n        peerConnection.setConfiguration(configuration);\n      });\n    }\n    this._configuration = configuration;\n    this._configurationDeferred.resolve(configuration);\n    return this;\n  };\n  /**\n   * Set the ICE reconnect timeout period for all {@link PeerConnectionV2}s.\n   * @param {number} period - Period in milliseconds.\n   * @returns {this}\n   */\n  PeerConnectionManager.prototype.setIceReconnectTimeout = function (period) {\n    if (this._sessionTimeout === null) {\n      this._peerConnections.forEach(function (peerConnection) {\n        peerConnection.setIceReconnectTimeout(period);\n      });\n      this._sessionTimeout = period;\n    }\n    return this;\n  };\n  /**\n   * Set the {@link DataTrackSender}s and {@link MediaTrackSender}s on the\n   * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.\n   * @param {Array<DataTrackSender|MediaTrackSender>} trackSenders\n   * @returns {this}\n   */\n  PeerConnectionManager.prototype.setTrackSenders = function (trackSenders) {\n    var dataTrackSenders = new Set(trackSenders.filter(function (trackSender) {\n      return trackSender.kind === 'data';\n    }));\n    var mediaTrackSenders = new Set(trackSenders.filter(function (trackSender) {\n      return trackSender && (trackSender.kind === 'audio' || trackSender.kind === 'video');\n    }));\n    var changes = getTrackSenderChanges(this, dataTrackSenders, mediaTrackSenders);\n    this._dataTrackSenders = dataTrackSenders;\n    this._mediaTrackSenders = mediaTrackSenders;\n    applyTrackSenderChanges(this, changes);\n    return this;\n  };\n  /**\n   * Update the {@link PeerConnectionManager}.\n   * @param {Array<object>} peerConnectionStates\n   * @param {boolean} [synced=false]\n   * @returns {Promise<this>}\n   */\n  PeerConnectionManager.prototype.update = function (peerConnectionStates, synced) {\n    var _this = this;\n    if (synced === void 0) {\n      synced = false;\n    }\n    if (synced) {\n      this._closeAbsentPeerConnections(peerConnectionStates);\n    }\n    return this._getConfiguration().then(function (configuration) {\n      return Promise.all(peerConnectionStates.map(function (peerConnectionState) {\n        if (_this._closedPeerConnectionIds.has(peerConnectionState.id)) {\n          return null;\n        }\n        var peerConnection = _this._getOrCreate(peerConnectionState.id, configuration);\n        return peerConnection.update(peerConnectionState);\n      }));\n    }).then(function () {\n      return _this;\n    });\n  };\n  /**\n   * Get the {@link PeerConnectionManager}'s media statistics.\n   * @returns {Promise.<Map<PeerConnectionV2#id, StandardizedStatsResponse>>}\n   */\n  PeerConnectionManager.prototype.getStats = function () {\n    var peerConnections = Array.from(this._peerConnections.values());\n    return Promise.all(peerConnections.map(function (peerConnection) {\n      return peerConnection.getStats().then(function (response) {\n        return [peerConnection.id, response];\n      });\n    })).then(function (responses) {\n      return new Map(responses);\n    });\n  };\n  return PeerConnectionManager;\n}(QueueingEventEmitter);\n/**\n * Create a dummy audio MediaStreamTrack with the given AudioContext.\n * @private\n * @param {AudioContext} audioContext\n * @return {MediaStreamTrack}\n */\nfunction createDummyAudioMediaStreamTrack(audioContext) {\n  var mediaStreamDestination = audioContext.createMediaStreamDestination();\n  return mediaStreamDestination.stream.getAudioTracks()[0];\n}\n/**\n * @event {PeerConnectionManager#candidates}\n * @param {object} candidates\n */\n/**\n * @event {PeerConnectionManager#connectionStateChanged}\n */\n/**\n * @event {PeerConnectionManager#description}\n * @param {object} description\n */\n/**\n * @event {PeerConnectionManager#iceConnectionStateChanged}\n */\n/**\n * @event {PeerConnectionManager#trackAdded}\n * @param {MediaStreamTrack|DataTrackReceiver} mediaStreamTrackOrDataTrackReceiver\n */\n/**\n * Apply {@link TrackSenderChanges}.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {TrackSenderChanges} changes\n * @returns {void}\n */\nfunction applyTrackSenderChanges(peerConnectionManager, changes) {\n  if (changes.data.add.size || changes.data.remove.size || changes.media.add.size || changes.media.remove.size) {\n    peerConnectionManager._peerConnections.forEach(function (peerConnection) {\n      changes.data.remove.forEach(peerConnection.removeDataTrackSender, peerConnection);\n      changes.media.remove.forEach(peerConnection.removeMediaTrackSender, peerConnection);\n      changes.data.add.forEach(peerConnection.addDataTrackSender, peerConnection);\n      changes.media.add.forEach(peerConnection.addMediaTrackSender, peerConnection);\n      if (changes.media.add.size || changes.media.remove.size || changes.data.add.size && !peerConnection.isApplicationSectionNegotiated) {\n        peerConnection.offer();\n      }\n    });\n  }\n}\n/**\n * @interface DataTrackSenderChanges\n * @property {Set<DataTrackSender>} add\n * @property {Set<DataTrackSender>} remove\n */\n/**\n * Get the {@Link DataTrackSender} changes.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {Array<DataTrackSender>} dataTrackSenders\n * @returns {DataTrackSenderChanges} changes\n */\nfunction getDataTrackSenderChanges(peerConnectionManager, dataTrackSenders) {\n  var dataTrackSendersToAdd = util.difference(dataTrackSenders, peerConnectionManager._dataTrackSenders);\n  var dataTrackSendersToRemove = util.difference(peerConnectionManager._dataTrackSenders, dataTrackSenders);\n  return {\n    add: dataTrackSendersToAdd,\n    remove: dataTrackSendersToRemove\n  };\n}\n/**\n * @interface TrackSenderChanges\n * @property {DataTrackSenderChanges} data\n * @property {MediaTrackSenderChanges} media\n */\n/**\n * Get {@link DataTrackSender} and {@link MediaTrackSender} changes.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {Array<DataTrackSender>} dataTrackSenders\n * @param {Array<MediaTrackSender>} mediaTrackSenders\n * @returns {TrackSenderChanges} changes\n */\nfunction getTrackSenderChanges(peerConnectionManager, dataTrackSenders, mediaTrackSenders) {\n  return {\n    data: getDataTrackSenderChanges(peerConnectionManager, dataTrackSenders),\n    media: getMediaTrackSenderChanges(peerConnectionManager, mediaTrackSenders)\n  };\n}\n/**\n * @interface MediaTrackSenderChanges\n * @property {Set<MediaTrackSender>} add\n * @property {Set<MediaTrackSender>} remove\n */\n/**\n * Get the {@link MediaTrackSender} changes.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {Array<MediaTrackSender>} mediaTrackSenders\n * @returns {MediaTrackSenderChanges} changes\n */\nfunction getMediaTrackSenderChanges(peerConnectionManager, mediaTrackSenders) {\n  var mediaTrackSendersToAdd = util.difference(mediaTrackSenders, peerConnectionManager._mediaTrackSenders);\n  var mediaTrackSendersToRemove = util.difference(peerConnectionManager._mediaTrackSenders, mediaTrackSenders);\n  return {\n    add: mediaTrackSendersToAdd,\n    remove: mediaTrackSendersToRemove\n  };\n}\n/**\n * This object maps RTCIceConnectionState and RTCPeerConnectionState values to a \"rank\".\n */\nvar toRank = {\n  new: 0,\n  checking: 1,\n  connecting: 2,\n  connected: 3,\n  completed: 4,\n  disconnected: -1,\n  failed: -2,\n  closed: -3\n};\n/**\n * This object maps \"rank\" back to RTCIceConnectionState or RTCPeerConnectionState values.\n */\nvar fromRank;\n/**\n * `Object.keys` is not supported in older browsers, so we can't just\n * synchronously call it in this module; we need to defer invoking it until we\n * know we're in a modern environment (i.e., anything that supports WebRTC).\n * @returns {object} fromRank\n */\nfunction createFromRank() {\n  return Object.keys(toRank).reduce(function (fromRank, state) {\n    var _a;\n    return Object.assign(fromRank, (_a = {}, _a[toRank[state]] = state, _a));\n  }, {});\n}\n/**\n * Summarize RTCIceConnectionStates or RTCPeerConnectionStates.\n * @param {Array<RTCIceConnectionState>|Array<RTCPeerConnectionState>} states\n * @returns {RTCIceConnectionState|RTCPeerConnectionState} summary\n */\nfunction summarizeIceOrPeerConnectionStates(states) {\n  if (!states.length) {\n    return 'new';\n  }\n  fromRank = fromRank || createFromRank();\n  return states.reduce(function (state1, state2) {\n    return fromRank[Math.max(toRank[state1], toRank[state2])];\n  });\n}\n/**\n * Update the {@link PeerConnectionManager}'s `iceConnectionState`, and emit an\n * \"iceConnectionStateChanged\" event, if necessary.\n * @param {PeerConnectionManager} pcm\n * @returns {void}\n */\nfunction updateIceConnectionState(pcm) {\n  pcm._lastIceConnectionState = pcm.iceConnectionState;\n  pcm._iceConnectionState = summarizeIceOrPeerConnectionStates(__spreadArray([], __read(pcm._peerConnections.values())).map(function (pcv2) {\n    return pcv2.iceConnectionState;\n  }));\n  if (pcm.iceConnectionState !== pcm._lastIceConnectionState) {\n    pcm.emit('iceConnectionStateChanged');\n  }\n}\n/**\n * Update the {@link PeerConnectionManager}'s `connectionState`, and emit a\n * \"connectionStateChanged\" event, if necessary.\n * @param {PeerConnectionManager} pcm\n * @returns {void}\n */\nfunction updateConnectionState(pcm) {\n  pcm._lastConnectionState = pcm.connectionState;\n  pcm._connectionState = summarizeIceOrPeerConnectionStates(__spreadArray([], __read(pcm._peerConnections.values())).map(function (pcv2) {\n    return pcv2.connectionState;\n  }));\n  if (pcm.connectionState !== pcm._lastConnectionState) {\n    pcm.emit('connectionStateChanged');\n  }\n}\nmodule.exports = PeerConnectionManager;","map":{"version":3,"names":["guessBrowser","require","PeerConnectionV2","MediaTrackSender","QueueingEventEmitter","util","MediaConnectionError","isFirefox","PeerConnectionManager","_super","__extends","encodingParameters","preferredCodecs","options","_this","call","Object","assign","audioContextFactory","audioContext","getOrCreate","offerOptions","offerToReceiveVideo","offerToReceiveAudio","defineProperties","_audioContextFactory","value","_closedPeerConnectionIds","Set","_configuration","writable","_configurationDeferred","defer","_connectionState","_dummyAudioTrackSender","createDummyAudioMediaStreamTrack","_encodingParameters","_iceConnectionState","_dataTrackSenders","_lastConnectionState","_lastIceConnectionState","_mediaTrackSenders","_offerOptions","_peerConnections","Map","_preferredCodecs","_sessionTimeout","_PeerConnectionV2","prototype","setEffectiveAdaptiveSimulcast","effectiveAdaptiveSimulcast","forEach","pc","video","cs","adaptiveSimulcast","defineProperty","get","_closeAbsentPeerConnections","peerConnectionStates","peerConnectionIds","map","peerConnectionState","id","peerConnection","has","_close","_getConfiguration","promise","_getOrCreate","configuration","self","PeerConnectionV2_1","dummyAudioMediaStreamTrack","track","sessionTimeout","e","set","on","queue","bind","stateChanged","state","removeListener","sender","removeDataTrackSender","removeMediaTrackSender","delete","add","updateConnectionState","updateIceConnectionState","addDataTrackSender","addMediaTrackSender","close","stop","release","createAndOffer","then","makeUUID","offer","getTrackReceivers","flatMap","getStates","getState","push","setConfiguration","resolve","setIceReconnectTimeout","period","setTrackSenders","trackSenders","dataTrackSenders","filter","trackSender","kind","mediaTrackSenders","changes","getTrackSenderChanges","applyTrackSenderChanges","update","synced","Promise","all","getStats","peerConnections","Array","from","values","response","responses","mediaStreamDestination","createMediaStreamDestination","stream","getAudioTracks","peerConnectionManager","data","size","remove","media","isApplicationSectionNegotiated","getDataTrackSenderChanges","dataTrackSendersToAdd","difference","dataTrackSendersToRemove","getMediaTrackSenderChanges","mediaTrackSendersToAdd","mediaTrackSendersToRemove","toRank","new","checking","connecting","connected","completed","disconnected","failed","closed","fromRank","createFromRank","keys","reduce","_a","summarizeIceOrPeerConnectionStates","states","length","state1","state2","Math","max","pcm","iceConnectionState","__spreadArray","__read","pcv2","emit","connectionState","module","exports"],"sources":["/home/denis/RiderProjects/ChatRoulette/WebUI/chat-app/node_modules/twilio-video/lib/signaling/v2/peerconnectionmanager.js"],"sourcesContent":["'use strict';\n\nconst { guessBrowser } = require('../../webrtc/util');\nconst PeerConnectionV2 = require('./peerconnection');\nconst MediaTrackSender = require('../../media/track/sender');\nconst QueueingEventEmitter = require('../../queueingeventemitter');\nconst util = require('../../util');\nconst { MediaConnectionError } = require('../../util/twilio-video-errors');\n\nconst isFirefox = guessBrowser() === 'firefox';\n\n/**\n * {@link PeerConnectionManager} manages multiple {@link PeerConnectionV2}s.\n * @extends QueueingEventEmitter\n * @emits PeerConnectionManager#candidates\n * @emits PeerConnectionManager#connectionStateChanged\n * @emits PeerConnectionManager#description\n * @emits PeerConnectionManager#iceConnectionStateChanged\n * @emits PeerConnectionManager#trackAdded\n */\nclass PeerConnectionManager extends QueueingEventEmitter {\n  /**\n   * Construct {@link PeerConnectionManager}.\n   * @param {EncodingParametersImpl} encodingParameters\n   * @param {PreferredCodecs} preferredCodecs\n   * @param {object} options\n   */\n  constructor(encodingParameters, preferredCodecs, options) {\n    super();\n\n    options = Object.assign({\n      audioContextFactory: isFirefox\n        ? require('../../webaudio/audiocontext')\n        : null,\n      PeerConnectionV2\n    }, options);\n\n    const audioContext = options.audioContextFactory\n      ? options.audioContextFactory.getOrCreate(this)\n      : null;\n\n    // NOTE(mroberts): If we're using an AudioContext, we don't need to specify\n    // `offerToReceiveAudio` in RTCOfferOptions.\n    const offerOptions = audioContext\n      ? { offerToReceiveVideo: true }\n      : { offerToReceiveAudio: true, offerToReceiveVideo: true };\n\n    Object.defineProperties(this, {\n      _audioContextFactory: {\n        value: options.audioContextFactory\n      },\n      _closedPeerConnectionIds: {\n        value: new Set()\n      },\n      _configuration: {\n        writable: true,\n        value: null\n      },\n      _configurationDeferred: {\n        writable: true,\n        value: util.defer()\n      },\n      _connectionState: {\n        value: 'new',\n        writable: true\n      },\n      _dummyAudioTrackSender: {\n        value: audioContext\n          ? new MediaTrackSender(createDummyAudioMediaStreamTrack(audioContext))\n          : null\n      },\n      _encodingParameters: {\n        value: encodingParameters\n      },\n      _iceConnectionState: {\n        writable: true,\n        value: 'new'\n      },\n      _dataTrackSenders: {\n        writable: true,\n        value: new Set()\n      },\n      _lastConnectionState: {\n        value: 'new',\n        writable: true\n      },\n      _lastIceConnectionState: {\n        writable: true,\n        value: 'new'\n      },\n      _mediaTrackSenders: {\n        writable: true,\n        value: new Set()\n      },\n      _offerOptions: {\n        value: offerOptions\n      },\n      _peerConnections: {\n        value: new Map()\n      },\n      _preferredCodecs: {\n        value: preferredCodecs\n      },\n      _sessionTimeout: {\n        value: null,\n        writable: true\n      },\n      _PeerConnectionV2: {\n        value: options.PeerConnectionV2\n      }\n    });\n  }\n\n  setEffectiveAdaptiveSimulcast(effectiveAdaptiveSimulcast) {\n    this._peerConnections.forEach(pc => pc.setEffectiveAdaptiveSimulcast(effectiveAdaptiveSimulcast));\n    this._preferredCodecs.video.forEach(cs => {\n      if ('adaptiveSimulcast' in cs) {\n        cs.adaptiveSimulcast = effectiveAdaptiveSimulcast;\n      }\n    });\n  }\n\n  /**\n   * A summarized RTCPeerConnectionState across all the\n   * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.\n   * @property {RTCPeerConnectionState}\n   */\n  get connectionState() {\n    return this._connectionState;\n  }\n\n  /**\n   * A summarized RTCIceConnectionState across all the\n   * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.\n   * @property {RTCIceConnectionState}\n   */\n  get iceConnectionState() {\n    return this._iceConnectionState;\n  }\n\n  /**\n   * Close the {@link PeerConnectionV2}s which are no longer relevant.\n   * @param {Array<object>} peerConnectionStates\n   * @returns {this}\n   */\n  _closeAbsentPeerConnections(peerConnectionStates) {\n    const peerConnectionIds = new Set(peerConnectionStates.map(peerConnectionState => peerConnectionState.id));\n    this._peerConnections.forEach(peerConnection => {\n      if (!peerConnectionIds.has(peerConnection.id)) {\n        peerConnection._close();\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Get the {@link PeerConnectionManager}'s configuration.\n   * @private\n   * @returns {Promise<object>}\n   */\n  _getConfiguration() {\n    return this._configurationDeferred.promise;\n  }\n\n  /**\n   * Get or create a {@link PeerConnectionV2}.\n   * @private\n   * @param {string} id\n   * @param {object} [configuration]\n   * @returns {PeerConnectionV2}\n   */\n  _getOrCreate(id, configuration) {\n    const self = this;\n    let peerConnection = this._peerConnections.get(id);\n    if (!peerConnection) {\n      const PeerConnectionV2 = this._PeerConnectionV2;\n\n      const options = Object.assign({\n        dummyAudioMediaStreamTrack: this._dummyAudioTrackSender\n          ? this._dummyAudioTrackSender.track\n          : null,\n        offerOptions: this._offerOptions\n      }, this._sessionTimeout ? {\n        sessionTimeout: this._sessionTimeout\n      } : {}, configuration);\n\n      try {\n        peerConnection = new PeerConnectionV2(id, this._encodingParameters, this._preferredCodecs, options);\n      } catch (e) {\n        throw new MediaConnectionError();\n      }\n\n      this._peerConnections.set(peerConnection.id, peerConnection);\n      peerConnection.on('candidates', this.queue.bind(this, 'candidates'));\n      peerConnection.on('description', this.queue.bind(this, 'description'));\n      peerConnection.on('trackAdded', this.queue.bind(this, 'trackAdded'));\n      peerConnection.on('stateChanged', function stateChanged(state) {\n        if (state === 'closed') {\n          peerConnection.removeListener('stateChanged', stateChanged);\n          self._dataTrackSenders.forEach(sender => peerConnection.removeDataTrackSender(sender));\n          self._mediaTrackSenders.forEach(sender => peerConnection.removeMediaTrackSender(sender));\n          self._peerConnections.delete(peerConnection.id);\n          self._closedPeerConnectionIds.add(peerConnection.id);\n          updateConnectionState(self);\n          updateIceConnectionState(self);\n        }\n      });\n      peerConnection.on('connectionStateChanged', () => updateConnectionState(this));\n      peerConnection.on('iceConnectionStateChanged', () => updateIceConnectionState(this));\n\n      this._dataTrackSenders.forEach(peerConnection.addDataTrackSender, peerConnection);\n      this._mediaTrackSenders.forEach(peerConnection.addMediaTrackSender, peerConnection);\n\n      updateIceConnectionState(this);\n    }\n    return peerConnection;\n  }\n\n  /**\n   * Close all the {@link PeerConnectionV2}s in this {@link PeerConnectionManager}.\n   * @returns {this}\n   */\n  close() {\n    this._peerConnections.forEach(peerConnection => {\n      peerConnection.close();\n    });\n    if (this._dummyAudioTrackSender) {\n      this._dummyAudioTrackSender.stop();\n    }\n    if (this._audioContextFactory) {\n      this._audioContextFactory.release(this);\n    }\n    updateIceConnectionState(this);\n    return this;\n  }\n\n  /**\n   * Create a new {@link PeerConnectionV2} on this {@link PeerConnectionManager}.\n   * Then, create a new offer with the newly-created {@link PeerConnectionV2}.\n   * @return {Promise<this>}\n   */\n  createAndOffer() {\n    return this._getConfiguration().then(configuration => {\n      let id;\n      do {\n        id = util.makeUUID();\n      } while (this._peerConnections.has(id));\n\n      return this._getOrCreate(id, configuration);\n    }).then(peerConnection => {\n      return peerConnection.offer();\n    }).then(() => {\n      return this;\n    });\n  }\n\n  /**\n   * Get the {@link DataTrackReceiver}s and {@link MediaTrackReceiver}s of all\n   * the {@link PeerConnectionV2}s.\n   * @returns {Array<DataTrackReceiver|MediaTrackReceiver>} trackReceivers\n   */\n  getTrackReceivers() {\n    return util.flatMap(this._peerConnections, peerConnection => peerConnection.getTrackReceivers());\n  }\n\n  /**\n   * Get the states of all {@link PeerConnectionV2}s.\n   * @returns {Array<object>}\n   */\n  getStates() {\n    const peerConnectionStates = [];\n    this._peerConnections.forEach(peerConnection => {\n      const peerConnectionState = peerConnection.getState();\n      if (peerConnectionState) {\n        peerConnectionStates.push(peerConnectionState);\n      }\n    });\n    return peerConnectionStates;\n  }\n\n  /**\n   * Set the {@link PeerConnectionManager}'s configuration.\n   * @param {object} configuration\n   * @returns {this}\n   */\n  setConfiguration(configuration) {\n    if (this._configuration) {\n      this._configurationDeferred = util.defer();\n      this._peerConnections.forEach(peerConnection => {\n        peerConnection.setConfiguration(configuration);\n      });\n    }\n    this._configuration = configuration;\n    this._configurationDeferred.resolve(configuration);\n    return this;\n  }\n\n  /**\n   * Set the ICE reconnect timeout period for all {@link PeerConnectionV2}s.\n   * @param {number} period - Period in milliseconds.\n   * @returns {this}\n   */\n  setIceReconnectTimeout(period) {\n    if (this._sessionTimeout === null) {\n      this._peerConnections.forEach(peerConnection => {\n        peerConnection.setIceReconnectTimeout(period);\n      });\n      this._sessionTimeout = period;\n    }\n    return this;\n  }\n\n  /**\n   * Set the {@link DataTrackSender}s and {@link MediaTrackSender}s on the\n   * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.\n   * @param {Array<DataTrackSender|MediaTrackSender>} trackSenders\n   * @returns {this}\n   */\n  setTrackSenders(trackSenders) {\n    const dataTrackSenders = new Set(trackSenders.filter(trackSender => trackSender.kind === 'data'));\n\n    const mediaTrackSenders = new Set(trackSenders\n      .filter(trackSender => trackSender && (trackSender.kind === 'audio' || trackSender.kind === 'video')));\n\n    const changes = getTrackSenderChanges(this, dataTrackSenders, mediaTrackSenders);\n    this._dataTrackSenders = dataTrackSenders;\n    this._mediaTrackSenders = mediaTrackSenders;\n    applyTrackSenderChanges(this, changes);\n\n    return this;\n  }\n\n  /**\n   * Update the {@link PeerConnectionManager}.\n   * @param {Array<object>} peerConnectionStates\n   * @param {boolean} [synced=false]\n   * @returns {Promise<this>}\n   */\n  update(peerConnectionStates, synced = false) {\n    if (synced) {\n      this._closeAbsentPeerConnections(peerConnectionStates);\n    }\n    return this._getConfiguration().then(configuration => {\n      return Promise.all(peerConnectionStates.map(peerConnectionState => {\n        if (this._closedPeerConnectionIds.has(peerConnectionState.id)) {\n          return null;\n        }\n        const peerConnection = this._getOrCreate(peerConnectionState.id, configuration);\n        return peerConnection.update(peerConnectionState);\n      }));\n    }).then(() => {\n      return this;\n    });\n  }\n\n  /**\n   * Get the {@link PeerConnectionManager}'s media statistics.\n   * @returns {Promise.<Map<PeerConnectionV2#id, StandardizedStatsResponse>>}\n   */\n  getStats() {\n    const peerConnections = Array.from(this._peerConnections.values());\n    return Promise.all(peerConnections.map(peerConnection => peerConnection.getStats().then(response => [\n      peerConnection.id,\n      response\n    ]))).then(responses => new Map(responses));\n  }\n}\n\n/**\n * Create a dummy audio MediaStreamTrack with the given AudioContext.\n * @private\n * @param {AudioContext} audioContext\n * @return {MediaStreamTrack}\n */\nfunction createDummyAudioMediaStreamTrack(audioContext) {\n  const mediaStreamDestination = audioContext.createMediaStreamDestination();\n  return mediaStreamDestination.stream.getAudioTracks()[0];\n}\n\n/**\n * @event {PeerConnectionManager#candidates}\n * @param {object} candidates\n */\n\n/**\n * @event {PeerConnectionManager#connectionStateChanged}\n */\n\n/**\n * @event {PeerConnectionManager#description}\n * @param {object} description\n */\n\n/**\n * @event {PeerConnectionManager#iceConnectionStateChanged}\n */\n\n/**\n * @event {PeerConnectionManager#trackAdded}\n * @param {MediaStreamTrack|DataTrackReceiver} mediaStreamTrackOrDataTrackReceiver\n */\n\n/**\n * Apply {@link TrackSenderChanges}.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {TrackSenderChanges} changes\n * @returns {void}\n */\nfunction applyTrackSenderChanges(peerConnectionManager, changes) {\n  if (changes.data.add.size\n    || changes.data.remove.size\n    || changes.media.add.size\n    || changes.media.remove.size) {\n    peerConnectionManager._peerConnections.forEach(peerConnection => {\n      changes.data.remove.forEach(peerConnection.removeDataTrackSender, peerConnection);\n      changes.media.remove.forEach(peerConnection.removeMediaTrackSender, peerConnection);\n      changes.data.add.forEach(peerConnection.addDataTrackSender, peerConnection);\n      changes.media.add.forEach(peerConnection.addMediaTrackSender, peerConnection);\n      if (changes.media.add.size\n        || changes.media.remove.size\n        || (changes.data.add.size && !peerConnection.isApplicationSectionNegotiated)) {\n        peerConnection.offer();\n      }\n    });\n  }\n}\n\n/**\n * @interface DataTrackSenderChanges\n * @property {Set<DataTrackSender>} add\n * @property {Set<DataTrackSender>} remove\n */\n\n/**\n * Get the {@Link DataTrackSender} changes.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {Array<DataTrackSender>} dataTrackSenders\n * @returns {DataTrackSenderChanges} changes\n */\nfunction getDataTrackSenderChanges(peerConnectionManager, dataTrackSenders) {\n  const dataTrackSendersToAdd = util.difference(dataTrackSenders, peerConnectionManager._dataTrackSenders);\n  const dataTrackSendersToRemove = util.difference(peerConnectionManager._dataTrackSenders, dataTrackSenders);\n  return {\n    add: dataTrackSendersToAdd,\n    remove: dataTrackSendersToRemove\n  };\n}\n\n/**\n * @interface TrackSenderChanges\n * @property {DataTrackSenderChanges} data\n * @property {MediaTrackSenderChanges} media\n */\n\n/**\n * Get {@link DataTrackSender} and {@link MediaTrackSender} changes.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {Array<DataTrackSender>} dataTrackSenders\n * @param {Array<MediaTrackSender>} mediaTrackSenders\n * @returns {TrackSenderChanges} changes\n */\nfunction getTrackSenderChanges(peerConnectionManager, dataTrackSenders, mediaTrackSenders) {\n  return {\n    data: getDataTrackSenderChanges(peerConnectionManager, dataTrackSenders),\n    media: getMediaTrackSenderChanges(peerConnectionManager, mediaTrackSenders)\n  };\n}\n\n/**\n * @interface MediaTrackSenderChanges\n * @property {Set<MediaTrackSender>} add\n * @property {Set<MediaTrackSender>} remove\n */\n\n/**\n * Get the {@link MediaTrackSender} changes.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {Array<MediaTrackSender>} mediaTrackSenders\n * @returns {MediaTrackSenderChanges} changes\n */\nfunction getMediaTrackSenderChanges(peerConnectionManager, mediaTrackSenders) {\n  const mediaTrackSendersToAdd = util.difference(mediaTrackSenders, peerConnectionManager._mediaTrackSenders);\n  const mediaTrackSendersToRemove = util.difference(peerConnectionManager._mediaTrackSenders, mediaTrackSenders);\n  return {\n    add: mediaTrackSendersToAdd,\n    remove: mediaTrackSendersToRemove\n  };\n}\n\n/**\n * This object maps RTCIceConnectionState and RTCPeerConnectionState values to a \"rank\".\n */\nconst toRank = {\n  new: 0,\n  checking: 1,\n  connecting: 2,\n  connected: 3,\n  completed: 4,\n  disconnected: -1,\n  failed: -2,\n  closed: -3\n};\n\n/**\n * This object maps \"rank\" back to RTCIceConnectionState or RTCPeerConnectionState values.\n */\nlet fromRank;\n\n/**\n * `Object.keys` is not supported in older browsers, so we can't just\n * synchronously call it in this module; we need to defer invoking it until we\n * know we're in a modern environment (i.e., anything that supports WebRTC).\n * @returns {object} fromRank\n */\nfunction createFromRank() {\n  return Object.keys(toRank).reduce((fromRank, state) => {\n    return Object.assign(fromRank, { [toRank[state]]: state });\n  }, {});\n}\n\n/**\n * Summarize RTCIceConnectionStates or RTCPeerConnectionStates.\n * @param {Array<RTCIceConnectionState>|Array<RTCPeerConnectionState>} states\n * @returns {RTCIceConnectionState|RTCPeerConnectionState} summary\n */\nfunction summarizeIceOrPeerConnectionStates(states) {\n  if (!states.length) {\n    return 'new';\n  }\n  fromRank = fromRank || createFromRank();\n  return states.reduce((state1, state2) => {\n    return fromRank[Math.max(toRank[state1], toRank[state2])];\n  });\n}\n\n/**\n * Update the {@link PeerConnectionManager}'s `iceConnectionState`, and emit an\n * \"iceConnectionStateChanged\" event, if necessary.\n * @param {PeerConnectionManager} pcm\n * @returns {void}\n */\nfunction updateIceConnectionState(pcm) {\n  pcm._lastIceConnectionState = pcm.iceConnectionState;\n  pcm._iceConnectionState = summarizeIceOrPeerConnectionStates(\n    [...pcm._peerConnections.values()].map(pcv2 => pcv2.iceConnectionState));\n  if (pcm.iceConnectionState !== pcm._lastIceConnectionState) {\n    pcm.emit('iceConnectionStateChanged');\n  }\n}\n\n/**\n * Update the {@link PeerConnectionManager}'s `connectionState`, and emit a\n * \"connectionStateChanged\" event, if necessary.\n * @param {PeerConnectionManager} pcm\n * @returns {void}\n */\nfunction updateConnectionState(pcm) {\n  pcm._lastConnectionState = pcm.connectionState;\n  pcm._connectionState = summarizeIceOrPeerConnectionStates(\n    [...pcm._peerConnections.values()].map(pcv2 => pcv2.connectionState));\n  if (pcm.connectionState !== pcm._lastConnectionState) {\n    pcm.emit('connectionStateChanged');\n  }\n}\n\nmodule.exports = PeerConnectionManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}