{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('./util');\n/**\n * {@link StateMachine} represents a state machine. The state machine supports a\n * reentrant locking mechanism to allow asynchronous state transitions to ensure\n * they have not been preempted. Calls to {@link StateMachine#takeLock} are\n * guaranteed to be resolved in FIFO order.\n * @extends EventEmitter\n * @property {boolean} isLocked - whether or not the {@link StateMachine} is\n *   locked performing asynchronous state transition\n * @property {string} state - the current state\n * @emits {@link StateMachine#stateChanged}\n */\nvar StateMachine = /** @class */function (_super) {\n  __extends(StateMachine, _super);\n  /**\n   * Construct a {@link StateMachine}.\n   * @param {string} initialState - the intiial state\n   * @param {object} states\n   */\n  function StateMachine(initialState, states) {\n    var _this = _super.call(this) || this;\n    var lock = null;\n    var state = initialState;\n    states = transformStates(states);\n    Object.defineProperties(_this, {\n      _lock: {\n        get: function () {\n          return lock;\n        },\n        set: function (_lock) {\n          lock = _lock;\n        }\n      },\n      _reachableStates: {\n        value: reachable(states)\n      },\n      _state: {\n        get: function () {\n          return state;\n        },\n        set: function (_state) {\n          state = _state;\n        }\n      },\n      _states: {\n        value: states\n      },\n      _whenDeferreds: {\n        value: new Set()\n      },\n      isLocked: {\n        enumerable: true,\n        get: function () {\n          return lock !== null;\n        }\n      },\n      state: {\n        enumerable: true,\n        get: function () {\n          return state;\n        }\n      }\n    });\n    _this.on('stateChanged', function (state) {\n      _this._whenDeferreds.forEach(function (deferred) {\n        deferred.when(state, deferred.resolve, deferred.reject);\n      });\n    });\n    return _this;\n  }\n  /**\n   * Returns a promise whose executor function is called on each state change.\n   * @param {function(state: string, resolve: function, reject: function): void} when\n   * @returns {Promise.<*>}\n   * @private\n   */\n  StateMachine.prototype._whenPromise = function (when) {\n    var _this = this;\n    if (typeof when !== 'function') {\n      return Promise.reject(new Error('when() executor must be a function'));\n    }\n    var deferred = util.defer();\n    deferred.when = when;\n    this._whenDeferreds.add(deferred);\n    return deferred.promise.then(function (payload) {\n      _this._whenDeferreds.delete(deferred);\n      return payload;\n    }, function (error) {\n      _this._whenDeferreds.delete(deferred);\n      throw error;\n    });\n  };\n  /**\n   * This method takes a lock and passes the {@link StateMachine#Key} to your\n   * transition function. You may perform zero or more state transitions in your\n   * transition function, but you should check for preemption in each tick. You\n   * may also reenter the lock. Once the Promise returned by your transition\n   * function resolves or rejects, this method releases the lock it acquired for\n   * you.\n   * @param {string} name - a name for the lock\n   * @param {function(StateMachine#Key): Promise} transitionFunction\n   * @returns {Promise}\n   */\n  // NOTE(mroberts): This method is named after a Haskell function:\n  // https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:bracket\n  StateMachine.prototype.bracket = function (name, transitionFunction) {\n    var key;\n    var self = this;\n    function releaseLock(error) {\n      if (self.hasLock(key)) {\n        self.releaseLockCompletely(key);\n      }\n      if (error) {\n        throw error;\n      }\n    }\n    return this.takeLock(name).then(function gotKey(_key) {\n      key = _key;\n      return transitionFunction(key);\n    }).then(function success(result) {\n      releaseLock();\n      return result;\n    }, releaseLock);\n  };\n  /**\n   * Check whether or not a {@link StateMachine#Key} matches the lock.\n   * @param {StateMachine#Key} key\n   * @returns {boolean}\n   */\n  StateMachine.prototype.hasLock = function (key) {\n    return this._lock === key;\n  };\n  /**\n   * Preempt any pending state transitions and immediately transition to the new\n   * state. If a lock name is specified, take the lock and return the\n   * {@link StateMachine#Key}.\n   * @param {string} newState\n   * @param {?string} [name=null] - a name for the lock\n   * @param {Array<*>} [payload=[]]\n   * @returns {?StateMachine#Key}\n   */\n  StateMachine.prototype.preempt = function (newState, name, payload) {\n    // 1. Check that the new state is valid.\n    if (!isValidTransition(this._states, this.state, newState)) {\n      throw new Error(\"Cannot transition from \\\"\" + this.state + \"\\\" to \\\"\" + newState + \"\\\"\");\n    }\n    // 2. Release the old lock, if any.\n    var oldLock;\n    if (this.isLocked) {\n      oldLock = this._lock;\n      this._lock = null;\n    }\n    // 3. Take the lock, if requested.\n    var key = null;\n    if (name) {\n      key = this.takeLockSync(name);\n    }\n    // 4. If a lock wasn't requested, take a \"preemption\" lock in order to\n    // maintain FIFO order of those taking locks.\n    var preemptionKey = key ? null : this.takeLockSync('preemption');\n    // 5. Transition.\n    this.transition(newState, key || preemptionKey, payload);\n    // 6. Preempt anyone blocked on the old lock.\n    if (oldLock) {\n      oldLock.resolve();\n    }\n    // 7. Release the \"preemption\" lock, if we took it.\n    if (preemptionKey) {\n      this.releaseLock(preemptionKey);\n    }\n    return key;\n  };\n  /**\n   * Release a lock. This method succeeds only if the {@link StateMachine} is\n   * still locked and has not been preempted.\n   * @param {StateMachine#Key} key\n   * @throws Error\n   */\n  StateMachine.prototype.releaseLock = function (key) {\n    if (!this.isLocked) {\n      throw new Error(\"Could not release the lock for \" + key.name + \" because the StateMachine is not locked\");\n    } else if (!this.hasLock(key)) {\n      throw new Error(\"Could not release the lock for \" + key.name + \" because \" + this._lock.name + \" has the lock\");\n    }\n    if (key.depth === 0) {\n      this._lock = null;\n      key.resolve();\n    } else {\n      key.depth--;\n    }\n  };\n  /**\n   * Release a lock completely, even if it has been reentered. This method\n   * succeeds only if the {@link StateMachine} is still locked and has not been\n   * preempted.\n   * @param {StateMachine#Key} key\n   * @throws Error\n   */\n  StateMachine.prototype.releaseLockCompletely = function (key) {\n    if (!this.isLocked) {\n      throw new Error(\"Could not release the lock for \" + key.name + \" because the StateMachine is not locked\");\n    } else if (!this.hasLock(key)) {\n      throw new Error(\"Could not release the lock for \" + key.name + \" because \" + this._lock.name + \" has the lock\");\n    }\n    key.depth = 0;\n    this._lock = null;\n    key.resolve();\n  };\n  /**\n   * Take a lock, returning a Promise for the {@link StateMachine#Key}. You should\n   * take a lock anytime you intend to perform asynchronous transitions. Calls to\n   * this method are guaranteed to be resolved in FIFO order. You may reenter\n   * a lock by passing its {@link StateMachine#Key}.\n   * @param {string|StateMachine#Key} nameOrKey - a name for the lock or an\n   * existing {@link StateMachine#Key}\n   * @returns {Promise<object>}\n   */\n  StateMachine.prototype.takeLock = function (nameOrKey) {\n    var _this = this;\n    // Reentrant lock\n    if (typeof nameOrKey === 'object') {\n      var key_1 = nameOrKey;\n      return new Promise(function (resolve) {\n        resolve(_this.takeLockSync(key_1));\n      });\n    }\n    // New lock\n    var name = nameOrKey;\n    if (this.isLocked) {\n      var takeLock = this.takeLock.bind(this, name);\n      return this._lock.promise.then(takeLock);\n    }\n    return Promise.resolve(this.takeLockSync(name));\n  };\n  /**\n   * Take a lock, returning the {@Link StateMachine#Key}. This method throws if\n   * the {@link StateMachine} is locked or the wrong {@link StateMachine#Key} is\n   * provided. You may reenter a lock by passing its {@link StateMachine#Key}.\n   * @param {string|StateMachine#Key} nameOrKey - a name for the lock or an\n   * existing {@link StateMachine#Key}\n   * @returns {object}\n   * @throws Error\n   */\n  StateMachine.prototype.takeLockSync = function (nameOrKey) {\n    var key = typeof nameOrKey === 'string' ? null : nameOrKey;\n    var name = key ? key.name : nameOrKey;\n    if (key && !this.hasLock(key) || !key && this.isLocked) {\n      throw new Error(\"Could not take the lock for \" + name + \" because the lock for \" + this._lock.name + \" was not released\");\n    }\n    // Reentrant lock\n    if (key) {\n      key.depth++;\n      return key;\n    }\n    // New lock\n    var lock = makeLock(name);\n    this._lock = lock;\n    return lock;\n  };\n  /**\n   * Transition to a new state. If the {@link StateMachine} is locked, you must\n   * provide the {@link StateMachine#Key}. An invalid state or the wrong\n   * {@link StateMachine#Key} will throw an error.\n   * @param {string} newState\n   * @param {?StateMachine#Key} [key=null]\n   * @param {Array<*>} [payload=[]]\n   * @throws {Error}\n   */\n  StateMachine.prototype.transition = function (newState, key, payload) {\n    payload = payload || [];\n    // 1. If we're locked, required the key.\n    if (this.isLocked) {\n      if (!key) {\n        throw new Error('You must provide the key in order to ' + 'transition');\n      } else if (!this.hasLock(key)) {\n        throw new Error(\"Could not transition using the key for \" + key.name + \" because \" + this._lock.name + \" has the lock\");\n      }\n    } else if (key) {\n      throw new Error(\"Key provided for \" + key.name + \", but the StateMachine was not locked (possibly due to preemption)\");\n    }\n    // 2. Check that the new state is valid.\n    if (!isValidTransition(this._states, this.state, newState)) {\n      throw new Error(\"Cannot transition from \\\"\" + this.state + \"\\\" to \\\"\" + newState + \"\\\"\");\n    }\n    // 3. Update the state and emit an event.\n    this._state = newState;\n    this.emit.apply(this, __spreadArray([], __read(['stateChanged', newState].concat(payload))));\n  };\n  /**\n   * Attempt to transition to a new state. Unlike {@link StateMachine#transition},\n   * this method does not throw.\n   * @param {string} newState\n   * @param {?StateMachine#Key} [key=null]\n   * @param {Array<*>} [payload=[]]\n   * @returns {boolean}\n   */\n  StateMachine.prototype.tryTransition = function (newState, key, payload) {\n    try {\n      this.transition(newState, key, payload);\n    } catch (error) {\n      return false;\n    }\n    return true;\n  };\n  /**\n   * Return a Promise that resolves when the {@link StateMachine} transitions to\n   * the specified state. If the {@link StateMachine} transitions such that the\n   * requested state becomes unreachable, the Promise rejects.\n   * @param {string} state\n   * @returns {Promise<this>}\n   */\n  StateMachine.prototype.when = function (state) {\n    var _this = this;\n    if (this.state === state) {\n      return Promise.resolve(this);\n    } else if (!isValidTransition(this._reachableStates, this.state, state)) {\n      return Promise.reject(createUnreachableError(this.state, state));\n    }\n    return this._whenPromise(function (newState, resolve, reject) {\n      if (newState === state) {\n        resolve(_this);\n      } else if (!isValidTransition(_this._reachableStates, newState, state)) {\n        reject(createUnreachableError(newState, state));\n      }\n    });\n  };\n  return StateMachine;\n}(EventEmitter);\n/**\n * @event StateMachine#stateChanged\n * @param {string} newState\n */\n/**\n * Check if a transition is valid.\n * @private\n * @param {Map<*, Set<*>>} graph\n * @param {*} from\n * @param {*} to\n * @returns {boolean}\n */\nfunction isValidTransition(graph, from, to) {\n  return graph.get(from).has(to);\n}\n/**\n * @typedef {object} StateMachine#Key\n */\nfunction makeLock(name) {\n  var lock = util.defer();\n  lock.name = name;\n  lock.depth = 0;\n  return lock;\n}\n/**\n * Compute the transitive closure of a graph (i.e. what nodes are reachable from\n * where).\n * @private\n * @param {Map<*, Set<*>>} graph\n * @returns {Map<*, Set<*>>}\n */\nfunction reachable(graph) {\n  return Array.from(graph.keys()).reduce(function (newGraph, from) {\n    return newGraph.set(from, reachableFrom(graph, from));\n  }, new Map());\n}\n/**\n * Compute the Set of node reachable from a particular node in the graph.\n * @private\n * @param {Map<*, Set<*>>} graph\n * @param {*} from\n * @param {Set<*>} [to]\n * @returns {Set<*>}\n */\nfunction reachableFrom(graph, from, to) {\n  to = to || new Set();\n  graph.get(from).forEach(function (node) {\n    if (!to.has(node)) {\n      to.add(node);\n      reachableFrom(graph, node, to).forEach(to.add, to);\n    }\n  });\n  return to;\n}\nfunction transformStates(states) {\n  var newStates = new Map();\n  for (var key in states) {\n    newStates.set(key, new Set(states[key]));\n  }\n  return newStates;\n}\n/**\n * Create an \"unreachable state\" Error.\n * @param {string} here\n * @param {string} there\n * @returns {Error}\n */\nfunction createUnreachableError(here, there) {\n  return new Error(\"\\\"\" + there + \"\\\" cannot be reached from \\\"\" + here + \"\\\"\");\n}\nmodule.exports = StateMachine;","map":{"version":3,"names":["EventEmitter","require","util","StateMachine","_super","__extends","initialState","states","_this","call","lock","state","transformStates","Object","defineProperties","_lock","get","set","_reachableStates","value","reachable","_state","_states","_whenDeferreds","Set","isLocked","enumerable","on","forEach","deferred","when","resolve","reject","prototype","_whenPromise","Promise","Error","defer","add","promise","then","payload","delete","error","bracket","name","transitionFunction","key","self","releaseLock","hasLock","releaseLockCompletely","takeLock","gotKey","_key","success","result","preempt","newState","isValidTransition","oldLock","takeLockSync","preemptionKey","transition","depth","nameOrKey","key_1","bind","makeLock","emit","apply","__spreadArray","__read","concat","tryTransition","createUnreachableError","graph","from","to","has","Array","keys","reduce","newGraph","reachableFrom","Map","node","newStates","here","there","module","exports"],"sources":["/home/denis/RiderProjects/ChatRoulette/WebUI/chat-app/node_modules/twilio-video/lib/statemachine.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\nconst util = require('./util');\n\n/**\n * {@link StateMachine} represents a state machine. The state machine supports a\n * reentrant locking mechanism to allow asynchronous state transitions to ensure\n * they have not been preempted. Calls to {@link StateMachine#takeLock} are\n * guaranteed to be resolved in FIFO order.\n * @extends EventEmitter\n * @property {boolean} isLocked - whether or not the {@link StateMachine} is\n *   locked performing asynchronous state transition\n * @property {string} state - the current state\n * @emits {@link StateMachine#stateChanged}\n */\nclass StateMachine extends EventEmitter {\n  /**\n   * Construct a {@link StateMachine}.\n   * @param {string} initialState - the intiial state\n   * @param {object} states\n   */\n  constructor(initialState, states) {\n    super();\n    let lock = null;\n    let state = initialState;\n    states = transformStates(states);\n    Object.defineProperties(this, {\n      _lock: {\n        get() {\n          return lock;\n        },\n        set(_lock) {\n          lock = _lock;\n        }\n      },\n      _reachableStates: {\n        value: reachable(states)\n      },\n      _state: {\n        get() {\n          return state;\n        },\n        set(_state) {\n          state = _state;\n        }\n      },\n      _states: {\n        value: states\n      },\n      _whenDeferreds: {\n        value: new Set()\n      },\n      isLocked: {\n        enumerable: true,\n        get() {\n          return lock !== null;\n        }\n      },\n      state: {\n        enumerable: true,\n        get() {\n          return state;\n        }\n      }\n    });\n\n    this.on('stateChanged', state => {\n      this._whenDeferreds.forEach(deferred => {\n        deferred.when(state, deferred.resolve, deferred.reject);\n      });\n    });\n  }\n\n  /**\n   * Returns a promise whose executor function is called on each state change.\n   * @param {function(state: string, resolve: function, reject: function): void} when\n   * @returns {Promise.<*>}\n   * @private\n   */\n  _whenPromise(when) {\n    if (typeof when !== 'function') {\n      return Promise.reject(new Error('when() executor must be a function'));\n    }\n\n    const deferred = util.defer();\n\n    deferred.when = when;\n    this._whenDeferreds.add(deferred);\n\n    return deferred.promise.then(payload => {\n      this._whenDeferreds.delete(deferred);\n      return payload;\n    }, error => {\n      this._whenDeferreds.delete(deferred);\n      throw error;\n    });\n  }\n\n  /**\n   * This method takes a lock and passes the {@link StateMachine#Key} to your\n   * transition function. You may perform zero or more state transitions in your\n   * transition function, but you should check for preemption in each tick. You\n   * may also reenter the lock. Once the Promise returned by your transition\n   * function resolves or rejects, this method releases the lock it acquired for\n   * you.\n   * @param {string} name - a name for the lock\n   * @param {function(StateMachine#Key): Promise} transitionFunction\n   * @returns {Promise}\n   */\n  // NOTE(mroberts): This method is named after a Haskell function:\n  // https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:bracket\n  bracket(name, transitionFunction) {\n    let key;\n    const self = this;\n\n    function releaseLock(error) {\n      if (self.hasLock(key)) {\n        self.releaseLockCompletely(key);\n      }\n      if (error) {\n        throw error;\n      }\n    }\n\n    return this.takeLock(name).then(function gotKey(_key) {\n      key = _key;\n      return transitionFunction(key);\n    }).then(function success(result) {\n      releaseLock();\n      return result;\n    }, releaseLock);\n  }\n\n  /**\n   * Check whether or not a {@link StateMachine#Key} matches the lock.\n   * @param {StateMachine#Key} key\n   * @returns {boolean}\n   */\n  hasLock(key) {\n    return this._lock === key;\n  }\n\n  /**\n   * Preempt any pending state transitions and immediately transition to the new\n   * state. If a lock name is specified, take the lock and return the\n   * {@link StateMachine#Key}.\n   * @param {string} newState\n   * @param {?string} [name=null] - a name for the lock\n   * @param {Array<*>} [payload=[]]\n   * @returns {?StateMachine#Key}\n   */\n  preempt(newState, name, payload) {\n    // 1. Check that the new state is valid.\n    if (!isValidTransition(this._states, this.state, newState)) {\n      throw new Error(`Cannot transition from \"${this.state}\" to \"${newState}\"`);\n    }\n\n    // 2. Release the old lock, if any.\n    let oldLock;\n    if (this.isLocked) {\n      oldLock = this._lock;\n      this._lock = null;\n    }\n\n    // 3. Take the lock, if requested.\n    let key = null;\n    if (name) {\n      key = this.takeLockSync(name);\n    }\n\n    // 4. If a lock wasn't requested, take a \"preemption\" lock in order to\n    // maintain FIFO order of those taking locks.\n    const preemptionKey = key ? null : this.takeLockSync('preemption');\n\n    // 5. Transition.\n    this.transition(newState, key || preemptionKey, payload);\n\n    // 6. Preempt anyone blocked on the old lock.\n    if (oldLock) {\n      oldLock.resolve();\n    }\n\n    // 7. Release the \"preemption\" lock, if we took it.\n    if (preemptionKey) {\n      this.releaseLock(preemptionKey);\n    }\n\n    return key;\n  }\n\n  /**\n   * Release a lock. This method succeeds only if the {@link StateMachine} is\n   * still locked and has not been preempted.\n   * @param {StateMachine#Key} key\n   * @throws Error\n   */\n  releaseLock(key) {\n    if (!this.isLocked) {\n      throw new Error(`Could not release the lock for ${key.name} because the StateMachine is not locked`);\n    } else if (!this.hasLock(key)) {\n      throw new Error(`Could not release the lock for ${key.name} because ${this._lock.name} has the lock`);\n    }\n    if (key.depth === 0) {\n      this._lock = null;\n      key.resolve();\n    } else {\n      key.depth--;\n    }\n  }\n\n  /**\n   * Release a lock completely, even if it has been reentered. This method\n   * succeeds only if the {@link StateMachine} is still locked and has not been\n   * preempted.\n   * @param {StateMachine#Key} key\n   * @throws Error\n   */\n  releaseLockCompletely(key) {\n    if (!this.isLocked) {\n      throw new Error(`Could not release the lock for ${key.name} because the StateMachine is not locked`);\n    } else if (!this.hasLock(key)) {\n      throw new Error(`Could not release the lock for ${key.name} because ${this._lock.name} has the lock`);\n    }\n    key.depth = 0;\n    this._lock = null;\n    key.resolve();\n  }\n\n  /**\n   * Take a lock, returning a Promise for the {@link StateMachine#Key}. You should\n   * take a lock anytime you intend to perform asynchronous transitions. Calls to\n   * this method are guaranteed to be resolved in FIFO order. You may reenter\n   * a lock by passing its {@link StateMachine#Key}.\n   * @param {string|StateMachine#Key} nameOrKey - a name for the lock or an\n   * existing {@link StateMachine#Key}\n   * @returns {Promise<object>}\n   */\n  takeLock(nameOrKey) {\n    // Reentrant lock\n    if (typeof nameOrKey === 'object') {\n      const key = nameOrKey;\n      return new Promise(resolve => {\n        resolve(this.takeLockSync(key));\n      });\n    }\n\n    // New lock\n    const name = nameOrKey;\n    if (this.isLocked) {\n      var takeLock = this.takeLock.bind(this, name);\n      return this._lock.promise.then(takeLock);\n    }\n    return Promise.resolve(this.takeLockSync(name));\n  }\n\n  /**\n   * Take a lock, returning the {@Link StateMachine#Key}. This method throws if\n   * the {@link StateMachine} is locked or the wrong {@link StateMachine#Key} is\n   * provided. You may reenter a lock by passing its {@link StateMachine#Key}.\n   * @param {string|StateMachine#Key} nameOrKey - a name for the lock or an\n   * existing {@link StateMachine#Key}\n   * @returns {object}\n   * @throws Error\n   */\n  takeLockSync(nameOrKey) {\n    const key = typeof nameOrKey === 'string' ? null : nameOrKey;\n    const name = key ? key.name : nameOrKey;\n\n    if (key && !this.hasLock(key) || !key && this.isLocked) {\n      throw new Error(`Could not take the lock for ${name} because the lock for ${this._lock.name} was not released`);\n    }\n\n    // Reentrant lock\n    if (key) {\n      key.depth++;\n      return key;\n    }\n\n    // New lock\n    const lock = makeLock(name);\n    this._lock = lock;\n    return lock;\n  }\n\n  /**\n   * Transition to a new state. If the {@link StateMachine} is locked, you must\n   * provide the {@link StateMachine#Key}. An invalid state or the wrong\n   * {@link StateMachine#Key} will throw an error.\n   * @param {string} newState\n   * @param {?StateMachine#Key} [key=null]\n   * @param {Array<*>} [payload=[]]\n   * @throws {Error}\n   */\n  transition(newState, key, payload) {\n    payload = payload || [];\n\n    // 1. If we're locked, required the key.\n    if (this.isLocked) {\n      if (!key) {\n        throw new Error('You must provide the key in order to ' +\n          'transition');\n      } else if (!this.hasLock(key)) {\n        throw new Error(`Could not transition using the key for ${key.name} because ${this._lock.name} has the lock`);\n      }\n    } else if (key) {\n      throw new Error(`Key provided for ${key.name}, but the StateMachine was not locked (possibly due to preemption)`);\n    }\n\n    // 2. Check that the new state is valid.\n    if (!isValidTransition(this._states, this.state, newState)) {\n      throw new Error(`Cannot transition from \"${this.state}\" to \"${newState}\"`);\n    }\n\n    // 3. Update the state and emit an event.\n    this._state = newState;\n    this.emit(...['stateChanged', newState].concat(payload));\n  }\n\n  /**\n   * Attempt to transition to a new state. Unlike {@link StateMachine#transition},\n   * this method does not throw.\n   * @param {string} newState\n   * @param {?StateMachine#Key} [key=null]\n   * @param {Array<*>} [payload=[]]\n   * @returns {boolean}\n   */\n  tryTransition(newState, key, payload) {\n    try {\n      this.transition(newState, key, payload);\n    } catch (error) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Return a Promise that resolves when the {@link StateMachine} transitions to\n   * the specified state. If the {@link StateMachine} transitions such that the\n   * requested state becomes unreachable, the Promise rejects.\n   * @param {string} state\n   * @returns {Promise<this>}\n   */\n  when(state) {\n    if (this.state === state) {\n      return Promise.resolve(this);\n    } else if (!isValidTransition(this._reachableStates, this.state, state)) {\n      return Promise.reject(createUnreachableError(this.state, state));\n    }\n    return this._whenPromise((newState, resolve, reject) => {\n      if (newState === state) {\n        resolve(this);\n      } else if (!isValidTransition(this._reachableStates, newState, state)) {\n        reject(createUnreachableError(newState, state));\n      }\n    });\n  }\n}\n\n/**\n * @event StateMachine#stateChanged\n * @param {string} newState\n */\n\n/**\n * Check if a transition is valid.\n * @private\n * @param {Map<*, Set<*>>} graph\n * @param {*} from\n * @param {*} to\n * @returns {boolean}\n */\nfunction isValidTransition(graph, from, to) {\n  return graph.get(from).has(to);\n}\n\n/**\n * @typedef {object} StateMachine#Key\n */\n\nfunction makeLock(name) {\n  const lock = util.defer();\n  lock.name = name;\n  lock.depth = 0;\n  return lock;\n}\n\n/**\n * Compute the transitive closure of a graph (i.e. what nodes are reachable from\n * where).\n * @private\n * @param {Map<*, Set<*>>} graph\n * @returns {Map<*, Set<*>>}\n */\nfunction reachable(graph) {\n  return Array.from(graph.keys()).reduce((newGraph, from) => newGraph.set(from, reachableFrom(graph, from)), new Map());\n}\n\n/**\n * Compute the Set of node reachable from a particular node in the graph.\n * @private\n * @param {Map<*, Set<*>>} graph\n * @param {*} from\n * @param {Set<*>} [to]\n * @returns {Set<*>}\n */\nfunction reachableFrom(graph, from, to) {\n  to = to || new Set();\n  graph.get(from).forEach(node => {\n    if (!to.has(node)) {\n      to.add(node);\n      reachableFrom(graph, node, to).forEach(to.add, to);\n    }\n  });\n  return to;\n}\n\nfunction transformStates(states) {\n  const newStates = new Map();\n  for (const key in states) {\n    newStates.set(key, new Set(states[key]));\n  }\n  return newStates;\n}\n\n/**\n * Create an \"unreachable state\" Error.\n * @param {string} here\n * @param {string} there\n * @returns {Error}\n */\nfunction createUnreachableError(here, there) {\n  return new Error(`\"${there}\" cannot be reached from \"${here}\"`);\n}\n\nmodule.exports = StateMachine;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}