{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nvar EventEmitter = require('./eventemitter');\nvar RemoteParticipant = require('./remoteparticipant');\nvar StatsReport = require('./stats/statsreport');\nvar _a = require('./util'),\n  flatMap = _a.flatMap,\n  valueToJSON = _a.valueToJSON;\nvar nInstances = 0;\n/**\n * A {@link Room} represents communication between you and one or more\n * {@link RemoteParticipant}s sharing {@link AudioTrack}s and\n * {@link VideoTrack}s.\n * <br><br>\n * You can connect to a {@link Room} by calling {@link module:twilio-video.connect}.\n * @extends EventEmitter\n * @property {?RemoteParticipant} dominantSpeaker - The Dominant Speaker in the\n *   {@link Room}, if any\n * @property {boolean} isRecording - Whether or not the {@link Room} is being\n *   recorded\n * @property {LocalParticipant} localParticipant - Your {@link LocalParticipant}\n *   in the {@link Room}\n * @property {string} mediaRegion - String indicating geographical region\n *    where  media is processed for the {@link Room}.\n * @property {string} name - The {@link Room}'s name\n * @property {Map<Participant.SID, RemoteParticipant>} participants -\n *   The {@link RemoteParticipant}s participating in this {@link Room}\n * @property {Room.SID} sid - The {@link Room}'s SID\n * @property {string} state - \"connected\", \"reconnecting\", or \"disconnected\"\n * @throws {SignalingConnectionDisconnectedError}\n * @emits Room#disconnected\n * @emits Room#participantConnected\n * @emits Room#participantDisconnected\n * @emits Room#participantReconnected\n * @emits Room#participantReconnecting\n * @emits Room#reconnected\n * @emits Room#reconnecting\n * @emits Room#recordingStarted\n * @emits Room#recordingStopped\n * @emits Room#trackDimensionsChanged\n * @emits Room#trackDisabled\n * @emits Room#trackEnabled\n * @emits Room#trackMessage\n * @emits Room#trackPublished\n * @emits Room#trackPublishPriorityChanged\n * @emits Room#trackStarted\n * @emits Room#trackSubscribed\n * @emits Room#trackSwitchedOff\n * @emits Room#trackSwitchedOn\n * @emits Room#trackUnpublished\n * @emits Room#trackUnsubscribed\n * @emits Room#trackWarning\n * @emits Room#trackWarningsCleared\n */\nvar Room = /** @class */function (_super) {\n  __extends(Room, _super);\n  /**\n   * Construct a {@link Room}.\n   * @param {RoomSignaling} signaling\n   * @param {?object} [options={}]\n   */\n  function Room(localParticipant, signaling, options) {\n    var _this = _super.call(this) || this;\n    var log = options.log.createLog('default', _this);\n    var participants = new Map();\n    /* istanbul ignore next */\n    Object.defineProperties(_this, {\n      _log: {\n        value: log\n      },\n      _clientTrackSwitchOffControl: {\n        value: options.clientTrackSwitchOffControl || 'disabled'\n      },\n      _contentPreferencesMode: {\n        value: options.contentPreferencesMode || 'disabled'\n      },\n      _instanceId: {\n        value: ++nInstances\n      },\n      _options: {\n        value: options\n      },\n      _participants: {\n        value: participants\n      },\n      _signaling: {\n        value: signaling\n      },\n      dominantSpeaker: {\n        enumerable: true,\n        get: function () {\n          return this.participants.get(signaling.dominantSpeakerSid) || null;\n        }\n      },\n      isRecording: {\n        enumerable: true,\n        get: function () {\n          return signaling.recording.isEnabled || false;\n        }\n      },\n      localParticipant: {\n        enumerable: true,\n        value: localParticipant\n      },\n      name: {\n        enumerable: true,\n        value: signaling.name\n      },\n      participants: {\n        enumerable: true,\n        value: participants\n      },\n      sid: {\n        enumerable: true,\n        value: signaling.sid\n      },\n      state: {\n        enumerable: true,\n        get: function () {\n          return signaling.state;\n        }\n      },\n      mediaRegion: {\n        enumerable: true,\n        value: signaling.mediaRegion\n      }\n    });\n    handleLocalParticipantEvents(_this, localParticipant);\n    handleRecordingEvents(_this, signaling.recording);\n    handleSignalingEvents(_this, signaling);\n    verifyNoiseCancellation(_this);\n    log.info('Created a new Room:', _this.name);\n    log.debug('Initial RemoteParticipants:', Array.from(_this._participants.values()));\n    return _this;\n  }\n  Room.prototype.toString = function () {\n    return \"[Room #\" + this._instanceId + \": \" + this.sid + \"]\";\n  };\n  /**\n   * Disconnect from the {@link Room}.\n   * @returns {this}\n   */\n  Room.prototype.disconnect = function () {\n    this._log.info('Disconnecting');\n    this._signaling.disconnect();\n    return this;\n  };\n  /**\n   * Get the {@link Room}'s media statistics. This is not supported in Safari 12.0 or below\n   * due to this bug : https://bugs.webkit.org/show_bug.cgi?id=192601\n   *\n   * @returns {Promise.<Array<StatsReport>>}\n   */\n  Room.prototype.getStats = function () {\n    var _this = this;\n    return this._signaling.getStats().then(function (responses) {\n      return Array.from(responses).map(function (_a) {\n        var _b = __read(_a, 2),\n          id = _b[0],\n          response = _b[1];\n        return new StatsReport(id, Object.assign({}, response, {\n          localAudioTrackStats: rewriteLocalTrackIds(_this, response.localAudioTrackStats),\n          localVideoTrackStats: rewriteLocalTrackIds(_this, response.localVideoTrackStats)\n        }));\n      });\n    });\n  };\n  /**\n   * Restart the muted local media {@link Track}s and play inadvertently paused HTMLMediaElements\n   * that are attached to local and remote media {@link Track}s. This method is useful mainly on\n   * mobile browsers (Safari and Chrome on iOS), where there is a possibility that the muted local\n   * media {@link Track}s are never unmuted and inadvertently paused HTMLMediaElements are never\n   * played again, especially after handling an incoming phone call.\n   * @returns {this}\n   */\n  Room.prototype.refreshInactiveMedia = function () {\n    var localTrackPublications = this.localParticipant.tracks;\n    var localMediaTracks = Array.from(localTrackPublications.values()).filter(function (_a) {\n      var kind = _a.track.kind;\n      return kind !== 'data';\n    }).map(function (_a) {\n      var track = _a.track;\n      return track;\n    });\n    var remoteMediaTracks = flatMap(this.participants, function (participants) {\n      return Array.from(participants.tracks.values());\n    }).filter(function (_a) {\n      var track = _a.track;\n      return track && track.kind !== 'data';\n    }).map(function (_a) {\n      var track = _a.track;\n      return track;\n    });\n    var mediaTracks = localMediaTracks.concat(remoteMediaTracks);\n    var unmuteEvent = new Event('unmute');\n    localMediaTracks.forEach(function (_a) {\n      var isMuted = _a.isMuted,\n        mediaStreamTrack = _a.mediaStreamTrack;\n      if (isMuted) {\n        mediaStreamTrack.dispatchEvent(unmuteEvent);\n      }\n    });\n    var pauseEvent = new Event('pause');\n    mediaTracks.forEach(function (_a) {\n      var attachments = _a._attachments,\n        elShims = _a._elShims;\n      return attachments.forEach(function (el) {\n        var shim = elShims.get(el);\n        var isInadvertentlyPaused = el.paused && shim && !shim.pausedIntentionally();\n        if (isInadvertentlyPaused) {\n          el.dispatchEvent(pauseEvent);\n        }\n      });\n    });\n    return this;\n  };\n  Room.prototype.toJSON = function () {\n    return valueToJSON(this);\n  };\n  return Room;\n}(EventEmitter);\nfunction verifyNoiseCancellation(room) {\n  var allowedAudioProcessors = room.localParticipant._signaling.audioProcessors;\n  room.localParticipant.audioTracks.forEach(function (_a) {\n    var track = _a.track;\n    var noiseCancellation = track.noiseCancellation;\n    if (noiseCancellation && !allowedAudioProcessors.includes(noiseCancellation.vendor)) {\n      room._log.warn(noiseCancellation.vendor + \" is not supported in this room. disabling it permanently\");\n      noiseCancellation.disablePermanently();\n    }\n  });\n}\nfunction rewriteLocalTrackIds(room, trackStats) {\n  var localParticipantSignaling = room.localParticipant._signaling;\n  return trackStats.reduce(function (trackStats, trackStat) {\n    var publication = localParticipantSignaling.tracks.get(trackStat.trackId);\n    var trackSender = localParticipantSignaling.getSender(publication);\n    return trackSender ? [Object.assign({}, trackStat, {\n      trackId: trackSender.id\n    })].concat(trackStats) : trackStats;\n  }, []);\n}\n/**\n * A {@link Room.SID} is a 34-character string starting with \"RM\"\n * that uniquely identifies a {@link Room}.\n * @type string\n * @typedef Room.SID\n */\n/**\n * The Dominant Speaker in the {@link Room} changed. Either the Dominant Speaker\n * is a new {@link RemoteParticipant} or the Dominant Speaker has been reset and\n * is now null.\n * @param {?RemoteParticipant} dominantSpeaker - The Dominant Speaker in the\n *   {@link Room}, if any\n * @event Room#dominantSpeakerChanged\n */\n/**\n * Your {@link LocalParticipant} was disconnected from the {@link Room} and all\n * other {@link RemoteParticipant}s.\n * @param {Room} room - The {@link Room} your\n *   {@link LocalParticipant} was disconnected from\n * @param {?TwilioError} error - Present when the {@link LocalParticipant} got\n *   disconnected from the {@link Room} unexpectedly\n * @event Room#disconnected\n * @example\n * myRoom.on('disconnected', function(room, error) {\n *   if (error) {\n *     console.log('Unexpectedly disconnected:', error);\n *   }\n *   myRoom.localParticipant.tracks.forEach(function(track) {\n *     track.stop();\n *     track.detach();\n *   });\n * });\n */\n/**\n * A {@link RemoteParticipant} joined the {@link Room}. In Large Group Rooms (Maximum\n * Participants greater than 50), this event is raised only when a {@link RemoteParticipant}\n * publishes at least one {@link LocalTrack}.\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who joined\n * @event Room#participantConnected\n * @example\n * myRoom.on('participantConnected', function(participant) {\n *   console.log(participant.identity + ' joined the Room');\n * });\n */\n/**\n * A {@link RemoteParticipant} left the {@link Room}. In Large Group Rooms (Maximum\n * Participants greater than 50), this event is raised only when a {@link RemoteParticipant}\n * unpublishes all its {@link LocalTrack}s.\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who left\n * @event Room#participantDisconnected\n * @example\n * myRoom.on('participantDisconnected', function(participant) {\n *   console.log(participant.identity + ' left the Room');\n *   participant.tracks.forEach(function(track) {\n *     track.detach().forEach(function(mediaElement) {\n *       mediaElement.remove();\n *     });\n *   });\n * });\n */\n/**\n * A {@link RemoteParticipant} has reconnected to the {@link Room} after a signaling connection disruption.\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} that has reconnected.\n * @event Room#participantReconnected\n * @example\n * myRoom.on('participantReconnected', participant => {\n *   console.log(participant.identity + ' reconnected to the Room');\n * });\n */\n/**\n * A {@link RemoteParticipant} is reconnecting to the {@link Room} after a signaling connection disruption.\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} that is reconnecting.\n * @event Room#participantReconnecting\n * @example\n * myRoom.on('participantReconnecting', participant => {\n *   console.log(participant.identity + ' is reconnecting to the Room');\n * });\n */\n/**\n * Your application successfully reconnected to the {@link Room}. When this\n * event is emitted, the {@link Room} is in state \"connected\".\n * @event Room#reconnected\n * @example\n * myRoom.on('reconnected', () => {\n *   console.log('Reconnected!');\n * });\n */\n/**\n * Your application is reconnecting to the {@link Room}. This happens when there\n * is a disruption in your signaling connection and/or your media connection. When\n * this event is emitted, the {@link Room} is in state \"reconnecting\". If reconnecting\n * succeeds, the {@link Room} will emit a \"reconnected\" event.\n * @param {MediaConnectionError|SignalingConnectionDisconnectedError} error - A\n *   {@link MediaConnectionError} if your application is reconnecting due to a\n *   disruption in your media connection, or a {@link SignalingConnectionDisconnectedError}\n *   if your application is reconnecting due to a disruption in your signaling connection\n * @event Room#reconnecting\n * @example\n * myRoom.on('reconnecting', error => {\n *   if (error.code === 53001) {\n *     console.log('Reconnecting your signaling connection!', error.message);\n *   } else if (error.code === 53405) {\n *     console.log('Reconnecting your media connection!', error.message);\n *   }\n * });\n */\n/**\n * The {@link Room} is now being recorded\n * @event Room#recordingStarted\n */\n/**\n * The {@link Room} is no longer being recorded\n * @event Room#recordingStopped\n */\n/**\n * One of the {@link RemoteParticipant}'s {@link VideoTrack}'s dimensions changed.\n * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} whose dimensions changed\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteVideoTrack}'s dimensions changed\n * @event Room#trackDimensionsChanged\n */\n/**\n * A {@link RemoteTrack} was disabled by a {@link RemoteParticipant} in the {@link Room}.\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication} that represents disabled {@link RemoteTrack}\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who\n *   disabled the {@link RemoteTrack}\n * @event Room#trackDisabled\n */\n/**\n * A {@link RemoteTrack} was enabled by a {@link RemoteParticipant} in the {@link Room}.\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication} that represents enabled {@link RemoteTrack}\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who\n *   enabled the {@link RemoteTrack}\n * @event Room#trackEnabled\n */\n/**\n * A message was received over one of the {@link RemoteParticipant}'s\n * {@link RemoteDataTrack}'s.\n * @param {string|ArrayBuffer} data\n * @param {RemoteDataTrack} track - The {@link RemoteDataTrack} over which the\n *   message was received\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteDataTrack} received the message\n * @event Room#trackMessage\n */\n/**\n * A {@link RemoteTrack} was published by a {@link RemoteParticipant} after\n * connecting to the {@link Room}. This event is not emitted for\n * {@link RemoteTrack}s that were published while the {@link RemoteParticipant}\n * was connecting to the {@link Room}.\n * @event Room#trackPublished\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}\n *   which represents the published {@link RemoteTrack}\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who\n *   published the {@link RemoteTrack}\n * @example\n * function trackPublished(publication, participant) {\n *   console.log(`RemoteParticipant ${participant.sid} published Track ${publication.trackSid}`);\n * }\n *\n * // Handle RemoteTracks published after connecting to the Room.\n * room.on('trackPublished', trackPublished);\n *\n * room.on('participantConnected', participant => {\n *   // Handle RemoteTracks published while connecting to the Room.\n *   participant.trackPublications.forEach(publication => trackPublished(publication, participant));\n * });\n */\n/**\n * One of a {@link RemoteParticipant}'s {@link RemoteTrack}s in the {@link Room} started.\n * @param {RemoteTrack} track - The {@link RemoteTrack} that started\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} started\n * @event Room#trackStarted\n */\n/**\n * A {@link RemoteParticipant}'s {@link RemoteTrack} was subscribed to.\n * @param {RemoteTrack} track - The {@link RemoteTrack} that was subscribed\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}\n *   for the {@link RemoteTrack} that was subscribed to\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} was subscribed\n * @event Room#trackSubscribed\n * @example\n * room.on('trackSubscribed', function(track, publication, participant) {\n *   var participantView = document.getElementById('participant-view-' + participant.identity);\n *   participantView.appendChild(track.attach());\n * });\n */\n/**\n * A {@link RemoteParticipant}'s {@link RemoteTrack} was switched off.\n * @param {RemoteTrack} track - The {@link RemoteTrack} that was switched off\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}\n *   for the {@link RemoteTrack} that was subscribed to\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} was switched off\n * @event Room#trackSwitchedOff\n */\n/**\n * A {@link RemoteParticipant}'s {@link RemoteTrack} was switched on.\n * @param {RemoteTrack} track - The {@link RemoteTrack} that was switched on\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}\n *   for the {@link RemoteTrack} that was subscribed to\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} was switched on\n * @event Room#trackSwitchedOn\n */\n/**\n * A {@link RemoteParticipant}'s {@link RemoteTrack} could not be subscribed to.\n * @param {TwilioError} error - The reason the {@link RemoteTrack} could not be\n *   subscribed to\n * @param {RemoteTrackPublication} publication - The\n *   {@link RemoteTrackPublication} for the {@link RemoteTrack} that could not\n *   be subscribed to\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} could not be subscribed to\n * @event Room#trackSubscriptionFailed\n */\n/**\n * The {@link RemoteTrack}'s publish {@link Track.Priority} was changed by the\n * {@link RemoteParticipant}.\n * @param {Track.Priority} priority - the {@link RemoteTrack}'s new publish\n *   {@link Track.Priority};\n * @param {RemoteTrackPublication} publication - The\n *   {@link RemoteTrackPublication} for the {@link RemoteTrack} that changed priority\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} changed priority\n * @event Room#trackPublishPriorityChanged\n */\n/**\n * A {@link RemoteTrack} was unpublished by a {@link RemoteParticipant} to the {@link Room}.\n * @event Room#trackUnpublished\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}\n *   which represents the unpublished {@link RemoteTrack}\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who\n *   unpublished the {@link RemoteTrack}\n */\n/**\n * A {@link RemoteParticipant}'s {@link RemoteTrack} was unsubscribed from.\n * @param {RemoteTrack} track - The {@link RemoteTrack} that was unsubscribed\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}\n *   for the {@link RemoteTrack} that was unsubscribed from\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} was unsubscribed\n * @event Room#trackUnsubscribed\n * @example\n * room.on('trackUnsubscribed', function(track, publication, participant) {\n *   track.detach().forEach(function(mediaElement) {\n *     mediaElement.remove();\n *   });\n * });\n */\n/**\n * One of the {@link LocalParticipant}'s {@link LocalTrackPublication}s in the {@link Room} encountered a warning.\n * This event is only raised if you enabled warnings using <code>notifyWarnings</code> in <code>ConnectOptions</code>.\n * @param {string} name - The warning that was raised.\n * @param {LocalTrackPublication} publication - The {@link LocalTrackPublication} that encountered the warning.\n * @param {LocalParticipant} participant - The {@link LocalParticipant}\n * @event Room#trackWarning\n * @example\n * room.on('trackWarning', (name, publication, participant) => {\n *   if (name === 'recording-media-lost') {\n *     log(`LocalTrack ${publication.track.name} is not recording media.`,\n *       name, publication, participant);\n *\n *     // Wait a reasonable amount of time to clear the warning.\n *     const timer = setTimeout(() => {\n *       // If the warning is not cleared, you can manually\n *       // reconnect to the room, or show a dialog to the user\n *     }, 5000);\n *\n *     room.once('trackWarningsCleared', (publication, participant) => {\n *       log('LocalTrack warnings have cleared!',\n *         publication, participant);\n *       clearTimeout(timer);\n *     });\n *   }\n});\n */\n/**\n * One of the {@link LocalParticipant}'s {@link LocalTrackPublication}s in the {@link Room} cleared all warnings.\n * This event is only raised if you enabled warnings using <code>notifyWarnings</code> in <code>ConnectOptions</code>.\n * @param {LocalTrackPublication} publication - The {@link LocalTrackPublication} that cleared all warnings.\n * @param {LocalParticipant} participant - The {@link LocalParticipant}\n * @event Room#trackWarningsCleared\n */\nfunction connectParticipant(room, participantSignaling) {\n  var log = room._log,\n    clientTrackSwitchOffControl = room._clientTrackSwitchOffControl,\n    contentPreferencesMode = room._contentPreferencesMode;\n  var participant = new RemoteParticipant(participantSignaling, {\n    log: log,\n    clientTrackSwitchOffControl: clientTrackSwitchOffControl,\n    contentPreferencesMode: contentPreferencesMode\n  });\n  log.info('A new RemoteParticipant connected:', participant);\n  room._participants.set(participant.sid, participant);\n  room.emit('participantConnected', participant);\n  // Reemit Track and RemoteParticipant events.\n  var eventListeners = [['reconnected', 'participantReconnected'], ['reconnecting', 'participantReconnecting'], 'trackDimensionsChanged', 'trackDisabled', 'trackEnabled', 'trackMessage', 'trackPublished', 'trackPublishPriorityChanged', 'trackStarted', 'trackSubscribed', 'trackSubscriptionFailed', 'trackSwitchedOff', 'trackSwitchedOn', 'trackUnpublished', 'trackUnsubscribed'].map(function (eventOrPair) {\n    var _a = __read(Array.isArray(eventOrPair) ? eventOrPair : [eventOrPair, eventOrPair], 2),\n      event = _a[0],\n      participantEvent = _a[1];\n    function reemit() {\n      var args = [].slice.call(arguments);\n      args.unshift(participantEvent);\n      args.push(participant);\n      room.emit.apply(room, __spreadArray([], __read(args)));\n    }\n    participant.on(event, reemit);\n    return [event, reemit];\n  });\n  participant.once('disconnected', function participantDisconnected() {\n    var dominantSpeaker = room.dominantSpeaker;\n    log.info('RemoteParticipant disconnected:', participant);\n    room._participants.delete(participant.sid);\n    eventListeners.forEach(function (args) {\n      participant.removeListener(args[0], args[1]);\n    });\n    room.emit('participantDisconnected', participant);\n    if (participant === dominantSpeaker) {\n      room.emit('dominantSpeakerChanged', room.dominantSpeaker);\n    }\n  });\n}\nfunction handleLocalParticipantEvents(room, localParticipant) {\n  var events = ['trackWarning', 'trackWarningsCleared'].map(function (event) {\n    return {\n      eventName: event,\n      handler: function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        return room.emit.apply(room, __spreadArray([event], __read(__spreadArray(__spreadArray([], __read(args)), [localParticipant]))));\n      }\n    };\n  });\n  events.forEach(function (_a) {\n    var eventName = _a.eventName,\n      handler = _a.handler;\n    return localParticipant.on(eventName, handler);\n  });\n  room.once('disconnected', function () {\n    return events.forEach(function (_a) {\n      var eventName = _a.eventName,\n        handler = _a.handler;\n      return localParticipant.removeListener(eventName, handler);\n    });\n  });\n}\nfunction handleRecordingEvents(room, recording) {\n  recording.on('updated', function updated() {\n    var started = recording.isEnabled;\n    room._log.info(\"Recording \" + (started ? 'started' : 'stopped'));\n    room.emit(\"recording\" + (started ? 'Started' : 'Stopped'));\n  });\n}\nfunction handleSignalingEvents(room, signaling) {\n  var log = room._log;\n  // Reemit RemoteParticipant events from the RoomSignaling.\n  log.debug('Creating a new RemoteParticipant for each ParticipantSignaling ' + 'in the RoomSignaling');\n  signaling.participants.forEach(connectParticipant.bind(null, room));\n  log.debug('Setting up RemoteParticipant creation for all subsequent ' + 'ParticipantSignalings that connect to the RoomSignaling');\n  signaling.on('participantConnected', connectParticipant.bind(null, room));\n  signaling.on('dominantSpeakerChanged', function () {\n    return room.emit('dominantSpeakerChanged', room.dominantSpeaker);\n  });\n  // Reemit state transition events from the RoomSignaling.\n  signaling.on('stateChanged', function stateChanged(state, error) {\n    log.info('Transitioned to state:', state);\n    switch (state) {\n      case 'disconnected':\n        room.participants.forEach(function (participant) {\n          participant._unsubscribeTracks();\n        });\n        room.emit(state, room, error);\n        room.localParticipant.tracks.forEach(function (publication) {\n          publication.unpublish();\n        });\n        signaling.removeListener('stateChanged', stateChanged);\n        break;\n      case 'reconnecting':\n        // NOTE(mpatwardhan): `stateChanged` can get emitted with StateMachine locked.\n        // Do not signal  public events synchronously with lock held.\n        setTimeout(function () {\n          return room.emit('reconnecting', error);\n        }, 0);\n        break;\n      default:\n        // NOTE(mpatwardhan): `stateChanged` can get emitted with StateMachine locked.\n        // Do not signal  public events synchronously with lock held.\n        setTimeout(function () {\n          return room.emit('reconnected');\n        }, 0);\n    }\n  });\n}\nmodule.exports = Room;","map":{"version":3,"names":["EventEmitter","require","RemoteParticipant","StatsReport","_a","flatMap","valueToJSON","nInstances","Room","_super","__extends","localParticipant","signaling","options","_this","call","log","createLog","participants","Map","Object","defineProperties","_log","value","_clientTrackSwitchOffControl","clientTrackSwitchOffControl","_contentPreferencesMode","contentPreferencesMode","_instanceId","_options","_participants","_signaling","dominantSpeaker","enumerable","get","dominantSpeakerSid","isRecording","recording","isEnabled","name","sid","state","mediaRegion","handleLocalParticipantEvents","handleRecordingEvents","handleSignalingEvents","verifyNoiseCancellation","info","debug","Array","from","values","prototype","toString","disconnect","getStats","then","responses","map","_b","__read","id","response","assign","localAudioTrackStats","rewriteLocalTrackIds","localVideoTrackStats","refreshInactiveMedia","localTrackPublications","tracks","localMediaTracks","filter","kind","track","remoteMediaTracks","mediaTracks","concat","unmuteEvent","Event","forEach","isMuted","mediaStreamTrack","dispatchEvent","pauseEvent","attachments","_attachments","elShims","_elShims","el","shim","isInadvertentlyPaused","paused","pausedIntentionally","toJSON","room","allowedAudioProcessors","audioProcessors","audioTracks","noiseCancellation","includes","vendor","warn","disablePermanently","trackStats","localParticipantSignaling","reduce","trackStat","publication","trackId","trackSender","getSender","connectParticipant","participantSignaling","participant","set","emit","eventListeners","eventOrPair","isArray","event","participantEvent","reemit","args","slice","arguments","unshift","push","apply","__spreadArray","on","once","participantDisconnected","delete","removeListener","events","eventName","handler","_i","length","updated","started","bind","stateChanged","error","_unsubscribeTracks","unpublish","setTimeout","module","exports"],"sources":["/home/denis/RiderProjects/ChatRoulette/WebUI/chat-app/node_modules/twilio-video/lib/room.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('./eventemitter');\nconst RemoteParticipant = require('./remoteparticipant');\nconst StatsReport = require('./stats/statsreport');\nconst { flatMap, valueToJSON } = require('./util');\n\nlet nInstances = 0;\n\n/**\n * A {@link Room} represents communication between you and one or more\n * {@link RemoteParticipant}s sharing {@link AudioTrack}s and\n * {@link VideoTrack}s.\n * <br><br>\n * You can connect to a {@link Room} by calling {@link module:twilio-video.connect}.\n * @extends EventEmitter\n * @property {?RemoteParticipant} dominantSpeaker - The Dominant Speaker in the\n *   {@link Room}, if any\n * @property {boolean} isRecording - Whether or not the {@link Room} is being\n *   recorded\n * @property {LocalParticipant} localParticipant - Your {@link LocalParticipant}\n *   in the {@link Room}\n * @property {string} mediaRegion - String indicating geographical region\n *    where  media is processed for the {@link Room}.\n * @property {string} name - The {@link Room}'s name\n * @property {Map<Participant.SID, RemoteParticipant>} participants -\n *   The {@link RemoteParticipant}s participating in this {@link Room}\n * @property {Room.SID} sid - The {@link Room}'s SID\n * @property {string} state - \"connected\", \"reconnecting\", or \"disconnected\"\n * @throws {SignalingConnectionDisconnectedError}\n * @emits Room#disconnected\n * @emits Room#participantConnected\n * @emits Room#participantDisconnected\n * @emits Room#participantReconnected\n * @emits Room#participantReconnecting\n * @emits Room#reconnected\n * @emits Room#reconnecting\n * @emits Room#recordingStarted\n * @emits Room#recordingStopped\n * @emits Room#trackDimensionsChanged\n * @emits Room#trackDisabled\n * @emits Room#trackEnabled\n * @emits Room#trackMessage\n * @emits Room#trackPublished\n * @emits Room#trackPublishPriorityChanged\n * @emits Room#trackStarted\n * @emits Room#trackSubscribed\n * @emits Room#trackSwitchedOff\n * @emits Room#trackSwitchedOn\n * @emits Room#trackUnpublished\n * @emits Room#trackUnsubscribed\n * @emits Room#trackWarning\n * @emits Room#trackWarningsCleared\n */\nclass Room extends EventEmitter {\n  /**\n   * Construct a {@link Room}.\n   * @param {RoomSignaling} signaling\n   * @param {?object} [options={}]\n   */\n  constructor(localParticipant, signaling, options) {\n    super();\n\n    const log = options.log.createLog('default', this);\n    const participants = new Map();\n\n    /* istanbul ignore next */\n    Object.defineProperties(this, {\n      _log: {\n        value: log\n      },\n      _clientTrackSwitchOffControl: {\n        value: options.clientTrackSwitchOffControl || 'disabled'\n      },\n      _contentPreferencesMode: {\n        value: options.contentPreferencesMode || 'disabled'\n      },\n      _instanceId: {\n        value: ++nInstances\n      },\n      _options: {\n        value: options\n      },\n      _participants: {\n        value: participants\n      },\n      _signaling: {\n        value: signaling\n      },\n      dominantSpeaker: {\n        enumerable: true,\n        get() {\n          return this.participants.get(signaling.dominantSpeakerSid) || null;\n        }\n      },\n      isRecording: {\n        enumerable: true,\n        get() {\n          return signaling.recording.isEnabled || false;\n        }\n      },\n      localParticipant: {\n        enumerable: true,\n        value: localParticipant\n      },\n      name: {\n        enumerable: true,\n        value: signaling.name\n      },\n      participants: {\n        enumerable: true,\n        value: participants\n      },\n      sid: {\n        enumerable: true,\n        value: signaling.sid\n      },\n      state: {\n        enumerable: true,\n        get() {\n          return signaling.state;\n        }\n      },\n      mediaRegion: {\n        enumerable: true,\n        value: signaling.mediaRegion\n      }\n    });\n\n    handleLocalParticipantEvents(this, localParticipant);\n    handleRecordingEvents(this, signaling.recording);\n    handleSignalingEvents(this, signaling);\n    verifyNoiseCancellation(this);\n\n    log.info('Created a new Room:', this.name);\n    log.debug('Initial RemoteParticipants:', Array.from(this._participants.values()));\n  }\n\n  toString() {\n    return `[Room #${this._instanceId}: ${this.sid}]`;\n  }\n\n\n  /**\n   * Disconnect from the {@link Room}.\n   * @returns {this}\n   */\n  disconnect() {\n    this._log.info('Disconnecting');\n    this._signaling.disconnect();\n    return this;\n  }\n\n  /**\n   * Get the {@link Room}'s media statistics. This is not supported in Safari 12.0 or below\n   * due to this bug : https://bugs.webkit.org/show_bug.cgi?id=192601\n   *\n   * @returns {Promise.<Array<StatsReport>>}\n   */\n  getStats() {\n    return this._signaling.getStats().then(responses =>\n      Array.from(responses).map(([id, response]) =>\n        new StatsReport(id, Object.assign({}, response, {\n          localAudioTrackStats: rewriteLocalTrackIds(this, response.localAudioTrackStats),\n          localVideoTrackStats: rewriteLocalTrackIds(this, response.localVideoTrackStats)\n        }))\n      )\n    );\n  }\n\n  /**\n   * Restart the muted local media {@link Track}s and play inadvertently paused HTMLMediaElements\n   * that are attached to local and remote media {@link Track}s. This method is useful mainly on\n   * mobile browsers (Safari and Chrome on iOS), where there is a possibility that the muted local\n   * media {@link Track}s are never unmuted and inadvertently paused HTMLMediaElements are never\n   * played again, especially after handling an incoming phone call.\n   * @returns {this}\n   */\n  refreshInactiveMedia() {\n    const { tracks: localTrackPublications } = this.localParticipant;\n\n    const localMediaTracks = Array.from(localTrackPublications.values())\n      .filter(({ track: { kind } }) => kind !== 'data')\n      .map(({ track }) => track);\n\n    const remoteMediaTracks = flatMap(this.participants, participants => Array.from(participants.tracks.values()))\n      .filter(({ track }) => track && track.kind !== 'data')\n      .map(({ track }) => track);\n\n    const mediaTracks = localMediaTracks.concat(remoteMediaTracks);\n\n    const unmuteEvent = new Event('unmute');\n    localMediaTracks.forEach(({ isMuted, mediaStreamTrack }) => {\n      if (isMuted) {\n        mediaStreamTrack.dispatchEvent(unmuteEvent);\n      }\n    });\n\n    const pauseEvent = new Event('pause');\n    mediaTracks.forEach(({ _attachments: attachments, _elShims: elShims }) => attachments.forEach(el => {\n      const shim = elShims.get(el);\n      const isInadvertentlyPaused = el.paused && shim && !shim.pausedIntentionally();\n      if (isInadvertentlyPaused) {\n        el.dispatchEvent(pauseEvent);\n      }\n    }));\n\n    return this;\n  }\n\n  toJSON() {\n    return valueToJSON(this);\n  }\n}\n\nfunction verifyNoiseCancellation(room) {\n  const allowedAudioProcessors = room.localParticipant._signaling.audioProcessors;\n  room.localParticipant.audioTracks.forEach(({ track }) => {\n    const noiseCancellation = track.noiseCancellation;\n    if (noiseCancellation && !allowedAudioProcessors.includes(noiseCancellation.vendor)) {\n      room._log.warn(`${noiseCancellation.vendor} is not supported in this room. disabling it permanently`);\n      noiseCancellation.disablePermanently();\n    }\n  });\n}\n\nfunction rewriteLocalTrackIds(room, trackStats) {\n  const localParticipantSignaling = room.localParticipant._signaling;\n  return trackStats.reduce((trackStats, trackStat) => {\n    const publication = localParticipantSignaling.tracks.get(trackStat.trackId);\n    const trackSender = localParticipantSignaling.getSender(publication);\n    return trackSender\n      ? [Object.assign({}, trackStat, { trackId: trackSender.id })].concat(trackStats)\n      : trackStats;\n  }, []);\n}\n\n/**\n * A {@link Room.SID} is a 34-character string starting with \"RM\"\n * that uniquely identifies a {@link Room}.\n * @type string\n * @typedef Room.SID\n */\n\n/**\n * The Dominant Speaker in the {@link Room} changed. Either the Dominant Speaker\n * is a new {@link RemoteParticipant} or the Dominant Speaker has been reset and\n * is now null.\n * @param {?RemoteParticipant} dominantSpeaker - The Dominant Speaker in the\n *   {@link Room}, if any\n * @event Room#dominantSpeakerChanged\n */\n\n/**\n * Your {@link LocalParticipant} was disconnected from the {@link Room} and all\n * other {@link RemoteParticipant}s.\n * @param {Room} room - The {@link Room} your\n *   {@link LocalParticipant} was disconnected from\n * @param {?TwilioError} error - Present when the {@link LocalParticipant} got\n *   disconnected from the {@link Room} unexpectedly\n * @event Room#disconnected\n * @example\n * myRoom.on('disconnected', function(room, error) {\n *   if (error) {\n *     console.log('Unexpectedly disconnected:', error);\n *   }\n *   myRoom.localParticipant.tracks.forEach(function(track) {\n *     track.stop();\n *     track.detach();\n *   });\n * });\n */\n\n/**\n * A {@link RemoteParticipant} joined the {@link Room}. In Large Group Rooms (Maximum\n * Participants greater than 50), this event is raised only when a {@link RemoteParticipant}\n * publishes at least one {@link LocalTrack}.\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who joined\n * @event Room#participantConnected\n * @example\n * myRoom.on('participantConnected', function(participant) {\n *   console.log(participant.identity + ' joined the Room');\n * });\n */\n\n/**\n * A {@link RemoteParticipant} left the {@link Room}. In Large Group Rooms (Maximum\n * Participants greater than 50), this event is raised only when a {@link RemoteParticipant}\n * unpublishes all its {@link LocalTrack}s.\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who left\n * @event Room#participantDisconnected\n * @example\n * myRoom.on('participantDisconnected', function(participant) {\n *   console.log(participant.identity + ' left the Room');\n *   participant.tracks.forEach(function(track) {\n *     track.detach().forEach(function(mediaElement) {\n *       mediaElement.remove();\n *     });\n *   });\n * });\n */\n\n/**\n * A {@link RemoteParticipant} has reconnected to the {@link Room} after a signaling connection disruption.\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} that has reconnected.\n * @event Room#participantReconnected\n * @example\n * myRoom.on('participantReconnected', participant => {\n *   console.log(participant.identity + ' reconnected to the Room');\n * });\n */\n\n/**\n * A {@link RemoteParticipant} is reconnecting to the {@link Room} after a signaling connection disruption.\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} that is reconnecting.\n * @event Room#participantReconnecting\n * @example\n * myRoom.on('participantReconnecting', participant => {\n *   console.log(participant.identity + ' is reconnecting to the Room');\n * });\n */\n\n/**\n * Your application successfully reconnected to the {@link Room}. When this\n * event is emitted, the {@link Room} is in state \"connected\".\n * @event Room#reconnected\n * @example\n * myRoom.on('reconnected', () => {\n *   console.log('Reconnected!');\n * });\n */\n\n/**\n * Your application is reconnecting to the {@link Room}. This happens when there\n * is a disruption in your signaling connection and/or your media connection. When\n * this event is emitted, the {@link Room} is in state \"reconnecting\". If reconnecting\n * succeeds, the {@link Room} will emit a \"reconnected\" event.\n * @param {MediaConnectionError|SignalingConnectionDisconnectedError} error - A\n *   {@link MediaConnectionError} if your application is reconnecting due to a\n *   disruption in your media connection, or a {@link SignalingConnectionDisconnectedError}\n *   if your application is reconnecting due to a disruption in your signaling connection\n * @event Room#reconnecting\n * @example\n * myRoom.on('reconnecting', error => {\n *   if (error.code === 53001) {\n *     console.log('Reconnecting your signaling connection!', error.message);\n *   } else if (error.code === 53405) {\n *     console.log('Reconnecting your media connection!', error.message);\n *   }\n * });\n */\n\n/**\n * The {@link Room} is now being recorded\n * @event Room#recordingStarted\n */\n\n/**\n * The {@link Room} is no longer being recorded\n * @event Room#recordingStopped\n */\n\n/**\n * One of the {@link RemoteParticipant}'s {@link VideoTrack}'s dimensions changed.\n * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} whose dimensions changed\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteVideoTrack}'s dimensions changed\n * @event Room#trackDimensionsChanged\n */\n\n/**\n * A {@link RemoteTrack} was disabled by a {@link RemoteParticipant} in the {@link Room}.\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication} that represents disabled {@link RemoteTrack}\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who\n *   disabled the {@link RemoteTrack}\n * @event Room#trackDisabled\n */\n\n/**\n * A {@link RemoteTrack} was enabled by a {@link RemoteParticipant} in the {@link Room}.\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication} that represents enabled {@link RemoteTrack}\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who\n *   enabled the {@link RemoteTrack}\n * @event Room#trackEnabled\n */\n\n/**\n * A message was received over one of the {@link RemoteParticipant}'s\n * {@link RemoteDataTrack}'s.\n * @param {string|ArrayBuffer} data\n * @param {RemoteDataTrack} track - The {@link RemoteDataTrack} over which the\n *   message was received\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteDataTrack} received the message\n * @event Room#trackMessage\n */\n\n/**\n * A {@link RemoteTrack} was published by a {@link RemoteParticipant} after\n * connecting to the {@link Room}. This event is not emitted for\n * {@link RemoteTrack}s that were published while the {@link RemoteParticipant}\n * was connecting to the {@link Room}.\n * @event Room#trackPublished\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}\n *   which represents the published {@link RemoteTrack}\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who\n *   published the {@link RemoteTrack}\n * @example\n * function trackPublished(publication, participant) {\n *   console.log(`RemoteParticipant ${participant.sid} published Track ${publication.trackSid}`);\n * }\n *\n * // Handle RemoteTracks published after connecting to the Room.\n * room.on('trackPublished', trackPublished);\n *\n * room.on('participantConnected', participant => {\n *   // Handle RemoteTracks published while connecting to the Room.\n *   participant.trackPublications.forEach(publication => trackPublished(publication, participant));\n * });\n */\n\n/**\n * One of a {@link RemoteParticipant}'s {@link RemoteTrack}s in the {@link Room} started.\n * @param {RemoteTrack} track - The {@link RemoteTrack} that started\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} started\n * @event Room#trackStarted\n */\n\n/**\n * A {@link RemoteParticipant}'s {@link RemoteTrack} was subscribed to.\n * @param {RemoteTrack} track - The {@link RemoteTrack} that was subscribed\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}\n *   for the {@link RemoteTrack} that was subscribed to\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} was subscribed\n * @event Room#trackSubscribed\n * @example\n * room.on('trackSubscribed', function(track, publication, participant) {\n *   var participantView = document.getElementById('participant-view-' + participant.identity);\n *   participantView.appendChild(track.attach());\n * });\n */\n\n/**\n * A {@link RemoteParticipant}'s {@link RemoteTrack} was switched off.\n * @param {RemoteTrack} track - The {@link RemoteTrack} that was switched off\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}\n *   for the {@link RemoteTrack} that was subscribed to\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} was switched off\n * @event Room#trackSwitchedOff\n */\n\n/**\n * A {@link RemoteParticipant}'s {@link RemoteTrack} was switched on.\n * @param {RemoteTrack} track - The {@link RemoteTrack} that was switched on\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}\n *   for the {@link RemoteTrack} that was subscribed to\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} was switched on\n * @event Room#trackSwitchedOn\n */\n\n/**\n * A {@link RemoteParticipant}'s {@link RemoteTrack} could not be subscribed to.\n * @param {TwilioError} error - The reason the {@link RemoteTrack} could not be\n *   subscribed to\n * @param {RemoteTrackPublication} publication - The\n *   {@link RemoteTrackPublication} for the {@link RemoteTrack} that could not\n *   be subscribed to\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} could not be subscribed to\n * @event Room#trackSubscriptionFailed\n */\n\n/**\n * The {@link RemoteTrack}'s publish {@link Track.Priority} was changed by the\n * {@link RemoteParticipant}.\n * @param {Track.Priority} priority - the {@link RemoteTrack}'s new publish\n *   {@link Track.Priority};\n * @param {RemoteTrackPublication} publication - The\n *   {@link RemoteTrackPublication} for the {@link RemoteTrack} that changed priority\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} changed priority\n * @event Room#trackPublishPriorityChanged\n */\n\n/**\n * A {@link RemoteTrack} was unpublished by a {@link RemoteParticipant} to the {@link Room}.\n * @event Room#trackUnpublished\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}\n *   which represents the unpublished {@link RemoteTrack}\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who\n *   unpublished the {@link RemoteTrack}\n */\n\n/**\n * A {@link RemoteParticipant}'s {@link RemoteTrack} was unsubscribed from.\n * @param {RemoteTrack} track - The {@link RemoteTrack} that was unsubscribed\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}\n *   for the {@link RemoteTrack} that was unsubscribed from\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} was unsubscribed\n * @event Room#trackUnsubscribed\n * @example\n * room.on('trackUnsubscribed', function(track, publication, participant) {\n *   track.detach().forEach(function(mediaElement) {\n *     mediaElement.remove();\n *   });\n * });\n */\n\n/**\n * One of the {@link LocalParticipant}'s {@link LocalTrackPublication}s in the {@link Room} encountered a warning.\n * This event is only raised if you enabled warnings using <code>notifyWarnings</code> in <code>ConnectOptions</code>.\n * @param {string} name - The warning that was raised.\n * @param {LocalTrackPublication} publication - The {@link LocalTrackPublication} that encountered the warning.\n * @param {LocalParticipant} participant - The {@link LocalParticipant}\n * @event Room#trackWarning\n * @example\n * room.on('trackWarning', (name, publication, participant) => {\n *   if (name === 'recording-media-lost') {\n *     log(`LocalTrack ${publication.track.name} is not recording media.`,\n *       name, publication, participant);\n *\n *     // Wait a reasonable amount of time to clear the warning.\n *     const timer = setTimeout(() => {\n *       // If the warning is not cleared, you can manually\n *       // reconnect to the room, or show a dialog to the user\n *     }, 5000);\n *\n *     room.once('trackWarningsCleared', (publication, participant) => {\n *       log('LocalTrack warnings have cleared!',\n *         publication, participant);\n *       clearTimeout(timer);\n *     });\n *   }\n});\n */\n\n/**\n * One of the {@link LocalParticipant}'s {@link LocalTrackPublication}s in the {@link Room} cleared all warnings.\n * This event is only raised if you enabled warnings using <code>notifyWarnings</code> in <code>ConnectOptions</code>.\n * @param {LocalTrackPublication} publication - The {@link LocalTrackPublication} that cleared all warnings.\n * @param {LocalParticipant} participant - The {@link LocalParticipant}\n * @event Room#trackWarningsCleared\n */\n\nfunction connectParticipant(room, participantSignaling) {\n  const { _log: log, _clientTrackSwitchOffControl: clientTrackSwitchOffControl, _contentPreferencesMode: contentPreferencesMode } = room;\n  const participant = new RemoteParticipant(participantSignaling, { log, clientTrackSwitchOffControl, contentPreferencesMode });\n\n  log.info('A new RemoteParticipant connected:', participant);\n  room._participants.set(participant.sid, participant);\n  room.emit('participantConnected', participant);\n\n  // Reemit Track and RemoteParticipant events.\n  const eventListeners = [\n    ['reconnected', 'participantReconnected'],\n    ['reconnecting', 'participantReconnecting'],\n    'trackDimensionsChanged',\n    'trackDisabled',\n    'trackEnabled',\n    'trackMessage',\n    'trackPublished',\n    'trackPublishPriorityChanged',\n    'trackStarted',\n    'trackSubscribed',\n    'trackSubscriptionFailed',\n    'trackSwitchedOff',\n    'trackSwitchedOn',\n    'trackUnpublished',\n    'trackUnsubscribed'\n  ].map(eventOrPair => {\n    const [event, participantEvent] = Array.isArray(eventOrPair)\n      ? eventOrPair\n      : [eventOrPair, eventOrPair];\n\n    function reemit() {\n      const args = [].slice.call(arguments);\n      args.unshift(participantEvent);\n      args.push(participant);\n      room.emit(...args);\n    }\n    participant.on(event, reemit);\n    return [event, reemit];\n  });\n\n  participant.once('disconnected', function participantDisconnected() {\n    const dominantSpeaker = room.dominantSpeaker;\n    log.info('RemoteParticipant disconnected:', participant);\n    room._participants.delete(participant.sid);\n    eventListeners.forEach(args => {\n      participant.removeListener(args[0], args[1]);\n    });\n    room.emit('participantDisconnected', participant);\n    if (participant === dominantSpeaker) {\n      room.emit('dominantSpeakerChanged', room.dominantSpeaker);\n    }\n  });\n}\n\nfunction handleLocalParticipantEvents(room, localParticipant) {\n  const events = ['trackWarning', 'trackWarningsCleared'].map(event => ({\n    eventName: event,\n    handler: (...args) => room.emit(event, ...[...args, localParticipant]),\n  }));\n\n  events.forEach(({ eventName, handler }) =>\n    localParticipant.on(eventName, handler));\n\n  room.once('disconnected', () =>\n    events.forEach(({ eventName, handler }) =>\n      localParticipant.removeListener(eventName, handler)));\n}\n\nfunction handleRecordingEvents(room, recording) {\n  recording.on('updated', function updated() {\n    const started = recording.isEnabled;\n    room._log.info(`Recording ${started ? 'started' : 'stopped'}`);\n    room.emit(`recording${started ? 'Started' : 'Stopped'}`);\n  });\n}\n\nfunction handleSignalingEvents(room, signaling) {\n  const log = room._log;\n\n  // Reemit RemoteParticipant events from the RoomSignaling.\n  log.debug('Creating a new RemoteParticipant for each ParticipantSignaling '\n    + 'in the RoomSignaling');\n  signaling.participants.forEach(connectParticipant.bind(null, room));\n  log.debug('Setting up RemoteParticipant creation for all subsequent '\n    + 'ParticipantSignalings that connect to the RoomSignaling');\n  signaling.on('participantConnected', connectParticipant.bind(null, room));\n\n  signaling.on('dominantSpeakerChanged', () => room.emit('dominantSpeakerChanged', room.dominantSpeaker));\n\n  // Reemit state transition events from the RoomSignaling.\n  signaling.on('stateChanged', function stateChanged(state, error) {\n    log.info('Transitioned to state:', state);\n    switch (state) {\n      case 'disconnected':\n        room.participants.forEach(participant => {\n          participant._unsubscribeTracks();\n        });\n        room.emit(state, room, error);\n        room.localParticipant.tracks.forEach(publication => {\n          publication.unpublish();\n        });\n        signaling.removeListener('stateChanged', stateChanged);\n        break;\n      case 'reconnecting':\n\n        // NOTE(mpatwardhan): `stateChanged` can get emitted with StateMachine locked.\n        // Do not signal  public events synchronously with lock held.\n        setTimeout(() => room.emit('reconnecting', error), 0);\n\n        break;\n      default:\n\n        // NOTE(mpatwardhan): `stateChanged` can get emitted with StateMachine locked.\n        // Do not signal  public events synchronously with lock held.\n        setTimeout(() => room.emit('reconnected'), 0);\n    }\n  });\n}\n\nmodule.exports = Room;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}