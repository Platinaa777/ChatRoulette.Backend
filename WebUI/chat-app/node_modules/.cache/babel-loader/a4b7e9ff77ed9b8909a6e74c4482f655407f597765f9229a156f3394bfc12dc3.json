{"ast":null,"code":"/* globals RTCPeerConnection */\n'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nvar EventTarget = require('../../eventtarget');\nvar FirefoxRTCSessionDescription = require('../rtcsessiondescription/firefox');\nvar updateTracksToSSRCs = require('../util/sdp').updateUnifiedPlanTrackIdsToSSRCs;\nvar _a = require('../util'),\n  delegateMethods = _a.delegateMethods,\n  interceptEvent = _a.interceptEvent,\n  legacyPromise = _a.legacyPromise,\n  proxyProperties = _a.proxyProperties;\n// NOTE(mroberts): This class wraps Firefox's RTCPeerConnection implementation.\n// It provides some functionality not currently present in Firefox, namely the\n// abilities to\n//\n//   1. Call setLocalDescription and setRemoteDescription with new offers in\n//      signalingStates \"have-local-offer\" and \"have-remote-offer\",\n//      respectively.\n//\n//   2. The ability to call createOffer in signalingState \"have-local-offer\".\n//\n// Both of these are implemented using rollbacks to workaround the following\n// bug:\n//\n//   https://bugzilla.mozilla.org/show_bug.cgi?id=1072388\n//\n// We also provide a workaround for a bug where Firefox may change the\n// previously-negotiated DTLS role in an answer, which breaks Chrome:\n//\n//     https://bugzilla.mozilla.org/show_bug.cgi?id=1240897\n//\nvar FirefoxRTCPeerConnection = /** @class */function (_super) {\n  __extends(FirefoxRTCPeerConnection, _super);\n  function FirefoxRTCPeerConnection(configuration) {\n    var _this = _super.call(this) || this;\n    interceptEvent(_this, 'signalingstatechange');\n    /* eslint new-cap:0 */\n    var peerConnection = new RTCPeerConnection(configuration);\n    Object.defineProperties(_this, {\n      _initiallyNegotiatedDtlsRole: {\n        value: null,\n        writable: true\n      },\n      _isClosed: {\n        value: false,\n        writable: true\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _rollingBack: {\n        value: false,\n        writable: true\n      },\n      _tracksToSSRCs: {\n        value: new Map()\n      },\n      // NOTE(mmalavalli): Firefox throws a TypeError when the PeerConnection's\n      // prototype's \"peerIdentity\" property is accessed. In order to overcome\n      // this, we ignore this property while delegating methods.\n      // Reference: https://bugzilla.mozilla.org/show_bug.cgi?id=1363815\n      peerIdentity: {\n        enumerable: true,\n        value: Promise.resolve({\n          idp: '',\n          name: ''\n        })\n      }\n    });\n    var previousSignalingState;\n    peerConnection.addEventListener('signalingstatechange', function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      if (!_this._rollingBack && _this.signalingState !== previousSignalingState) {\n        previousSignalingState = _this.signalingState;\n        // NOTE(mmalavalli): In Firefox, 'signalingstatechange' event is\n        // triggered synchronously in the same tick after\n        // RTCPeerConnection#close() is called. So we mimic Chrome's behavior\n        // by triggering 'signalingstatechange' on the next tick.\n        if (_this._isClosed) {\n          setTimeout(function () {\n            return _this.dispatchEvent.apply(_this, __spreadArray([], __read(args)));\n          });\n        } else {\n          _this.dispatchEvent.apply(_this, __spreadArray([], __read(args)));\n        }\n      }\n    });\n    proxyProperties(RTCPeerConnection.prototype, _this, peerConnection);\n    return _this;\n  }\n  Object.defineProperty(FirefoxRTCPeerConnection.prototype, \"iceGatheringState\", {\n    get: function () {\n      return this._isClosed ? 'complete' : this._peerConnection.iceGatheringState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FirefoxRTCPeerConnection.prototype, \"localDescription\", {\n    get: function () {\n      return overwriteWithInitiallyNegotiatedDtlsRole(this._peerConnection.localDescription, this._initiallyNegotiatedDtlsRole);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FirefoxRTCPeerConnection.prototype, \"signalingState\", {\n    get: function () {\n      return this._isClosed ? 'closed' : this._peerConnection.signalingState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  FirefoxRTCPeerConnection.prototype.createAnswer = function () {\n    var _this = this;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var promise;\n    promise = this._peerConnection.createAnswer().then(function (answer) {\n      saveInitiallyNegotiatedDtlsRole(_this, answer);\n      return overwriteWithInitiallyNegotiatedDtlsRole(answer, _this._initiallyNegotiatedDtlsRole);\n    });\n    return typeof args[0] === 'function' ? legacyPromise.apply(void 0, __spreadArray([promise], __read(args))) : promise;\n  };\n  // NOTE(mroberts): The WebRTC spec allows you to call createOffer from any\n  // signalingState other than \"closed\"; however, Firefox has not yet implemented\n  // this (https://bugzilla.mozilla.org/show_bug.cgi?id=1072388). We workaround\n  // this by rolling back if we are in state \"have-local-offer\" or\n  // \"have-remote-offer\". This is acceptable for our use case because we will\n  // apply the newly-created offer almost immediately; however, this may be\n  // unacceptable for other use cases.\n  FirefoxRTCPeerConnection.prototype.createOffer = function () {\n    var _this = this;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var _a = __read(args, 3),\n      arg1 = _a[0],\n      arg2 = _a[1],\n      arg3 = _a[2];\n    var options = arg3 || arg1 || {};\n    var promise;\n    if (this.signalingState === 'have-local-offer' || this.signalingState === 'have-remote-offer') {\n      var local = this.signalingState === 'have-local-offer';\n      promise = rollback(this, local, function () {\n        return _this.createOffer(options);\n      });\n    } else {\n      promise = this._peerConnection.createOffer(options);\n    }\n    promise = promise.then(function (offer) {\n      return new FirefoxRTCSessionDescription({\n        type: offer.type,\n        sdp: updateTracksToSSRCs(_this._tracksToSSRCs, offer.sdp)\n      });\n    });\n    return args.length > 1 ? legacyPromise(promise, arg1, arg2) : promise;\n  };\n  // NOTE(mroberts): While Firefox will reject the Promise returned by\n  // setLocalDescription when called from signalingState \"have-local-offer\" with\n  // an answer, it still updates the .localDescription property. We workaround\n  // this by explicitly handling this case.\n  FirefoxRTCPeerConnection.prototype.setLocalDescription = function () {\n    var _a;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var _b = __read(args),\n      description = _b[0],\n      rest = _b.slice(1);\n    var promise;\n    if (description && description.type === 'answer' && this.signalingState === 'have-local-offer') {\n      promise = Promise.reject(new Error('Cannot set local answer in state have-local-offer'));\n    }\n    if (promise) {\n      return args.length > 1 ? legacyPromise.apply(void 0, __spreadArray([promise], __read(rest))) : promise;\n    }\n    return (_a = this._peerConnection).setLocalDescription.apply(_a, __spreadArray([], __read(args)));\n  };\n  // NOTE(mroberts): The WebRTC spec allows you to call setRemoteDescription with\n  // an offer multiple times in signalingState \"have-remote-offer\"; however,\n  // Firefox has not yet implemented this (https://bugzilla.mozilla.org/show_bug.cgi?id=1072388).\n  // We workaround this by rolling back if we are in state \"have-remote-offer\".\n  // This is acceptable for our use case; however, this may be unacceptable for\n  // other use cases.\n  //\n  // While Firefox will reject the Promise returned by setRemoteDescription when\n  // called from signalingState \"have-remote-offer\" with an answer, it sill\n  // updates the .remoteDescription property. We workaround this by explicitly\n  // handling this case.\n  FirefoxRTCPeerConnection.prototype.setRemoteDescription = function () {\n    var _this = this;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var _a = __read(args),\n      description = _a[0],\n      rest = _a.slice(1);\n    var promise;\n    if (description && this.signalingState === 'have-remote-offer') {\n      if (description.type === 'answer') {\n        promise = Promise.reject(new Error('Cannot set remote answer in state have-remote-offer'));\n      } else if (description.type === 'offer') {\n        promise = rollback(this, false, function () {\n          return _this._peerConnection.setRemoteDescription(description);\n        });\n      }\n    }\n    if (!promise) {\n      promise = this._peerConnection.setRemoteDescription(description);\n    }\n    promise = promise.then(function () {\n      return saveInitiallyNegotiatedDtlsRole(_this, description, true);\n    });\n    return args.length > 1 ? legacyPromise.apply(void 0, __spreadArray([promise], __read(rest))) : promise;\n  };\n  // NOTE(mroberts): The WebRTC spec specifies that the PeerConnection's internal\n  // isClosed slot should immediately be set to true; however, in Firefox it\n  // occurs in the next tick. We workaround this by tracking isClosed manually.\n  FirefoxRTCPeerConnection.prototype.close = function () {\n    if (this.signalingState !== 'closed') {\n      this._isClosed = true;\n      this._peerConnection.close();\n    }\n  };\n  return FirefoxRTCPeerConnection;\n}(EventTarget);\ndelegateMethods(RTCPeerConnection.prototype, FirefoxRTCPeerConnection.prototype, '_peerConnection');\nfunction rollback(peerConnection, local, onceRolledBack) {\n  var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n  peerConnection._rollingBack = true;\n  return peerConnection._peerConnection[setLocalDescription](new FirefoxRTCSessionDescription({\n    type: 'rollback'\n  })).then(onceRolledBack).then(function (result) {\n    peerConnection._rollingBack = false;\n    return result;\n  }, function (error) {\n    peerConnection._rollingBack = false;\n    throw error;\n  });\n}\n/**\n * Extract the initially negotiated DTLS role out of an RTCSessionDescription's\n * sdp property and save it on the FirefoxRTCPeerConnection if and only if\n *\n *   1. A DTLS role was not already saved on the FirefoxRTCPeerConnection, and\n *   2. The description is an answer.\n *\n * @private\n * @param {FirefoxRTCPeerConnection} peerConnection\n * @param {RTCSessionDescription} description\n * @param {boolean} [remote=false] - if true, save the inverse of the DTLS role,\n *   e.g. \"active\" instead of \"passive\" and vice versa\n * @returns {undefined}\n */\nfunction saveInitiallyNegotiatedDtlsRole(peerConnection, description, remote) {\n  // NOTE(mroberts): JSEP specifies that offers always offer \"actpass\" as the\n  // DTLS role. We need to inspect answers to figure out the negotiated DTLS\n  // role.\n  if (peerConnection._initiallyNegotiatedDtlsRole || description.type === 'offer') {\n    return;\n  }\n  var match = description.sdp.match(/a=setup:([a-z]+)/);\n  if (!match) {\n    return;\n  }\n  var dtlsRole = match[1];\n  peerConnection._initiallyNegotiatedDtlsRole = remote ? {\n    active: 'passive',\n    passive: 'active'\n  }[dtlsRole] : dtlsRole;\n}\n/**\n * Overwrite the DTLS role in the sdp property of an RTCSessionDescription if\n * and only if\n *\n *   1. The description is an answer, and\n *   2. A DTLS role is provided.\n *\n * @private\n * @param {RTCSessionDescription} [description]\n * @param {string} [dtlsRole] - one of \"active\" or \"passive\"\n * @returns {?RTCSessionDescription} description\n */\nfunction overwriteWithInitiallyNegotiatedDtlsRole(description, dtlsRole) {\n  if (description && description.type === 'answer' && dtlsRole) {\n    return new FirefoxRTCSessionDescription({\n      type: description.type,\n      sdp: description.sdp.replace(/a=setup:[a-z]+/g, 'a=setup:' + dtlsRole)\n    });\n  }\n  return description;\n}\nmodule.exports = FirefoxRTCPeerConnection;","map":{"version":3,"names":["EventTarget","require","FirefoxRTCSessionDescription","updateTracksToSSRCs","updateUnifiedPlanTrackIdsToSSRCs","_a","delegateMethods","interceptEvent","legacyPromise","proxyProperties","FirefoxRTCPeerConnection","_super","__extends","configuration","_this","call","peerConnection","RTCPeerConnection","Object","defineProperties","_initiallyNegotiatedDtlsRole","value","writable","_isClosed","_peerConnection","_rollingBack","_tracksToSSRCs","Map","peerIdentity","enumerable","Promise","resolve","idp","name","previousSignalingState","addEventListener","args","_i","arguments","length","signalingState","setTimeout","dispatchEvent","apply","__spreadArray","__read","prototype","defineProperty","get","iceGatheringState","overwriteWithInitiallyNegotiatedDtlsRole","localDescription","createAnswer","promise","then","answer","saveInitiallyNegotiatedDtlsRole","createOffer","arg1","arg2","arg3","options","local","rollback","offer","type","sdp","setLocalDescription","_b","description","rest","slice","reject","Error","setRemoteDescription","close","onceRolledBack","result","error","remote","match","dtlsRole","active","passive","replace","module","exports"],"sources":["/home/denis/RiderProjects/ChatRoulette/WebUI/chat-app/node_modules/twilio-video/lib/webrtc/rtcpeerconnection/firefox.js"],"sourcesContent":["/* globals RTCPeerConnection */\n'use strict';\n\nconst EventTarget = require('../../eventtarget');\nconst FirefoxRTCSessionDescription = require('../rtcsessiondescription/firefox');\nconst { updateUnifiedPlanTrackIdsToSSRCs: updateTracksToSSRCs } = require('../util/sdp');\nconst { delegateMethods, interceptEvent, legacyPromise, proxyProperties } = require('../util');\n\n// NOTE(mroberts): This class wraps Firefox's RTCPeerConnection implementation.\n// It provides some functionality not currently present in Firefox, namely the\n// abilities to\n//\n//   1. Call setLocalDescription and setRemoteDescription with new offers in\n//      signalingStates \"have-local-offer\" and \"have-remote-offer\",\n//      respectively.\n//\n//   2. The ability to call createOffer in signalingState \"have-local-offer\".\n//\n// Both of these are implemented using rollbacks to workaround the following\n// bug:\n//\n//   https://bugzilla.mozilla.org/show_bug.cgi?id=1072388\n//\n// We also provide a workaround for a bug where Firefox may change the\n// previously-negotiated DTLS role in an answer, which breaks Chrome:\n//\n//     https://bugzilla.mozilla.org/show_bug.cgi?id=1240897\n//\nclass FirefoxRTCPeerConnection extends EventTarget {\n  constructor(configuration) {\n    super();\n\n    interceptEvent(this, 'signalingstatechange');\n\n    /* eslint new-cap:0 */\n    const peerConnection = new RTCPeerConnection(configuration);\n\n    Object.defineProperties(this, {\n      _initiallyNegotiatedDtlsRole: {\n        value: null,\n        writable: true\n      },\n      _isClosed: {\n        value: false,\n        writable: true\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _rollingBack: {\n        value: false,\n        writable: true\n      },\n      _tracksToSSRCs: {\n        value: new Map()\n      },\n\n      // NOTE(mmalavalli): Firefox throws a TypeError when the PeerConnection's\n      // prototype's \"peerIdentity\" property is accessed. In order to overcome\n      // this, we ignore this property while delegating methods.\n      // Reference: https://bugzilla.mozilla.org/show_bug.cgi?id=1363815\n      peerIdentity: {\n        enumerable: true,\n        value: Promise.resolve({\n          idp: '',\n          name: ''\n        })\n      }\n    });\n\n    let previousSignalingState;\n\n    peerConnection.addEventListener('signalingstatechange', (...args) => {\n      if (!this._rollingBack && this.signalingState !== previousSignalingState) {\n        previousSignalingState = this.signalingState;\n\n        // NOTE(mmalavalli): In Firefox, 'signalingstatechange' event is\n        // triggered synchronously in the same tick after\n        // RTCPeerConnection#close() is called. So we mimic Chrome's behavior\n        // by triggering 'signalingstatechange' on the next tick.\n        if (this._isClosed) {\n          setTimeout(() => this.dispatchEvent(...args));\n        } else {\n          this.dispatchEvent(...args);\n        }\n      }\n    });\n\n    proxyProperties(RTCPeerConnection.prototype, this, peerConnection);\n  }\n\n  get iceGatheringState() {\n    return this._isClosed ? 'complete' : this._peerConnection.iceGatheringState;\n  }\n\n  get localDescription() {\n    return overwriteWithInitiallyNegotiatedDtlsRole(this._peerConnection.localDescription, this._initiallyNegotiatedDtlsRole);\n  }\n\n  get signalingState() {\n    return this._isClosed ? 'closed' : this._peerConnection.signalingState;\n  }\n\n  createAnswer(...args) {\n    let promise;\n\n    promise = this._peerConnection.createAnswer().then(answer => {\n      saveInitiallyNegotiatedDtlsRole(this, answer);\n      return overwriteWithInitiallyNegotiatedDtlsRole(answer, this._initiallyNegotiatedDtlsRole);\n    });\n\n    return typeof args[0] === 'function'\n      ? legacyPromise(promise, ...args)\n      : promise;\n  }\n\n  // NOTE(mroberts): The WebRTC spec allows you to call createOffer from any\n  // signalingState other than \"closed\"; however, Firefox has not yet implemented\n  // this (https://bugzilla.mozilla.org/show_bug.cgi?id=1072388). We workaround\n  // this by rolling back if we are in state \"have-local-offer\" or\n  // \"have-remote-offer\". This is acceptable for our use case because we will\n  // apply the newly-created offer almost immediately; however, this may be\n  // unacceptable for other use cases.\n  createOffer(...args) {\n    const [arg1, arg2, arg3] = args;\n    const options = arg3 || arg1 || {};\n    let promise;\n\n    if (this.signalingState === 'have-local-offer' ||\n      this.signalingState === 'have-remote-offer') {\n      const local = this.signalingState === 'have-local-offer';\n      promise = rollback(this, local, () => this.createOffer(options));\n    } else {\n      promise = this._peerConnection.createOffer(options);\n    }\n\n    promise = promise.then(offer => {\n      return new FirefoxRTCSessionDescription({\n        type: offer.type,\n        sdp: updateTracksToSSRCs(this._tracksToSSRCs, offer.sdp)\n      });\n    });\n\n    return args.length > 1\n      ? legacyPromise(promise, arg1, arg2)\n      : promise;\n  }\n\n  // NOTE(mroberts): While Firefox will reject the Promise returned by\n  // setLocalDescription when called from signalingState \"have-local-offer\" with\n  // an answer, it still updates the .localDescription property. We workaround\n  // this by explicitly handling this case.\n  setLocalDescription(...args) {\n    const [description, ...rest] = args;\n    let promise;\n\n    if (description && description.type === 'answer' && this.signalingState === 'have-local-offer') {\n      promise = Promise.reject(new Error('Cannot set local answer in state have-local-offer'));\n    }\n\n    if (promise) {\n      return args.length > 1\n        ? legacyPromise(promise, ...rest)\n        : promise;\n    }\n\n    return this._peerConnection.setLocalDescription(...args);\n  }\n\n  // NOTE(mroberts): The WebRTC spec allows you to call setRemoteDescription with\n  // an offer multiple times in signalingState \"have-remote-offer\"; however,\n  // Firefox has not yet implemented this (https://bugzilla.mozilla.org/show_bug.cgi?id=1072388).\n  // We workaround this by rolling back if we are in state \"have-remote-offer\".\n  // This is acceptable for our use case; however, this may be unacceptable for\n  // other use cases.\n  //\n  // While Firefox will reject the Promise returned by setRemoteDescription when\n  // called from signalingState \"have-remote-offer\" with an answer, it sill\n  // updates the .remoteDescription property. We workaround this by explicitly\n  // handling this case.\n  setRemoteDescription(...args) {\n    const [description, ...rest] = args;\n\n    let promise;\n\n    if (description && this.signalingState === 'have-remote-offer') {\n      if (description.type === 'answer') {\n        promise = Promise.reject(new Error('Cannot set remote answer in state have-remote-offer'));\n      } else if (description.type === 'offer') {\n        promise = rollback(this, false, () => this._peerConnection.setRemoteDescription(description));\n      }\n    }\n\n    if (!promise) {\n      promise = this._peerConnection.setRemoteDescription(description);\n    }\n\n    promise = promise.then(() => saveInitiallyNegotiatedDtlsRole(this, description, true));\n\n    return args.length > 1\n      ? legacyPromise(promise, ...rest)\n      : promise;\n  }\n\n  // NOTE(mroberts): The WebRTC spec specifies that the PeerConnection's internal\n  // isClosed slot should immediately be set to true; however, in Firefox it\n  // occurs in the next tick. We workaround this by tracking isClosed manually.\n  close() {\n    if (this.signalingState !== 'closed') {\n      this._isClosed = true;\n      this._peerConnection.close();\n    }\n  }\n}\n\ndelegateMethods(\n  RTCPeerConnection.prototype,\n  FirefoxRTCPeerConnection.prototype,\n  '_peerConnection');\n\nfunction rollback(peerConnection, local, onceRolledBack) {\n  const setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n  peerConnection._rollingBack = true;\n  return peerConnection._peerConnection[setLocalDescription](new FirefoxRTCSessionDescription({\n    type: 'rollback'\n  })).then(onceRolledBack).then(result => {\n    peerConnection._rollingBack = false;\n    return result;\n  }, error => {\n    peerConnection._rollingBack = false;\n    throw error;\n  });\n}\n\n/**\n * Extract the initially negotiated DTLS role out of an RTCSessionDescription's\n * sdp property and save it on the FirefoxRTCPeerConnection if and only if\n *\n *   1. A DTLS role was not already saved on the FirefoxRTCPeerConnection, and\n *   2. The description is an answer.\n *\n * @private\n * @param {FirefoxRTCPeerConnection} peerConnection\n * @param {RTCSessionDescription} description\n * @param {boolean} [remote=false] - if true, save the inverse of the DTLS role,\n *   e.g. \"active\" instead of \"passive\" and vice versa\n * @returns {undefined}\n */\nfunction saveInitiallyNegotiatedDtlsRole(peerConnection, description, remote) {\n  // NOTE(mroberts): JSEP specifies that offers always offer \"actpass\" as the\n  // DTLS role. We need to inspect answers to figure out the negotiated DTLS\n  // role.\n  if (peerConnection._initiallyNegotiatedDtlsRole || description.type === 'offer') {\n    return;\n  }\n\n  const match = description.sdp.match(/a=setup:([a-z]+)/);\n  if (!match) {\n    return;\n  }\n\n  const dtlsRole = match[1];\n  peerConnection._initiallyNegotiatedDtlsRole = remote ? {\n    active: 'passive',\n    passive: 'active'\n  }[dtlsRole] : dtlsRole;\n}\n\n/**\n * Overwrite the DTLS role in the sdp property of an RTCSessionDescription if\n * and only if\n *\n *   1. The description is an answer, and\n *   2. A DTLS role is provided.\n *\n * @private\n * @param {RTCSessionDescription} [description]\n * @param {string} [dtlsRole] - one of \"active\" or \"passive\"\n * @returns {?RTCSessionDescription} description\n */\nfunction overwriteWithInitiallyNegotiatedDtlsRole(description, dtlsRole) {\n  if (description && description.type === 'answer' && dtlsRole) {\n    return new FirefoxRTCSessionDescription({\n      type: description.type,\n      sdp: description.sdp.replace(/a=setup:[a-z]+/g, 'a=setup:' + dtlsRole)\n    });\n  }\n  return description;\n}\n\nmodule.exports = FirefoxRTCPeerConnection;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}