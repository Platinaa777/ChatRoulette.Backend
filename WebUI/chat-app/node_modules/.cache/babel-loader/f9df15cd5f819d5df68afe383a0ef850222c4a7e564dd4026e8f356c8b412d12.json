{"ast":null,"code":"'use strict';\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyNoiseCancellation = exports.NoiseCancellationImpl = void 0;\nvar noisecancellationadapter_1 = require(\"../../noisecancellationadapter\");\nvar Log = require('../../util/log');\n/**\n * {@link NoiseCancellation} interface provides methods to control noise cancellation at runtime. This interface is exposed\n * on {@link LocalAudioTrack} property `noiseCancellation`. It is available only when {@link NoiseCancellationOptions} are\n * specified when creating a {@link LocalAudioTrack}, and the plugin is successfully loaded.\n * @alias NoiseCancellation\n * @interface\n *\n * @example\n * const { connect, createLocalAudioTrack } = require('twilio-video');\n *\n * // Create a LocalAudioTrack with Krisp noise cancellation enabled.\n * const localAudioTrack = await createLocalAudioTrack({\n *   noiseCancellationOptions: {\n *     sdkAssetsPath: 'path/to/hosted/twilio/krisp/audio/plugin/1.0.0/dist',\n *     vendor: 'krisp'\n *   }\n * });\n *\n * if (!localAudioTrack.noiseCancellation) {\n *   // If the Krisp audio plugin fails to load, then a warning message will be logged\n *   // in the browser console, and the \"noiseCancellation\" property will be set to null.\n *   // You can still use the LocalAudioTrack to join a Room. However, it will use the\n *   // browser's noise suppression instead of the Krisp noise cancellation. Make sure\n *   // the \"sdkAssetsPath\" provided in \"noiseCancellationOptions\" points to the correct\n *   // hosted path of the plugin assets.\n * } else {\n *   // Join a Room with the LocalAudioTrack.\n *   const room = await connect('token', {\n *     name: 'my-cool-room',\n *     tracks: [localAudioTrack]\n *   });\n *\n *   if (!localAudioTrack.noiseCancellation.isEnabled) {\n *     // Krisp noise cancellation is permanently disabled in Peer-to-Peer and Go Rooms.\n *   }\n * }\n *\n * //\n * // Enable/disable noise cancellation.\n * // @param {boolean} enable - whether noise cancellation should be enabled\n * //\n * function setNoiseCancellation(enable) {\n *   const { noiseCancellation } = localAudioTrack;\n *   if (noiseCancellation) {\n *     if (enable) {\n *       // If enabled, then the LocalAudioTrack will use the Krisp noise\n *       // cancellation instead of the browser's noise suppression.\n *       noiseCancellation.enable();\n *     } else {\n *       // If disabled, then the LocalAudioTrack will use the browser's\n *       // noise suppression instead of the Krisp noise cancellation.\n *       noiseCancellation.disable();\n *     }\n *   }\n * }\n */\nvar NoiseCancellationImpl = /** @class */function () {\n  function NoiseCancellationImpl(processor, originalTrack) {\n    this._processor = processor;\n    this._sourceTrack = originalTrack;\n    this._disabledPermanent = false;\n  }\n  Object.defineProperty(NoiseCancellationImpl.prototype, \"vendor\", {\n    /**\n     * Name of the noise cancellation vendor.\n     * @type {NoiseCancellationVendor}\n     */\n    get: function () {\n      return this._processor.vendor;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NoiseCancellationImpl.prototype, \"sourceTrack\", {\n    /**\n     * The underlying MediaStreamTrack of the {@link LocalAudioTrack}.\n     * @type {MediaStreamTrack}\n     */\n    get: function () {\n      return this._sourceTrack;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NoiseCancellationImpl.prototype, \"isEnabled\", {\n    /**\n     * Whether noise cancellation is enabled.\n     * @type {boolean}\n     */\n    get: function () {\n      return this._processor.isEnabled();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Enable noise cancellation.\n   * @returns {Promise<void>} Promise that resolves when the operation is complete\n   * @throws {Error} Throws an error if noise cancellation is disabled permanently\n   *   for the {@link LocalAudioTrack}\n   */\n  NoiseCancellationImpl.prototype.enable = function () {\n    if (this._disabledPermanent) {\n      throw new Error(this.vendor + \" noise cancellation is disabled permanently for this track\");\n    }\n    this._processor.enable();\n    return Promise.resolve();\n  };\n  /**\n   * Disable noise cancellation.\n   * @returns {Promise<void>} Promise that resolves when the operation is complete\n   */\n  NoiseCancellationImpl.prototype.disable = function () {\n    this._processor.disable();\n    return Promise.resolve();\n  };\n  /**\n   * @private\n   */\n  NoiseCancellationImpl.prototype.reacquireTrack = function (reacquire) {\n    return __awaiter(this, void 0, void 0, function () {\n      var processorWasEnabled, track, processedTrack;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            processorWasEnabled = this._processor.isEnabled();\n            this._processor.disconnect();\n            return [4 /*yield*/, reacquire()];\n          case 1:\n            track = _a.sent();\n            this._sourceTrack = track;\n            return [4 /*yield*/, this._processor.connect(track)];\n          case 2:\n            processedTrack = _a.sent();\n            if (processorWasEnabled) {\n              this._processor.enable();\n            } else {\n              this._processor.disable();\n            }\n            return [2 /*return*/, processedTrack];\n        }\n      });\n    });\n  };\n  /**\n   * @private\n   */\n  NoiseCancellationImpl.prototype.disablePermanently = function () {\n    this._disabledPermanent = true;\n    return this.disable();\n  };\n  /**\n   * @private\n   */\n  NoiseCancellationImpl.prototype.stop = function () {\n    this._processor.disconnect();\n    this._sourceTrack.stop();\n  };\n  return NoiseCancellationImpl;\n}();\nexports.NoiseCancellationImpl = NoiseCancellationImpl;\nfunction applyNoiseCancellation(mediaStreamTrack, noiseCancellationOptions, log) {\n  return __awaiter(this, void 0, void 0, function () {\n    var processor, cleanTrack, noiseCancellation, ex_1;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          _a.trys.push([0, 2,, 3]);\n          return [4 /*yield*/, noisecancellationadapter_1.createNoiseCancellationAudioProcessor(noiseCancellationOptions, log)];\n        case 1:\n          processor = _a.sent();\n          cleanTrack = processor.connect(mediaStreamTrack);\n          noiseCancellation = new NoiseCancellationImpl(processor, mediaStreamTrack);\n          return [2 /*return*/, {\n            cleanTrack: cleanTrack,\n            noiseCancellation: noiseCancellation\n          }];\n        case 2:\n          ex_1 = _a.sent();\n          // in case of failures to load noise cancellation library just return original media stream.\n          log.warn(\"Failed to create noise cancellation. Returning normal audio track: \" + ex_1);\n          return [2 /*return*/, {\n            cleanTrack: mediaStreamTrack\n          }];\n        case 3:\n          return [2 /*return*/];\n      }\n    });\n  });\n}\n\nexports.applyNoiseCancellation = applyNoiseCancellation;","map":{"version":3,"names":["noisecancellationadapter_1","require","Log","NoiseCancellationImpl","processor","originalTrack","_processor","_sourceTrack","_disabledPermanent","Object","defineProperty","prototype","get","vendor","isEnabled","enable","Error","Promise","resolve","disable","reacquireTrack","reacquire","processorWasEnabled","disconnect","track","_a","sent","connect","processedTrack","disablePermanently","stop","exports","applyNoiseCancellation","mediaStreamTrack","noiseCancellationOptions","log","createNoiseCancellationAudioProcessor","cleanTrack","noiseCancellation","warn","ex_1"],"sources":["/home/denis/RiderProjects/ChatRoulette/WebUI/chat-app/node_modules/twilio-video/lib/media/track/noisecancellationimpl.ts"],"sourcesContent":["'use strict';\n\nimport { NoiseCancellation, NoiseCancellationOptions, NoiseCancellationVendor } from '../../../tsdef/types';\nimport { AudioProcessor } from '../../../tsdef/AudioProcessor';\nimport { createNoiseCancellationAudioProcessor } from '../../noisecancellationadapter';\nconst Log = require('../../util/log');\n\n/**\n * {@link NoiseCancellation} interface provides methods to control noise cancellation at runtime. This interface is exposed\n * on {@link LocalAudioTrack} property `noiseCancellation`. It is available only when {@link NoiseCancellationOptions} are\n * specified when creating a {@link LocalAudioTrack}, and the plugin is successfully loaded.\n * @alias NoiseCancellation\n * @interface\n *\n * @example\n * const { connect, createLocalAudioTrack } = require('twilio-video');\n *\n * // Create a LocalAudioTrack with Krisp noise cancellation enabled.\n * const localAudioTrack = await createLocalAudioTrack({\n *   noiseCancellationOptions: {\n *     sdkAssetsPath: 'path/to/hosted/twilio/krisp/audio/plugin/1.0.0/dist',\n *     vendor: 'krisp'\n *   }\n * });\n *\n * if (!localAudioTrack.noiseCancellation) {\n *   // If the Krisp audio plugin fails to load, then a warning message will be logged\n *   // in the browser console, and the \"noiseCancellation\" property will be set to null.\n *   // You can still use the LocalAudioTrack to join a Room. However, it will use the\n *   // browser's noise suppression instead of the Krisp noise cancellation. Make sure\n *   // the \"sdkAssetsPath\" provided in \"noiseCancellationOptions\" points to the correct\n *   // hosted path of the plugin assets.\n * } else {\n *   // Join a Room with the LocalAudioTrack.\n *   const room = await connect('token', {\n *     name: 'my-cool-room',\n *     tracks: [localAudioTrack]\n *   });\n *\n *   if (!localAudioTrack.noiseCancellation.isEnabled) {\n *     // Krisp noise cancellation is permanently disabled in Peer-to-Peer and Go Rooms.\n *   }\n * }\n *\n * //\n * // Enable/disable noise cancellation.\n * // @param {boolean} enable - whether noise cancellation should be enabled\n * //\n * function setNoiseCancellation(enable) {\n *   const { noiseCancellation } = localAudioTrack;\n *   if (noiseCancellation) {\n *     if (enable) {\n *       // If enabled, then the LocalAudioTrack will use the Krisp noise\n *       // cancellation instead of the browser's noise suppression.\n *       noiseCancellation.enable();\n *     } else {\n *       // If disabled, then the LocalAudioTrack will use the browser's\n *       // noise suppression instead of the Krisp noise cancellation.\n *       noiseCancellation.disable();\n *     }\n *   }\n * }\n */\nexport class NoiseCancellationImpl implements NoiseCancellation {\n  private _processor: AudioProcessor;\n  private _sourceTrack: MediaStreamTrack;\n  private _disabledPermanent: boolean;\n\n  constructor(processor: AudioProcessor, originalTrack: MediaStreamTrack) {\n    this._processor = processor;\n    this._sourceTrack = originalTrack;\n    this._disabledPermanent = false;\n  }\n\n  /**\n   * Name of the noise cancellation vendor.\n   * @type {NoiseCancellationVendor}\n   */\n  get vendor(): NoiseCancellationVendor {\n    return this._processor.vendor;\n  }\n\n  /**\n   * The underlying MediaStreamTrack of the {@link LocalAudioTrack}.\n   * @type {MediaStreamTrack}\n   */\n  get sourceTrack(): MediaStreamTrack {\n    return this._sourceTrack;\n  }\n\n  /**\n   * Whether noise cancellation is enabled.\n   * @type {boolean}\n   */\n  get isEnabled(): boolean {\n    return this._processor.isEnabled();\n  }\n\n  /**\n   * Enable noise cancellation.\n   * @returns {Promise<void>} Promise that resolves when the operation is complete\n   * @throws {Error} Throws an error if noise cancellation is disabled permanently\n   *   for the {@link LocalAudioTrack}\n   */\n  enable() : Promise<void> {\n    if (this._disabledPermanent) {\n      throw new Error(`${this.vendor} noise cancellation is disabled permanently for this track`);\n    }\n\n    this._processor.enable();\n    return Promise.resolve();\n  }\n\n  /**\n   * Disable noise cancellation.\n   * @returns {Promise<void>} Promise that resolves when the operation is complete\n   */\n  disable() : Promise<void> {\n    this._processor.disable();\n    return Promise.resolve();\n  }\n\n  /**\n   * @private\n   */\n  async reacquireTrack(reacquire: () => Promise<MediaStreamTrack>) : Promise<MediaStreamTrack>  {\n    const processorWasEnabled = this._processor.isEnabled();\n    this._processor.disconnect();\n\n    const track = await reacquire();\n    this._sourceTrack = track;\n\n    const processedTrack = await this._processor.connect(track);\n    if (processorWasEnabled) {\n      this._processor.enable();\n    } else {\n      this._processor.disable();\n    }\n    return processedTrack;\n  }\n\n  /**\n   * @private\n   */\n  disablePermanently(): Promise<void> {\n    this._disabledPermanent = true;\n    return this.disable();\n  }\n\n\n  /**\n   * @private\n   */\n  stop(): void {\n    this._processor.disconnect();\n    this._sourceTrack.stop();\n  }\n}\n\n\nexport async function applyNoiseCancellation(\n  mediaStreamTrack: MediaStreamTrack,\n  noiseCancellationOptions: NoiseCancellationOptions,\n  log: typeof Log\n) : Promise<{ cleanTrack: MediaStreamTrack, noiseCancellation?: NoiseCancellation }> {\n  try {\n    const processor = await createNoiseCancellationAudioProcessor(noiseCancellationOptions, log);\n    const cleanTrack = processor.connect(mediaStreamTrack);\n    const noiseCancellation = new NoiseCancellationImpl(processor, mediaStreamTrack);\n    return { cleanTrack, noiseCancellation };\n  } catch (ex) {\n    // in case of failures to load noise cancellation library just return original media stream.\n    log.warn(`Failed to create noise cancellation. Returning normal audio track: ${ex}`);\n    return { cleanTrack: mediaStreamTrack };\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}