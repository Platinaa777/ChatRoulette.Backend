{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar isIOS = require('../../util/browserdetection').isIOS;\nvar detectSilentVideo = require('../../util/detectsilentvideo');\nvar mixinLocalMediaTrack = require('./localmediatrack');\nvar VideoTrack = require('./videotrack');\nvar LocalMediaVideoTrack = mixinLocalMediaTrack(VideoTrack);\n/**\n * A {@link LocalVideoTrack} is a {@link VideoTrack} representing video that\n * your {@link LocalParticipant} can publish to a {@link Room}. It can be\n * enabled and disabled with {@link LocalVideoTrack#enable} and\n * {@link LocalVideoTrack#disable} or stopped completely with\n * {@link LocalVideoTrack#stop}.\n * @extends VideoTrack\n * @property {Track.ID} id - The {@link LocalVideoTrack}'s ID\n * @property {boolean} isMuted - Whether or not the video source has stopped sending frames to the\n *   {@link LocalVideoTrack}; This can happen when the camera is taken over by another application,\n *   mainly on mobile devices; When this property toggles, then <code>muted</code> and <code>unmuted</code>\n *   events are fired appropriately\n * @property {boolean} isStopped - Whether or not the {@link LocalVideoTrack} is\n *   stopped\n * @emits LocalVideoTrack#disabled\n * @emits LocalVideoTrack#enabled\n * @emits LocalVideoTrack#muted\n * @emits LocalVideoTrack#started\n * @emits LocalVideoTrack#stopped\n * @emits LocalVideoTrack#unmuted\n */\nvar LocalVideoTrack = /** @class */function (_super) {\n  __extends(LocalVideoTrack, _super);\n  /**\n   * Construct a {@link LocalVideoTrack} from a MediaStreamTrack.\n   * @param {MediaStreamTrack} mediaStreamTrack - The underlying MediaStreamTrack\n   * @param {LocalTrackOptions} [options] - {@link LocalTrack} options\n   */\n  function LocalVideoTrack(mediaStreamTrack, options) {\n    var _this = this;\n    options = Object.assign({\n      workaroundSilentLocalVideo: isIOS() && typeof document !== 'undefined' && typeof document.createElement === 'function'\n    }, options);\n    _this = _super.call(this, mediaStreamTrack, options) || this;\n    Object.defineProperties(_this, {\n      _workaroundSilentLocalVideo: {\n        value: options.workaroundSilentLocalVideo ? workaroundSilentLocalVideo : null\n      },\n      _workaroundSilentLocalVideoCleanup: {\n        value: null,\n        writable: true\n      }\n    });\n    // NOTE(mmalavalli): In iOS Safari, we work around a bug where local video\n    // MediaStreamTracks are silent (even though they are enabled, live and unmuted)\n    // after accepting/rejecting a phone call.\n    if (_this._workaroundSilentLocalVideo) {\n      _this._workaroundSilentLocalVideoCleanup = _this._workaroundSilentLocalVideo(_this, document);\n    }\n    return _this;\n  }\n  LocalVideoTrack.prototype.toString = function () {\n    return \"[LocalVideoTrack #\" + this._instanceId + \": \" + this.id + \"]\";\n  };\n  /**\n   * @private\n   */\n  LocalVideoTrack.prototype._checkIfCanCaptureFrames = function () {\n    return _super.prototype._checkIfCanCaptureFrames.call(this, this._trackSender.isPublishing);\n  };\n  /**\n   * @private\n   */\n  LocalVideoTrack.prototype._end = function () {\n    return _super.prototype._end.apply(this, arguments);\n  };\n  /**\n   * @private\n   */\n  LocalVideoTrack.prototype._setSenderMediaStreamTrack = function (useProcessed) {\n    var _this = this;\n    var unprocessedTrack = this.mediaStreamTrack;\n    var mediaStreamTrack = useProcessed ? this.processedTrack : unprocessedTrack;\n    return this._trackSender.setMediaStreamTrack(mediaStreamTrack).catch(function (error) {\n      return _this._log.warn('setMediaStreamTrack failed on LocalVideoTrack RTCRtpSender', {\n        error: error,\n        mediaStreamTrack: mediaStreamTrack\n      });\n    }).then(function () {\n      _this._unprocessedTrack = useProcessed ? unprocessedTrack : null;\n    });\n  };\n  /**\n   * Add a {@link VideoProcessor} to allow for custom processing of video frames belonging to a VideoTrack.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to use.\n   * @param {AddProcessorOptions} [options] - {@link AddProcessorOptions} to provide.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * const localVideoTrack = Array.from(room.localParticipant.videoTracks.values())[0].track;\n   * localVideoTrack.addProcessor(new GrayScaleProcessor(100));\n   */\n  LocalVideoTrack.prototype.addProcessor = function () {\n    this._log.debug('Adding VideoProcessor to the LocalVideoTrack');\n    var result = _super.prototype.addProcessor.apply(this, arguments);\n    if (!this.processedTrack) {\n      return this._log.warn('Unable to add a VideoProcessor to the LocalVideoTrack');\n    }\n    this._log.debug('Updating LocalVideoTrack\\'s MediaStreamTrack with the processed MediaStreamTrack', this.processedTrack);\n    this._setSenderMediaStreamTrack(true);\n    return result;\n  };\n  /**\n   * Remove the previously added {@link VideoProcessor} using `addProcessor` API.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to remove.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * const localVideoTrack = Array.from(room.localParticipant.videoTracks.values())[0].track;\n   * const grayScaleProcessor = new GrayScaleProcessor(100);\n   * localVideoTrack.addProcessor(grayScaleProcessor);\n   *\n   * document.getElementById('remove-button').onclick = () => localVideoTrack.removeProcessor(grayScaleProcessor);\n   */\n  LocalVideoTrack.prototype.removeProcessor = function () {\n    var _this = this;\n    this._log.debug('Removing VideoProcessor from the LocalVideoTrack');\n    var result = _super.prototype.removeProcessor.apply(this, arguments);\n    this._log.debug('Updating LocalVideoTrack\\'s MediaStreamTrack with the original MediaStreamTrack');\n    this._setSenderMediaStreamTrack().then(function () {\n      return _this._updateElementsMediaStreamTrack();\n    });\n    return result;\n  };\n  /**\n   * Disable the {@link LocalVideoTrack}. This is equivalent to pausing a video source.\n   * If a {@link VideoProcessor} is added, then <code>processedTrack</code> is also disabled.\n   * @returns {this}\n   * @fires VideoTrack#disabled\n   */\n  LocalVideoTrack.prototype.disable = function () {\n    var result = _super.prototype.disable.apply(this, arguments);\n    if (this.processedTrack) {\n      this.processedTrack.enabled = false;\n    }\n    return result;\n  };\n  /**\n   * Enable the {@link LocalVideoTrack}. This is equivalent to unpausing the video source.\n   * If a {@link VideoProcessor} is added, then <code>processedTrack</code> is also enabled.\n   * @returns {this}\n   * @fires VideoTrack#enabled\n  */ /**\n     * Enable or disable the {@link LocalVideoTrack}. This is equivalent to unpausing or pausing\n     * the video source respectively. If a {@link VideoProcessor} is added, then <code>processedTrack</code>\n     * is also enabled or disabled.\n     * @param {boolean} [enabled] - Specify false to disable the\n     *   {@link LocalVideoTrack}\n     * @returns {this}\n     * @fires VideoTrack#disabled\n     * @fires VideoTrack#enabled\n     */\n  LocalVideoTrack.prototype.enable = function (enabled) {\n    if (enabled === void 0) {\n      enabled = true;\n    }\n    var result = _super.prototype.enable.apply(this, arguments);\n    if (this.processedTrack) {\n      this.processedTrack.enabled = enabled;\n      if (enabled) {\n        this._captureFrames();\n        this._log.debug('Updating LocalVideoTrack\\'s MediaStreamTrack with the processed MediaStreamTrack', this.processedTrack);\n        this._setSenderMediaStreamTrack(true);\n      }\n    }\n    return result;\n  };\n  /**\n   * Restart the {@link LocalVideoTrack}. This stops the existing MediaStreamTrack\n   * and creates a new MediaStreamTrack. If the {@link LocalVideoTrack} is being published\n   * to a {@link Room}, then all the {@link RemoteParticipant}s will start receiving media\n   * from the newly created MediaStreamTrack. You can access the new MediaStreamTrack via\n   * the <code>mediaStreamTrack</code> property. If you want to listen to events on\n   * the MediaStreamTrack directly, please do so in the \"started\" event handler. Also,\n   * the {@link LocalVideoTrack}'s ID is no longer guaranteed to be the same as the\n   * underlying MediaStreamTrack's ID.\n   * @param {MediaTrackConstraints} [constraints] - The optional <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints\" target=\"_blank\">MediaTrackConstraints</a>\n   *   for restarting the {@link LocalVideoTrack}; If not specified, then the current MediaTrackConstraints\n   *   will be used; If <code>{}</code> (empty object) is specified, then the default MediaTrackConstraints\n   *   will be used\n   * @returns {Promise<void>} Rejects with a TypeError if the {@link LocalVideoTrack} was not created\n   *   using an one of <code>createLocalVideoTrack</code>, <code>createLocalTracks</code> or <code>connect</code>;\n   *   Also rejects with the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#Exceptions\" target=\"_blank\">DOMException</a>\n   *   raised by <code>getUserMedia</code> when it fails\n   * @fires LocalVideoTrack#stopped\n   * @fires LocalVideoTrack#started\n   * @example\n   * const { connect, createLocalVideoTrack } = require('twilio-video');\n   *\n   * // Create a LocalVideoTrack that captures video from the front-facing camera.\n   * createLocalVideoTrack({ facingMode: 'user' }).then(function(localVideoTrack) {\n   *   return connect('token', {\n   *     name: 'my-cool-room',\n   *     tracks: [localVideoTrack]\n   *   });\n   * }).then(function(room) {\n   *   // Restart the LocalVideoTrack to capture video from the back-facing camera.\n   *   const localVideoTrack = Array.from(room.localParticipant.videoTracks.values())[0].track;\n   *   return localVideoTrack.restart({ facingMode: 'environment' });\n   * });\n   */\n  LocalVideoTrack.prototype.restart = function () {\n    var _this = this;\n    if (this._workaroundSilentLocalVideoCleanup) {\n      this._workaroundSilentLocalVideoCleanup();\n      this._workaroundSilentLocalVideoCleanup = null;\n    }\n    var promise = _super.prototype.restart.apply(this, arguments);\n    if (this.processor) {\n      promise.then(function () {\n        _this._restartProcessor();\n      });\n    }\n    if (this._workaroundSilentLocalVideo) {\n      promise.finally(function () {\n        _this._workaroundSilentLocalVideoCleanup = _this._workaroundSilentLocalVideo(_this, document);\n      });\n    }\n    return promise;\n  };\n  /**\n   * Calls stop on the underlying MediaStreamTrack. If you choose to stop a\n   * {@link LocalVideoTrack}, you should unpublish it after stopping.\n   * @returns {this}\n   * @fires LocalVideoTrack#stopped\n   */\n  LocalVideoTrack.prototype.stop = function () {\n    if (this._workaroundSilentLocalVideoCleanup) {\n      this._workaroundSilentLocalVideoCleanup();\n      this._workaroundSilentLocalVideoCleanup = null;\n    }\n    return _super.prototype.stop.apply(this, arguments);\n  };\n  return LocalVideoTrack;\n}(LocalMediaVideoTrack);\n/**\n * Work around a bug where local video MediaStreamTracks are silent (even though\n * they are enabled, live and unmuted) after accepting/rejecting a phone call.\n * @private\n * @param {LocalVideoTrack} localVideoTrack\n * @param {HTMLDocument} doc\n * @returns {function} Cleans up listeners attached by the workaround\n */\nfunction workaroundSilentLocalVideo(localVideoTrack, doc) {\n  var log = localVideoTrack._log;\n  var el = localVideoTrack._dummyEl,\n    mediaStreamTrack = localVideoTrack.mediaStreamTrack;\n  function onUnmute() {\n    if (!localVideoTrack.isEnabled) {\n      return;\n    }\n    log.info('Unmuted, checking silence');\n    // The dummy element is paused, so play it and then detect silence.\n    el.play().then(function () {\n      return detectSilentVideo(el, doc);\n    }).then(function (isSilent) {\n      if (!isSilent) {\n        log.info('Non-silent frames detected, so no need to restart');\n        return;\n      }\n      log.warn('Silence detected, restarting');\n      // NOTE(mmalavalli): If we try and restart a silent MediaStreamTrack\n      // without stopping it first, then a NotReadableError is raised. Hence,\n      // we stop the MediaStreamTrack here.\n      localVideoTrack._stop();\n      // Restart the LocalVideoTrack.\n      // eslint-disable-next-line consistent-return\n      return localVideoTrack._restart();\n    }).catch(function (error) {\n      log.warn('Failed to detect silence and restart:', error);\n    }).finally(function () {\n      // If silent frames were not detected, then pause the dummy element again,\n      // if there is no processed track.\n      el = localVideoTrack._dummyEl;\n      if (el && !el.paused && !localVideoTrack.processedTrack) {\n        el.pause();\n      }\n      // Reset the unmute handler.\n      mediaStreamTrack.removeEventListener('unmute', onUnmute);\n      mediaStreamTrack = localVideoTrack.mediaStreamTrack;\n      mediaStreamTrack.addEventListener('unmute', onUnmute);\n    });\n  }\n  // Set the unmute handler.\n  mediaStreamTrack.addEventListener('unmute', onUnmute);\n  return function () {\n    mediaStreamTrack.removeEventListener('unmute', onUnmute);\n  };\n}\n/**\n * The {@link LocalVideoTrack} was disabled, i.e. the video source was paused by the user.\n * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that was\n *   disabled\n * @event LocalVideoTrack#disabled\n */\n/**\n * The {@link LocalVideoTrack} was enabled, i.e. the video source was unpaused by the user.\n * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that was enabled\n * @event LocalVideoTrack#enabled\n */\n/**\n * The {@link LocalVideoTrack} was muted because the video source stopped sending frames, most\n * likely due to another application taking said video source, especially on mobile devices.\n * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that was muted\n * @event LocalVideoTrack#muted\n */\n/**\n * The {@link LocalVideoTrack} started. This means there is enough video data\n * to begin playback.\n * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that started\n * @event LocalVideoTrack#started\n */\n/**\n * The {@link LocalVideoTrack} stopped, either because {@link LocalVideoTrack#stop}\n * or {@link LocalVideoTrack#restart} was called or because the underlying\n * MediaStreamTrack ended.\n * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that stopped\n * @event LocalVideoTrack#stopped\n */\n/**\n * The {@link LocalVideoTrack} was unmuted because the video source resumed sending frames,\n * most likely due to the application that took over the said video source has released it\n * back to the application, especially on mobile devices. This event is also fired when\n * {@link LocalVideoTrack#restart} is called on a muted {@link LocalVideoTrack} with a\n * new video source.\n * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that was unmuted\n * @event LocalVideoTrack#unmuted\n */\nmodule.exports = LocalVideoTrack;","map":{"version":3,"names":["isIOS","require","detectSilentVideo","mixinLocalMediaTrack","VideoTrack","LocalMediaVideoTrack","LocalVideoTrack","_super","__extends","mediaStreamTrack","options","_this","Object","assign","workaroundSilentLocalVideo","document","createElement","call","defineProperties","_workaroundSilentLocalVideo","value","_workaroundSilentLocalVideoCleanup","writable","prototype","toString","_instanceId","id","_checkIfCanCaptureFrames","_trackSender","isPublishing","_end","apply","arguments","_setSenderMediaStreamTrack","useProcessed","unprocessedTrack","processedTrack","setMediaStreamTrack","catch","error","_log","warn","then","_unprocessedTrack","addProcessor","debug","result","removeProcessor","_updateElementsMediaStreamTrack","disable","enabled","enable","_captureFrames","restart","promise","processor","_restartProcessor","finally","stop","localVideoTrack","doc","log","el","_dummyEl","onUnmute","isEnabled","info","play","isSilent","_stop","_restart","paused","pause","removeEventListener","addEventListener","module","exports"],"sources":["/home/denis/RiderProjects/ChatRoulette/WebUI/chat-app/node_modules/twilio-video/lib/media/track/localvideotrack.js"],"sourcesContent":["'use strict';\n\nconst { isIOS } = require('../../util/browserdetection');\nconst detectSilentVideo = require('../../util/detectsilentvideo');\nconst mixinLocalMediaTrack = require('./localmediatrack');\nconst VideoTrack = require('./videotrack');\n\nconst LocalMediaVideoTrack = mixinLocalMediaTrack(VideoTrack);\n\n/**\n * A {@link LocalVideoTrack} is a {@link VideoTrack} representing video that\n * your {@link LocalParticipant} can publish to a {@link Room}. It can be\n * enabled and disabled with {@link LocalVideoTrack#enable} and\n * {@link LocalVideoTrack#disable} or stopped completely with\n * {@link LocalVideoTrack#stop}.\n * @extends VideoTrack\n * @property {Track.ID} id - The {@link LocalVideoTrack}'s ID\n * @property {boolean} isMuted - Whether or not the video source has stopped sending frames to the\n *   {@link LocalVideoTrack}; This can happen when the camera is taken over by another application,\n *   mainly on mobile devices; When this property toggles, then <code>muted</code> and <code>unmuted</code>\n *   events are fired appropriately\n * @property {boolean} isStopped - Whether or not the {@link LocalVideoTrack} is\n *   stopped\n * @emits LocalVideoTrack#disabled\n * @emits LocalVideoTrack#enabled\n * @emits LocalVideoTrack#muted\n * @emits LocalVideoTrack#started\n * @emits LocalVideoTrack#stopped\n * @emits LocalVideoTrack#unmuted\n */\nclass LocalVideoTrack extends LocalMediaVideoTrack {\n  /**\n   * Construct a {@link LocalVideoTrack} from a MediaStreamTrack.\n   * @param {MediaStreamTrack} mediaStreamTrack - The underlying MediaStreamTrack\n   * @param {LocalTrackOptions} [options] - {@link LocalTrack} options\n   */\n  constructor(mediaStreamTrack, options) {\n    options = Object.assign({\n      workaroundSilentLocalVideo: isIOS()\n        && typeof document !== 'undefined'\n        && typeof document.createElement === 'function'\n    }, options);\n\n    super(mediaStreamTrack, options);\n\n    Object.defineProperties(this, {\n      _workaroundSilentLocalVideo: {\n        value: options.workaroundSilentLocalVideo\n          ? workaroundSilentLocalVideo\n          : null\n      },\n      _workaroundSilentLocalVideoCleanup: {\n        value: null,\n        writable: true\n      }\n    });\n\n    // NOTE(mmalavalli): In iOS Safari, we work around a bug where local video\n    // MediaStreamTracks are silent (even though they are enabled, live and unmuted)\n    // after accepting/rejecting a phone call.\n    if (this._workaroundSilentLocalVideo) {\n      this._workaroundSilentLocalVideoCleanup = this._workaroundSilentLocalVideo(this, document);\n    }\n  }\n\n  toString() {\n    return `[LocalVideoTrack #${this._instanceId}: ${this.id}]`;\n  }\n\n  /**\n   * @private\n   */\n  _checkIfCanCaptureFrames() {\n    return super._checkIfCanCaptureFrames.call(this, this._trackSender.isPublishing);\n  }\n\n  /**\n   * @private\n   */\n  _end() {\n    return super._end.apply(this, arguments);\n  }\n\n  /**\n   * @private\n   */\n  _setSenderMediaStreamTrack(useProcessed) {\n    const unprocessedTrack = this.mediaStreamTrack;\n    const mediaStreamTrack = useProcessed ? this.processedTrack : unprocessedTrack;\n\n    return this._trackSender.setMediaStreamTrack(mediaStreamTrack)\n      .catch(error => this._log.warn(\n        'setMediaStreamTrack failed on LocalVideoTrack RTCRtpSender', { error, mediaStreamTrack }))\n      .then(() => {\n        this._unprocessedTrack = useProcessed ? unprocessedTrack : null;\n      });\n  }\n\n  /**\n   * Add a {@link VideoProcessor} to allow for custom processing of video frames belonging to a VideoTrack.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to use.\n   * @param {AddProcessorOptions} [options] - {@link AddProcessorOptions} to provide.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * const localVideoTrack = Array.from(room.localParticipant.videoTracks.values())[0].track;\n   * localVideoTrack.addProcessor(new GrayScaleProcessor(100));\n   */\n  addProcessor() {\n    this._log.debug('Adding VideoProcessor to the LocalVideoTrack');\n    const result = super.addProcessor.apply(this, arguments);\n\n    if (!this.processedTrack) {\n      return this._log.warn('Unable to add a VideoProcessor to the LocalVideoTrack');\n    }\n\n    this._log.debug('Updating LocalVideoTrack\\'s MediaStreamTrack with the processed MediaStreamTrack', this.processedTrack);\n    this._setSenderMediaStreamTrack(true);\n\n    return result;\n  }\n\n  /**\n   * Remove the previously added {@link VideoProcessor} using `addProcessor` API.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to remove.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * const localVideoTrack = Array.from(room.localParticipant.videoTracks.values())[0].track;\n   * const grayScaleProcessor = new GrayScaleProcessor(100);\n   * localVideoTrack.addProcessor(grayScaleProcessor);\n   *\n   * document.getElementById('remove-button').onclick = () => localVideoTrack.removeProcessor(grayScaleProcessor);\n   */\n  removeProcessor() {\n    this._log.debug('Removing VideoProcessor from the LocalVideoTrack');\n    const result = super.removeProcessor.apply(this, arguments);\n\n    this._log.debug('Updating LocalVideoTrack\\'s MediaStreamTrack with the original MediaStreamTrack');\n    this._setSenderMediaStreamTrack()\n      .then(() => this._updateElementsMediaStreamTrack());\n\n    return result;\n  }\n\n  /**\n   * Disable the {@link LocalVideoTrack}. This is equivalent to pausing a video source.\n   * If a {@link VideoProcessor} is added, then <code>processedTrack</code> is also disabled.\n   * @returns {this}\n   * @fires VideoTrack#disabled\n   */\n  disable() {\n    const result = super.disable.apply(this, arguments);\n    if (this.processedTrack) {\n      this.processedTrack.enabled = false;\n    }\n    return result;\n  }\n\n  /**\n   * Enable the {@link LocalVideoTrack}. This is equivalent to unpausing the video source.\n   * If a {@link VideoProcessor} is added, then <code>processedTrack</code> is also enabled.\n   * @returns {this}\n   * @fires VideoTrack#enabled\n  *//**\n   * Enable or disable the {@link LocalVideoTrack}. This is equivalent to unpausing or pausing\n   * the video source respectively. If a {@link VideoProcessor} is added, then <code>processedTrack</code>\n   * is also enabled or disabled.\n   * @param {boolean} [enabled] - Specify false to disable the\n   *   {@link LocalVideoTrack}\n   * @returns {this}\n   * @fires VideoTrack#disabled\n   * @fires VideoTrack#enabled\n   */\n  enable(enabled = true) {\n    const result = super.enable.apply(this, arguments);\n    if (this.processedTrack) {\n      this.processedTrack.enabled = enabled;\n\n      if (enabled) {\n        this._captureFrames();\n        this._log.debug('Updating LocalVideoTrack\\'s MediaStreamTrack with the processed MediaStreamTrack', this.processedTrack);\n        this._setSenderMediaStreamTrack(true);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Restart the {@link LocalVideoTrack}. This stops the existing MediaStreamTrack\n   * and creates a new MediaStreamTrack. If the {@link LocalVideoTrack} is being published\n   * to a {@link Room}, then all the {@link RemoteParticipant}s will start receiving media\n   * from the newly created MediaStreamTrack. You can access the new MediaStreamTrack via\n   * the <code>mediaStreamTrack</code> property. If you want to listen to events on\n   * the MediaStreamTrack directly, please do so in the \"started\" event handler. Also,\n   * the {@link LocalVideoTrack}'s ID is no longer guaranteed to be the same as the\n   * underlying MediaStreamTrack's ID.\n   * @param {MediaTrackConstraints} [constraints] - The optional <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints\" target=\"_blank\">MediaTrackConstraints</a>\n   *   for restarting the {@link LocalVideoTrack}; If not specified, then the current MediaTrackConstraints\n   *   will be used; If <code>{}</code> (empty object) is specified, then the default MediaTrackConstraints\n   *   will be used\n   * @returns {Promise<void>} Rejects with a TypeError if the {@link LocalVideoTrack} was not created\n   *   using an one of <code>createLocalVideoTrack</code>, <code>createLocalTracks</code> or <code>connect</code>;\n   *   Also rejects with the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#Exceptions\" target=\"_blank\">DOMException</a>\n   *   raised by <code>getUserMedia</code> when it fails\n   * @fires LocalVideoTrack#stopped\n   * @fires LocalVideoTrack#started\n   * @example\n   * const { connect, createLocalVideoTrack } = require('twilio-video');\n   *\n   * // Create a LocalVideoTrack that captures video from the front-facing camera.\n   * createLocalVideoTrack({ facingMode: 'user' }).then(function(localVideoTrack) {\n   *   return connect('token', {\n   *     name: 'my-cool-room',\n   *     tracks: [localVideoTrack]\n   *   });\n   * }).then(function(room) {\n   *   // Restart the LocalVideoTrack to capture video from the back-facing camera.\n   *   const localVideoTrack = Array.from(room.localParticipant.videoTracks.values())[0].track;\n   *   return localVideoTrack.restart({ facingMode: 'environment' });\n   * });\n   */\n  restart() {\n    if (this._workaroundSilentLocalVideoCleanup) {\n      this._workaroundSilentLocalVideoCleanup();\n      this._workaroundSilentLocalVideoCleanup = null;\n    }\n\n    const promise = super.restart.apply(this, arguments);\n    if (this.processor) {\n      promise.then(() => {\n        this._restartProcessor();\n      });\n    }\n\n    if (this._workaroundSilentLocalVideo) {\n      promise.finally(() => {\n        this._workaroundSilentLocalVideoCleanup = this._workaroundSilentLocalVideo(this, document);\n      });\n    }\n    return promise;\n  }\n\n  /**\n   * Calls stop on the underlying MediaStreamTrack. If you choose to stop a\n   * {@link LocalVideoTrack}, you should unpublish it after stopping.\n   * @returns {this}\n   * @fires LocalVideoTrack#stopped\n   */\n  stop() {\n    if (this._workaroundSilentLocalVideoCleanup) {\n      this._workaroundSilentLocalVideoCleanup();\n      this._workaroundSilentLocalVideoCleanup = null;\n    }\n    return super.stop.apply(this, arguments);\n  }\n}\n\n/**\n * Work around a bug where local video MediaStreamTracks are silent (even though\n * they are enabled, live and unmuted) after accepting/rejecting a phone call.\n * @private\n * @param {LocalVideoTrack} localVideoTrack\n * @param {HTMLDocument} doc\n * @returns {function} Cleans up listeners attached by the workaround\n */\nfunction workaroundSilentLocalVideo(localVideoTrack, doc) {\n  const { _log: log } = localVideoTrack;\n  let { _dummyEl: el, mediaStreamTrack } = localVideoTrack;\n\n  function onUnmute() {\n    if (!localVideoTrack.isEnabled) {\n      return;\n    }\n    log.info('Unmuted, checking silence');\n\n    // The dummy element is paused, so play it and then detect silence.\n    el.play().then(() => detectSilentVideo(el, doc)).then(isSilent => {\n      if (!isSilent) {\n        log.info('Non-silent frames detected, so no need to restart');\n        return;\n      }\n      log.warn('Silence detected, restarting');\n\n      // NOTE(mmalavalli): If we try and restart a silent MediaStreamTrack\n      // without stopping it first, then a NotReadableError is raised. Hence,\n      // we stop the MediaStreamTrack here.\n      localVideoTrack._stop();\n\n      // Restart the LocalVideoTrack.\n      // eslint-disable-next-line consistent-return\n      return localVideoTrack._restart();\n    }).catch(error => {\n      log.warn('Failed to detect silence and restart:', error);\n    }).finally(() => {\n      // If silent frames were not detected, then pause the dummy element again,\n      // if there is no processed track.\n      el = localVideoTrack._dummyEl;\n      if (el && !el.paused && !localVideoTrack.processedTrack) {\n        el.pause();\n      }\n\n      // Reset the unmute handler.\n      mediaStreamTrack.removeEventListener('unmute', onUnmute);\n      mediaStreamTrack = localVideoTrack.mediaStreamTrack;\n      mediaStreamTrack.addEventListener('unmute', onUnmute);\n    });\n  }\n\n  // Set the unmute handler.\n  mediaStreamTrack.addEventListener('unmute', onUnmute);\n\n  return () => {\n    mediaStreamTrack.removeEventListener('unmute', onUnmute);\n  };\n}\n\n/**\n * The {@link LocalVideoTrack} was disabled, i.e. the video source was paused by the user.\n * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that was\n *   disabled\n * @event LocalVideoTrack#disabled\n */\n\n/**\n * The {@link LocalVideoTrack} was enabled, i.e. the video source was unpaused by the user.\n * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that was enabled\n * @event LocalVideoTrack#enabled\n */\n\n/**\n * The {@link LocalVideoTrack} was muted because the video source stopped sending frames, most\n * likely due to another application taking said video source, especially on mobile devices.\n * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that was muted\n * @event LocalVideoTrack#muted\n */\n\n/**\n * The {@link LocalVideoTrack} started. This means there is enough video data\n * to begin playback.\n * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that started\n * @event LocalVideoTrack#started\n */\n\n/**\n * The {@link LocalVideoTrack} stopped, either because {@link LocalVideoTrack#stop}\n * or {@link LocalVideoTrack#restart} was called or because the underlying\n * MediaStreamTrack ended.\n * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that stopped\n * @event LocalVideoTrack#stopped\n */\n\n/**\n * The {@link LocalVideoTrack} was unmuted because the video source resumed sending frames,\n * most likely due to the application that took over the said video source has released it\n * back to the application, especially on mobile devices. This event is also fired when\n * {@link LocalVideoTrack#restart} is called on a muted {@link LocalVideoTrack} with a\n * new video source.\n * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that was unmuted\n * @event LocalVideoTrack#unmuted\n */\n\nmodule.exports = LocalVideoTrack;\n"],"mappings":"AAAA,YAAY;;;;;;;;;;;;;;;;;;;;;;AAEJ,IAAAA,KAAK,GAAKC,OAAO,CAAC,6BAA6B,CAAC,CAAAD,KAA3C;AACb,IAAME,iBAAiB,GAAGD,OAAO,CAAC,8BAA8B,CAAC;AACjE,IAAME,oBAAoB,GAAGF,OAAO,CAAC,mBAAmB,CAAC;AACzD,IAAMG,UAAU,GAAGH,OAAO,CAAC,cAAc,CAAC;AAE1C,IAAMI,oBAAoB,GAAGF,oBAAoB,CAACC,UAAU,CAAC;AAE7D;;;;;;;;;;;;;;;;;;;;;AAqBA,IAAAE,eAAA,0BAAAC,MAAA;EAA8BC,SAAA,CAAAF,eAAA,EAAAC,MAAA;EAC5B;;;;;EAKA,SAAAD,gBAAYG,gBAAgB,EAAEC,OAAO;IAArC,IAAAC,KAAA;IACED,OAAO,GAAGE,MAAM,CAACC,MAAM,CAAC;MACtBC,0BAA0B,EAAEd,KAAK,EAAE,IAC9B,OAAOe,QAAQ,KAAK,WAAW,IAC/B,OAAOA,QAAQ,CAACC,aAAa,KAAK;KACxC,EAAEN,OAAO,CAAC;IAEXC,KAAA,GAAAJ,MAAA,CAAAU,IAAA,OAAMR,gBAAgB,EAAEC,OAAO,CAAC;IAEhCE,MAAM,CAACM,gBAAgB,CAACP,KAAI,EAAE;MAC5BQ,2BAA2B,EAAE;QAC3BC,KAAK,EAAEV,OAAO,CAACI,0BAA0B,GACrCA,0BAA0B,GAC1B;OACL;MACDO,kCAAkC,EAAE;QAClCD,KAAK,EAAE,IAAI;QACXE,QAAQ,EAAE;;KAEb,CAAC;IAEF;IACA;IACA;IACA,IAAIX,KAAI,CAACQ,2BAA2B,EAAE;MACpCR,KAAI,CAACU,kCAAkC,GAAGV,KAAI,CAACQ,2BAA2B,CAACR,KAAI,EAAEI,QAAQ,CAAC;;;EAE9F;EAEAT,eAAA,CAAAiB,SAAA,CAAAC,QAAQ,GAAR;IACE,OAAO,uBAAqB,IAAI,CAACC,WAAW,UAAK,IAAI,CAACC,EAAE,MAAG;EAC7D,CAAC;EAED;;;EAGApB,eAAA,CAAAiB,SAAA,CAAAI,wBAAwB,GAAxB;IACE,OAAOpB,MAAA,CAAAgB,SAAA,CAAMI,wBAAwB,CAACV,IAAI,CAAC,IAAI,EAAE,IAAI,CAACW,YAAY,CAACC,YAAY,CAAC;EAClF,CAAC;EAED;;;EAGAvB,eAAA,CAAAiB,SAAA,CAAAO,IAAI,GAAJ;IACE,OAAOvB,MAAA,CAAAgB,SAAA,CAAMO,IAAI,CAACC,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;EAC1C,CAAC;EAED;;;EAGA1B,eAAA,CAAAiB,SAAA,CAAAU,0BAA0B,GAA1B,UAA2BC,YAAY;IAAvC,IAAAvB,KAAA;IACE,IAAMwB,gBAAgB,GAAG,IAAI,CAAC1B,gBAAgB;IAC9C,IAAMA,gBAAgB,GAAGyB,YAAY,GAAG,IAAI,CAACE,cAAc,GAAGD,gBAAgB;IAE9E,OAAO,IAAI,CAACP,YAAY,CAACS,mBAAmB,CAAC5B,gBAAgB,CAAC,CAC3D6B,KAAK,CAAC,UAAAC,KAAK;MAAI,OAAA5B,KAAI,CAAC6B,IAAI,CAACC,IAAI,CAC5B,4DAA4D,EAAE;QAAEF,KAAK,EAAAA,KAAA;QAAE9B,gBAAgB,EAAAA;MAAA,CAAE,CAAC;IAD5E,CAC4E,CAAC,CAC5FiC,IAAI,CAAC;MACJ/B,KAAI,CAACgC,iBAAiB,GAAGT,YAAY,GAAGC,gBAAgB,GAAG,IAAI;IACjE,CAAC,CAAC;EACN,CAAC;EAED;;;;;;;;;;;;;;;;;;;;EAoBA7B,eAAA,CAAAiB,SAAA,CAAAqB,YAAY,GAAZ;IACE,IAAI,CAACJ,IAAI,CAACK,KAAK,CAAC,8CAA8C,CAAC;IAC/D,IAAMC,MAAM,GAAGvC,MAAA,CAAAgB,SAAA,CAAMqB,YAAY,CAACb,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;IAExD,IAAI,CAAC,IAAI,CAACI,cAAc,EAAE;MACxB,OAAO,IAAI,CAACI,IAAI,CAACC,IAAI,CAAC,uDAAuD,CAAC;;IAGhF,IAAI,CAACD,IAAI,CAACK,KAAK,CAAC,kFAAkF,EAAE,IAAI,CAACT,cAAc,CAAC;IACxH,IAAI,CAACH,0BAA0B,CAAC,IAAI,CAAC;IAErC,OAAOa,MAAM;EACf,CAAC;EAED;;;;;;;;;;;;;;;;;;;;;;EAsBAxC,eAAA,CAAAiB,SAAA,CAAAwB,eAAe,GAAf;IAAA,IAAApC,KAAA;IACE,IAAI,CAAC6B,IAAI,CAACK,KAAK,CAAC,kDAAkD,CAAC;IACnE,IAAMC,MAAM,GAAGvC,MAAA,CAAAgB,SAAA,CAAMwB,eAAe,CAAChB,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;IAE3D,IAAI,CAACQ,IAAI,CAACK,KAAK,CAAC,iFAAiF,CAAC;IAClG,IAAI,CAACZ,0BAA0B,EAAE,CAC9BS,IAAI,CAAC;MAAM,OAAA/B,KAAI,CAACqC,+BAA+B,EAAE;IAAtC,CAAsC,CAAC;IAErD,OAAOF,MAAM;EACf,CAAC;EAED;;;;;;EAMAxC,eAAA,CAAAiB,SAAA,CAAA0B,OAAO,GAAP;IACE,IAAMH,MAAM,GAAGvC,MAAA,CAAAgB,SAAA,CAAM0B,OAAO,CAAClB,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;IACnD,IAAI,IAAI,CAACI,cAAc,EAAE;MACvB,IAAI,CAACA,cAAc,CAACc,OAAO,GAAG,KAAK;;IAErC,OAAOJ,MAAM;EACf,CAAC;EAED;;;;;IAAA,CAKE;;;;;;;;;;EAUFxC,eAAA,CAAAiB,SAAA,CAAA4B,MAAM,GAAN,UAAOD,OAAc;IAAd,IAAAA,OAAA;MAAAA,OAAA,OAAc;IAAA;IACnB,IAAMJ,MAAM,GAAGvC,MAAA,CAAAgB,SAAA,CAAM4B,MAAM,CAACpB,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;IAClD,IAAI,IAAI,CAACI,cAAc,EAAE;MACvB,IAAI,CAACA,cAAc,CAACc,OAAO,GAAGA,OAAO;MAErC,IAAIA,OAAO,EAAE;QACX,IAAI,CAACE,cAAc,EAAE;QACrB,IAAI,CAACZ,IAAI,CAACK,KAAK,CAAC,kFAAkF,EAAE,IAAI,CAACT,cAAc,CAAC;QACxH,IAAI,CAACH,0BAA0B,CAAC,IAAI,CAAC;;;IAGzC,OAAOa,MAAM;EACf,CAAC;EAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAkCAxC,eAAA,CAAAiB,SAAA,CAAA8B,OAAO,GAAP;IAAA,IAAA1C,KAAA;IACE,IAAI,IAAI,CAACU,kCAAkC,EAAE;MAC3C,IAAI,CAACA,kCAAkC,EAAE;MACzC,IAAI,CAACA,kCAAkC,GAAG,IAAI;;IAGhD,IAAMiC,OAAO,GAAG/C,MAAA,CAAAgB,SAAA,CAAM8B,OAAO,CAACtB,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;IACpD,IAAI,IAAI,CAACuB,SAAS,EAAE;MAClBD,OAAO,CAACZ,IAAI,CAAC;QACX/B,KAAI,CAAC6C,iBAAiB,EAAE;MAC1B,CAAC,CAAC;;IAGJ,IAAI,IAAI,CAACrC,2BAA2B,EAAE;MACpCmC,OAAO,CAACG,OAAO,CAAC;QACd9C,KAAI,CAACU,kCAAkC,GAAGV,KAAI,CAACQ,2BAA2B,CAACR,KAAI,EAAEI,QAAQ,CAAC;MAC5F,CAAC,CAAC;;IAEJ,OAAOuC,OAAO;EAChB,CAAC;EAED;;;;;;EAMAhD,eAAA,CAAAiB,SAAA,CAAAmC,IAAI,GAAJ;IACE,IAAI,IAAI,CAACrC,kCAAkC,EAAE;MAC3C,IAAI,CAACA,kCAAkC,EAAE;MACzC,IAAI,CAACA,kCAAkC,GAAG,IAAI;;IAEhD,OAAOd,MAAA,CAAAgB,SAAA,CAAMmC,IAAI,CAAC3B,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;EAC1C,CAAC;EACH,OAAA1B,eAAC;AAAD,CAAC,CAtP6BD,oBAAoB;AAwPlD;;;;;;;;AAQA,SAASS,0BAA0BA,CAAC6C,eAAe,EAAEC,GAAG;EAC9C,IAAMC,GAAG,GAAKF,eAAe,CAAAnB,IAApB;EACX,IAAUsB,EAAE,GAAuBH,eAAe,CAAAI,QAAtC;IAAEtD,gBAAgB,GAAKkD,eAAe,CAAAlD,gBAApB;EAEpC,SAASuD,QAAQA,CAAA;IACf,IAAI,CAACL,eAAe,CAACM,SAAS,EAAE;MAC9B;;IAEFJ,GAAG,CAACK,IAAI,CAAC,2BAA2B,CAAC;IAErC;IACAJ,EAAE,CAACK,IAAI,EAAE,CAACzB,IAAI,CAAC;MAAM,OAAAxC,iBAAiB,CAAC4D,EAAE,EAAEF,GAAG,CAAC;IAA1B,CAA0B,CAAC,CAAClB,IAAI,CAAC,UAAA0B,QAAQ;MAC5D,IAAI,CAACA,QAAQ,EAAE;QACbP,GAAG,CAACK,IAAI,CAAC,mDAAmD,CAAC;QAC7D;;MAEFL,GAAG,CAACpB,IAAI,CAAC,8BAA8B,CAAC;MAExC;MACA;MACA;MACAkB,eAAe,CAACU,KAAK,EAAE;MAEvB;MACA;MACA,OAAOV,eAAe,CAACW,QAAQ,EAAE;IACnC,CAAC,CAAC,CAAChC,KAAK,CAAC,UAAAC,KAAK;MACZsB,GAAG,CAACpB,IAAI,CAAC,uCAAuC,EAAEF,KAAK,CAAC;IAC1D,CAAC,CAAC,CAACkB,OAAO,CAAC;MACT;MACA;MACAK,EAAE,GAAGH,eAAe,CAACI,QAAQ;MAC7B,IAAID,EAAE,IAAI,CAACA,EAAE,CAACS,MAAM,IAAI,CAACZ,eAAe,CAACvB,cAAc,EAAE;QACvD0B,EAAE,CAACU,KAAK,EAAE;;MAGZ;MACA/D,gBAAgB,CAACgE,mBAAmB,CAAC,QAAQ,EAAET,QAAQ,CAAC;MACxDvD,gBAAgB,GAAGkD,eAAe,CAAClD,gBAAgB;MACnDA,gBAAgB,CAACiE,gBAAgB,CAAC,QAAQ,EAAEV,QAAQ,CAAC;IACvD,CAAC,CAAC;EACJ;EAEA;EACAvD,gBAAgB,CAACiE,gBAAgB,CAAC,QAAQ,EAAEV,QAAQ,CAAC;EAErD,OAAO;IACLvD,gBAAgB,CAACgE,mBAAmB,CAAC,QAAQ,EAAET,QAAQ,CAAC;EAC1D,CAAC;AACH;AAEA;;;;;;AAOA;;;;;AAMA;;;;;;AAOA;;;;;;AAOA;;;;;;;AAQA;;;;;;;;;AAUAW,MAAM,CAACC,OAAO,GAAGtE,eAAe"},"metadata":{},"sourceType":"script","externalDependencies":[]}