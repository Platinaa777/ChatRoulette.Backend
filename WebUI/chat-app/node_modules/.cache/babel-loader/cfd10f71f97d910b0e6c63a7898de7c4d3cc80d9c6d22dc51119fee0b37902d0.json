{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar MediaTrack = require('./mediatrack');\nvar VideoProcessorEventObserver = require('./videoprocessoreventobserver');\nvar DEFAULT_FRAME_RATE = require('../../util/constants').DEFAULT_FRAME_RATE;\n/**\n * A {@link VideoTrack} is a {@link Track} representing video.\n * @extends Track\n * @property {boolean} isStarted - Whether or not the {@link VideoTrack} has\n *   started; if the {@link VideoTrack} started, there is enough video data to\n *   begin playback\n * @property {boolean} isEnabled - Whether or not the {@link VideoTrack} is\n *   enabled; if the {@link VideoTrack} is not enabled, it is \"paused\"\n * @property {VideoTrack.Dimensions} dimensions - The {@link VideoTrack}'s\n *   {@link VideoTrack.Dimensions}\n * @property {Track.Kind} kind - \"video\"\n * @property {MediaStreamTrack} mediaStreamTrack - A video MediaStreamTrack\n * @property {?MediaStreamTrack} processedTrack - The source of processed video frames.\n * It is null if no VideoProcessor has been added.\n * @property {?VideoProcessor} processor - A {@link VideoProcessor} that is currently\n *   processing video frames. It is null if video frames are not being processed.\n * @emits VideoTrack#dimensionsChanged\n * @emits VideoTrack#disabled\n * @emits VideoTrack#enabled\n * @emits VideoTrack#started\n */\nvar VideoTrack = /** @class */function (_super) {\n  __extends(VideoTrack, _super);\n  /**\n   * Construct a {@link VideoTrack}.\n   * @param {MediaTrackTransceiver} mediaTrackTransceiver\n   * @param {{log: Log}} options\n   */\n  function VideoTrack(mediaTrackTransceiver, options) {\n    var _this = _super.call(this, mediaTrackTransceiver, options) || this;\n    Object.defineProperties(_this, {\n      _captureTimeoutId: {\n        value: null,\n        writable: true\n      },\n      _isCapturing: {\n        value: false,\n        writable: true\n      },\n      _inputFrame: {\n        value: null,\n        writable: true\n      },\n      _outputFrame: {\n        value: null,\n        writable: true\n      },\n      _processorEventObserver: {\n        value: null,\n        writable: true\n      },\n      _processorOptions: {\n        value: {},\n        writable: true\n      },\n      _unmuteHandler: {\n        value: null,\n        writable: true\n      },\n      dimensions: {\n        enumerable: true,\n        value: {\n          width: null,\n          height: null\n        }\n      },\n      processor: {\n        enumerable: true,\n        value: null,\n        writable: true\n      }\n    });\n    _this._processorEventObserver = new (options.VideoProcessorEventObserver || VideoProcessorEventObserver)(_this._log);\n    return _this;\n  }\n  /**\n   * @private\n   */\n  VideoTrack.prototype._checkIfCanCaptureFrames = function (isPublishing) {\n    if (isPublishing === void 0) {\n      isPublishing = false;\n    }\n    var canCaptureFrames = true;\n    var message = '';\n    var _a = this.mediaStreamTrack,\n      enabled = _a.enabled,\n      readyState = _a.readyState;\n    if (!enabled) {\n      canCaptureFrames = false;\n      message = 'MediaStreamTrack is disabled';\n    }\n    if (readyState === 'ended') {\n      canCaptureFrames = false;\n      message = 'MediaStreamTrack is ended';\n    }\n    if (!this.processor) {\n      canCaptureFrames = false;\n      message = 'VideoProcessor not detected.';\n    }\n    if (!this._attachments.size && !isPublishing) {\n      canCaptureFrames = false;\n      message = 'VideoTrack is not publishing and there is no attached element.';\n    }\n    if (message) {\n      this._log.debug(message);\n    }\n    return {\n      canCaptureFrames: canCaptureFrames,\n      message: message\n    };\n  };\n  /**\n   * @private\n   */\n  VideoTrack.prototype._captureFrames = function () {\n    var _this = this;\n    if (this._isCapturing) {\n      this._log.debug('Ignoring captureFrames call. Capture is already in progress');\n      return;\n    }\n    if (!this._checkIfCanCaptureFrames().canCaptureFrames) {\n      this._isCapturing = false;\n      this._log.debug('Cannot capture frames. Ignoring captureFrames call.');\n      return;\n    }\n    this._isCapturing = true;\n    this._processorEventObserver.emit('start');\n    this._log.debug('Start capturing frames');\n    var startTime = Date.now();\n    var processFramePeriodMs;\n    this._dummyEl.play().then(function () {\n      var captureFrame = function (cb) {\n        clearTimeout(_this._captureTimeoutId);\n        var _a = _this.mediaStreamTrack.getSettings().frameRate,\n          frameRate = _a === void 0 ? DEFAULT_FRAME_RATE : _a;\n        var capturePeriodMs = Math.floor(1000 / frameRate);\n        var delay = capturePeriodMs - processFramePeriodMs;\n        if (delay < 0 || typeof processFramePeriodMs !== 'number') {\n          delay = 0;\n        }\n        _this._captureTimeoutId = setTimeout(cb, delay);\n      };\n      var process = function () {\n        var checkResult = _this._checkIfCanCaptureFrames();\n        if (!checkResult.canCaptureFrames) {\n          _this._isCapturing = false;\n          _this._processorEventObserver.emit('stop', checkResult.message);\n          _this._log.debug('Cannot capture frames. Stopping capturing frames.');\n          return;\n        }\n        startTime = Date.now();\n        var _a = _this.mediaStreamTrack.getSettings(),\n          _b = _a.width,\n          width = _b === void 0 ? 0 : _b,\n          _c = _a.height,\n          height = _c === void 0 ? 0 : _c;\n        // Setting the canvas' dimension triggers a redraw.\n        // Only set it if it has changed.\n        if (_this._outputFrame && _this._outputFrame.width !== width) {\n          _this._outputFrame.width = width;\n          _this._outputFrame.height = height;\n        }\n        if (_this._inputFrame) {\n          if (_this._inputFrame.width !== width) {\n            _this._inputFrame.width = width;\n            _this._inputFrame.height = height;\n          }\n          _this._inputFrame.getContext('2d').drawImage(_this._dummyEl, 0, 0, width, height);\n        }\n        var result = null;\n        try {\n          var input = _this._processorOptions.inputFrameBufferType === 'video' ? _this._dummyEl : _this._inputFrame;\n          result = _this.processor.processFrame(input, _this._outputFrame);\n        } catch (ex) {\n          _this._log.debug('Exception detected after calling processFrame.', ex);\n        }\n        (result instanceof Promise ? result : Promise.resolve(result)).then(function () {\n          if (_this._outputFrame) {\n            if (typeof _this.processedTrack.requestFrame === 'function') {\n              _this.processedTrack.requestFrame();\n            }\n            _this._processorEventObserver.emit('stats');\n          }\n        }).finally(function () {\n          processFramePeriodMs = Date.now() - startTime;\n          captureFrame(process);\n        });\n      };\n      captureFrame(process);\n    }).catch(function (error) {\n      return _this._log.error('Video element cannot be played', {\n        error: error,\n        track: _this\n      });\n    });\n  };\n  /**\n   * @private\n   */\n  VideoTrack.prototype._initialize = function () {\n    var _this = this;\n    _super.prototype._initialize.call(this);\n    if (this._dummyEl) {\n      this._dummyEl.onloadedmetadata = function () {\n        if (dimensionsChanged(_this, _this._dummyEl)) {\n          _this.dimensions.width = _this._dummyEl.videoWidth;\n          _this.dimensions.height = _this._dummyEl.videoHeight;\n        }\n      };\n      this._dummyEl.onresize = function () {\n        if (dimensionsChanged(_this, _this._dummyEl)) {\n          _this.dimensions.width = _this._dummyEl.videoWidth;\n          _this.dimensions.height = _this._dummyEl.videoHeight;\n          if (_this.isStarted) {\n            _this._log.debug('Dimensions changed:', _this.dimensions);\n            _this.emit(VideoTrack.DIMENSIONS_CHANGED, _this);\n          }\n        }\n      };\n    }\n  };\n  /**\n   * @private\n   */\n  VideoTrack.prototype._restartProcessor = function () {\n    var processor = this.processor;\n    if (processor) {\n      var processorOptions = Object.assign({}, this._processorOptions);\n      this.removeProcessor(processor);\n      this.addProcessor(processor, processorOptions);\n    }\n  };\n  /**\n   * @private\n   */\n  VideoTrack.prototype._start = function (dummyEl) {\n    this.dimensions.width = dummyEl.videoWidth;\n    this.dimensions.height = dummyEl.videoHeight;\n    this._log.debug('Dimensions:', this.dimensions);\n    this.emit(VideoTrack.DIMENSIONS_CHANGED, this);\n    return _super.prototype._start.call(this, dummyEl);\n  };\n  /**\n   * Add a {@link VideoProcessor} to allow for custom processing of video frames belonging to a VideoTrack.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to use.\n   * @param {AddProcessorOptions} [options] - {@link AddProcessorOptions} to provide.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * Video.createLocalVideoTrack().then(function(videoTrack) {\n   *   videoTrack.addProcessor(new GrayScaleProcessor(100));\n   * });\n   */\n  VideoTrack.prototype.addProcessor = function (processor, options) {\n    var _this = this;\n    if (!processor || typeof processor.processFrame !== 'function') {\n      throw new Error('Received an invalid VideoProcessor from addProcessor.');\n    }\n    if (this.processor) {\n      throw new Error('A VideoProcessor has already been added.');\n    }\n    if (!this._dummyEl) {\n      throw new Error('VideoTrack has not been initialized.');\n    }\n    this._log.debug('Adding VideoProcessor to the VideoTrack', processor);\n    if (!this._unmuteHandler) {\n      this._unmuteHandler = function () {\n        _this._log.debug('mediaStreamTrack unmuted');\n        // NOTE(csantos): On certain scenarios where mediaStreamTrack is coming from muted to unmuted state,\n        // the processedTrack doesn't unmutes automatically although enabled is already set to true.\n        // This is a terminal state for the processedTrack and should be restarted. (VIDEO-4176)\n        if (_this.processedTrack.muted) {\n          _this._log.debug('mediaStreamTrack is unmuted but processedTrack is muted. Restarting processor.');\n          _this._restartProcessor();\n        }\n      };\n      this.mediaStreamTrack.addEventListener('unmute', this._unmuteHandler);\n    }\n    this._processorOptions = options || {};\n    var _a = this._processorOptions,\n      inputFrameBufferType = _a.inputFrameBufferType,\n      outputFrameBufferContextType = _a.outputFrameBufferContextType;\n    if (typeof OffscreenCanvas === 'undefined' && inputFrameBufferType === 'offscreencanvas') {\n      throw new Error('OffscreenCanvas is not supported by this browser.');\n    }\n    if (inputFrameBufferType && inputFrameBufferType !== 'video' && inputFrameBufferType !== 'canvas' && inputFrameBufferType !== 'offscreencanvas') {\n      throw new Error(\"Invalid inputFrameBufferType of \" + inputFrameBufferType);\n    }\n    if (!inputFrameBufferType) {\n      inputFrameBufferType = typeof OffscreenCanvas === 'undefined' ? 'canvas' : 'offscreencanvas';\n    }\n    var _b = this.mediaStreamTrack.getSettings(),\n      _c = _b.width,\n      width = _c === void 0 ? 0 : _c,\n      _d = _b.height,\n      height = _d === void 0 ? 0 : _d,\n      _e = _b.frameRate,\n      frameRate = _e === void 0 ? DEFAULT_FRAME_RATE : _e;\n    if (inputFrameBufferType === 'offscreencanvas') {\n      this._inputFrame = new OffscreenCanvas(width, height);\n    }\n    if (inputFrameBufferType === 'canvas') {\n      this._inputFrame = document.createElement('canvas');\n    }\n    if (this._inputFrame) {\n      this._inputFrame.width = width;\n      this._inputFrame.height = height;\n    }\n    this._outputFrame = document.createElement('canvas');\n    this._outputFrame.width = width;\n    this._outputFrame.height = height;\n    // NOTE(csantos): Initialize the rendering context for future renders. This also ensures\n    // that the correct type is used and on Firefox, it throws an exception if you try to capture\n    // frames prior calling getContext https://bugzilla.mozilla.org/show_bug.cgi?id=1572422\n    outputFrameBufferContextType = outputFrameBufferContextType || '2d';\n    var ctx = this._outputFrame.getContext(outputFrameBufferContextType);\n    if (!ctx) {\n      throw new Error(\"Cannot get outputFrameBufferContextType: \" + outputFrameBufferContextType + \".\");\n    }\n    // NOTE(csantos): Zero FPS means we can control when to render the next frame by calling requestFrame.\n    // Some browsers such as Firefox doesn't support requestFrame so we will use default, which is an undefined value.\n    // This means, the browser will use the highest FPS available.\n    var targetFps = typeof CanvasCaptureMediaStreamTrack !== 'undefined' && CanvasCaptureMediaStreamTrack.prototype &&\n    // eslint-disable-next-line\n    typeof CanvasCaptureMediaStreamTrack.prototype.requestFrame === 'function' ? 0 : undefined;\n    this.processedTrack = this._outputFrame.captureStream(targetFps).getTracks()[0];\n    this.processedTrack.enabled = this.mediaStreamTrack.enabled;\n    this.processor = processor;\n    this._processorEventObserver.emit('add', {\n      processor: processor,\n      captureHeight: height,\n      captureWidth: width,\n      inputFrameRate: frameRate,\n      isRemoteVideoTrack: this.toString().includes('RemoteVideoTrack'),\n      inputFrameBufferType: inputFrameBufferType,\n      outputFrameBufferContextType: outputFrameBufferContextType\n    });\n    this._updateElementsMediaStreamTrack();\n    this._captureFrames();\n    return this;\n  };\n  /**\n   * Create an HTMLVideoElement and attach the {@link VideoTrack} to it.\n   *\n   * The HTMLVideoElement's <code>srcObject</code> will be set to a new\n   * MediaStream containing the {@link VideoTrack}'s MediaStreamTrack.\n   *\n   * @returns {HTMLVideoElement} videoElement\n   * @example\n   * const Video = require('twilio-video');\n   *\n   * Video.createLocalVideoTrack().then(function(videoTrack) {\n   *   const videoElement = videoTrack.attach();\n   *   document.body.appendChild(videoElement);\n   * });\n  */ /**\n     * Attach the {@link VideoTrack} to an existing HTMLMediaElement. The\n     * HTMLMediaElement could be an HTMLAudioElement or an HTMLVideoElement.\n     *\n     * If the HTMLMediaElement's <code>srcObject</code> is not set to a MediaStream,\n     * this method sets it to a new MediaStream containing the {@link VideoTrack}'s\n     * MediaStreamTrack; otherwise, it adds the {@link MediaTrack}'s\n     * MediaStreamTrack to the existing MediaStream. Finally, if there are any other\n     * MediaStreamTracks of the same kind on the MediaStream, this method removes\n     * them.\n     *\n     * @param {HTMLMediaElement} mediaElement - The HTMLMediaElement to attach to\n     * @returns {HTMLMediaElement} mediaElement\n     * @example\n     * const Video = require('twilio-video');\n     *\n     * const videoElement = document.createElement('video');\n     * document.body.appendChild(videoElement);\n     *\n     * Video.createLocalVideoTrack().then(function(videoTrack) {\n     *   videoTrack.attach(videoElement);\n     * });\n     */ /**\n        * Attach the {@link VideoTrack} to an HTMLMediaElement selected by\n        * <code>document.querySelector</code>. The HTMLMediaElement could be an\n        * HTMLAudioElement or an HTMLVideoElement.\n        *\n        * If the HTMLMediaElement's <code>srcObject</code> is not set to a MediaStream,\n        * this method sets it to a new MediaStream containing the {@link VideoTrack}'s\n        * MediaStreamTrack; otherwise, it adds the {@link VideoTrack}'s\n        * MediaStreamTrack to the existing MediaStream. Finally, if there are any other\n        * MediaStreamTracks of the same kind on the MediaStream, this method removes\n        * them.\n        *\n        * @param {string} selector - A query selector for the HTMLMediaElement to\n        *   attach to\n        * @returns {HTMLMediaElement} mediaElement\n        * @example\n        * const Video = require('twilio-video');\n        *\n        * const videoElement = document.createElement('video');\n        * videoElement.id = 'my-video-element';\n        * document.body.appendChild(videoElement);\n        *\n        * Video.createLocalVideoTrack().then(function(track) {\n        *   track.attach('#my-video-element');\n        * });\n        */\n  VideoTrack.prototype.attach = function () {\n    var result = _super.prototype.attach.apply(this, arguments);\n    if (this.processor) {\n      this._captureFrames();\n    }\n    return result;\n  };\n  /**\n   * Detach the {@link VideoTrack} from all previously attached HTMLMediaElements.\n   * @returns {Array<HTMLMediaElement>} mediaElements\n   * @example\n   * const mediaElements = videoTrack.detach();\n   * mediaElements.forEach(mediaElement => mediaElement.remove());\n  */ /**\n     * Detach the {@link VideoTrack} from a previously attached HTMLMediaElement.\n     * @param {HTMLMediaElement} mediaElement - One of the HTMLMediaElements to\n     *   which the {@link VideoTrack} is attached\n     * @returns {HTMLMediaElement} mediaElement\n     * @example\n     * const videoElement = document.getElementById('my-video-element');\n     * videoTrack.detach(videoElement).remove();\n     */ /**\n        * Detach the {@link VideoTrack} from a previously attached HTMLMediaElement\n        *   specified by <code>document.querySelector</code>.\n        * @param {string} selector - The query selector of HTMLMediaElement to which\n        *    the {@link VideoTrack} is attached\n        * @returns {HTMLMediaElement} mediaElement\n        * @example\n        * videoTrack.detach('#my-video-element').remove();\n        */\n  VideoTrack.prototype.detach = function () {\n    return _super.prototype.detach.apply(this, arguments);\n  };\n  /**\n   * Remove the previously added {@link VideoProcessor} using `addProcessor` API.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to remove.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * Video.createLocalVideoTrack().then(function(videoTrack) {\n   *   const grayScaleProcessor = new GrayScaleProcessor(100);\n   *   videoTrack.addProcessor(grayScaleProcessor);\n   *   document.getElementById('remove-button').onclick = () => videoTrack.removeProcessor(grayScaleProcessor);\n   * });\n   */\n  VideoTrack.prototype.removeProcessor = function (processor) {\n    if (!processor) {\n      throw new Error('Received an invalid VideoProcessor from removeProcessor.');\n    }\n    if (!this.processor) {\n      throw new Error('No existing VideoProcessor detected.');\n    }\n    if (processor !== this.processor) {\n      throw new Error('The provided VideoProcessor is different than the existing one.');\n    }\n    this._processorEventObserver.emit('remove');\n    this._log.debug('Removing VideoProcessor from the VideoTrack', processor);\n    clearTimeout(this._captureTimeoutId);\n    this.mediaStreamTrack.removeEventListener('unmute', this._unmuteHandler);\n    this._processorOptions = {};\n    this._unmuteHandler = null;\n    this._isCapturing = false;\n    this.processor = null;\n    this.processedTrack = null;\n    this._inputFrame = null;\n    this._outputFrame = null;\n    this._updateElementsMediaStreamTrack();\n    return this;\n  };\n  return VideoTrack;\n}(MediaTrack);\nVideoTrack.DIMENSIONS_CHANGED = 'dimensionsChanged';\nfunction dimensionsChanged(track, elem) {\n  return track.dimensions.width !== elem.videoWidth || track.dimensions.height !== elem.videoHeight;\n}\n/**\n * A {@link VideoTrack}'s width and height.\n * @typedef {object} VideoTrack.Dimensions\n * @property {?number} width - The {@link VideoTrack}'s width or null if the\n *   {@link VideoTrack} has not yet started\n * @property {?number} height - The {@link VideoTrack}'s height or null if the\n *   {@link VideoTrack} has not yet started\n */\n/**\n * A {@link VideoProcessor}, when added via {@link VideoTrack#addProcessor},\n * is used to process incoming video frames before\n * sending to the encoder or renderer.\n * @typedef {object} VideoProcessor\n * @property {function} processFrame - A callback to receive input and output frame buffers for processing.\n * The input frame buffer contains the original video frame which can be used for additional processing\n * such as applying filters to it. The output frame buffer is used to receive the processed video frame\n * before sending to the encoder or renderer.\n *\n * Any exception raised (either synchronously or asynchronously) in `processFrame` will result in the frame being dropped.\n * This callback has the following signature:<br/><br/>\n * <code>processFrame(</code><br/>\n * &nbsp;&nbsp;<code>inputFrameBuffer: OffscreenCanvas | HTMLCanvasElement | HTMLVideoElement,</code><br/>\n * &nbsp;&nbsp;<code>outputFrameBuffer: HTMLCanvasElement</code><br/>\n * <code>): Promise&lt;void&gt; | void;</code>\n *\n * @example\n * class GrayScaleProcessor {\n *   constructor(percentage) {\n *     this.percentage = percentage;\n *   }\n *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n *     const context = outputFrameBuffer.getContext('2d');\n *     context.filter = `grayscale(${this.percentage}%)`;\n *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n *   }\n * }\n */\n/**\n * Possible options to provide to {@link LocalVideoTrack#addProcessor} and {@link RemoteVideoTrack#addProcessor}.\n * @typedef {object} AddProcessorOptions\n * @property {string} [inputFrameBufferType=\"offscreencanvas\"] - This option allows you to specify what kind of input you want to receive in your\n * Video Processor. The default is `offscreencanvas` and will fallback to a regular `canvas` if the browser does not support it.\n * Possible values include the following.\n * <br/>\n * <br/>\n * `offscreencanvas` - Your Video Processor will receive an [OffscreenCanvas](https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas)\n * which is good for canvas-related processing that can be rendered off screen.\n * <br/>\n * <br/>\n * `canvas` - Your Video Processor will receive an [HTMLCanvasElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement).\n * This is recommended on browsers that doesn't support `OffscreenCanvas`, or if you need to render the frame on the screen.\n * <br/>\n * <br/>\n * `video` - Your Video Processor will receive an [HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement).\n * Use this option if you are processing the frame using WebGL or if you only need to [draw](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage)\n * the frame directly to your output canvas.\n * @property {string} [outputFrameBufferContextType=\"2d\"] - The SDK needs the [context type](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext)\n * that your Video Processor uses in order to properly generate the processed track. For example, if your Video Processor uses WebGL2 (`canvas.getContext('webgl2')`),\n * you should set `outputFrameBufferContextType` to `webgl2`. Or if you're using Canvas 2D processing (`canvas.getContext('2d')`),\n * you should set `outputFrameBufferContextType` to `2d`.\n */\n/**\n * The {@link VideoTrack}'s dimensions changed.\n * @param {VideoTrack} track - The {@link VideoTrack} whose dimensions changed\n * @event VideoTrack#dimensionsChanged\n */\n/**\n * The {@link VideoTrack} was disabled, i.e. \"paused\".\n * @param {VideoTrack} track - The {@link VideoTrack} that was disabled\n * @event VideoTrack#disabled\n */\n/**\n * The {@link VideoTrack} was enabled, i.e. \"unpaused\".\n * @param {VideoTrack} track - The {@link VideoTrack} that was enabled\n * @event VideoTrack#enabled\n */\n/**\n * The {@link VideoTrack} started. This means there is enough video data to\n * begin playback.\n * @param {VideoTrack} track - The {@link VideoTrack} that started\n * @event VideoTrack#started\n */\nmodule.exports = VideoTrack;","map":{"version":3,"names":["MediaTrack","require","VideoProcessorEventObserver","DEFAULT_FRAME_RATE","VideoTrack","_super","__extends","mediaTrackTransceiver","options","_this","call","Object","defineProperties","_captureTimeoutId","value","writable","_isCapturing","_inputFrame","_outputFrame","_processorEventObserver","_processorOptions","_unmuteHandler","dimensions","enumerable","width","height","processor","_log","prototype","_checkIfCanCaptureFrames","isPublishing","canCaptureFrames","message","_a","mediaStreamTrack","enabled","readyState","_attachments","size","debug","_captureFrames","emit","startTime","Date","now","processFramePeriodMs","_dummyEl","play","then","captureFrame","cb","clearTimeout","getSettings","frameRate","capturePeriodMs","Math","floor","delay","setTimeout","process","checkResult","_b","_c","getContext","drawImage","result","input","inputFrameBufferType","processFrame","ex","Promise","resolve","processedTrack","requestFrame","finally","catch","error","track","_initialize","onloadedmetadata","dimensionsChanged","videoWidth","videoHeight","onresize","isStarted","DIMENSIONS_CHANGED","_restartProcessor","processorOptions","assign","removeProcessor","addProcessor","_start","dummyEl","Error","muted","addEventListener","outputFrameBufferContextType","OffscreenCanvas","_d","_e","document","createElement","ctx","targetFps","CanvasCaptureMediaStreamTrack","undefined","captureStream","getTracks","captureHeight","captureWidth","inputFrameRate","isRemoteVideoTrack","toString","includes","_updateElementsMediaStreamTrack","attach","apply","arguments","detach","removeEventListener","elem","module","exports"],"sources":["/home/denis/RiderProjects/ChatRoulette/WebUI/chat-app/node_modules/twilio-video/lib/media/track/videotrack.js"],"sourcesContent":["'use strict';\n\nconst MediaTrack = require('./mediatrack');\nconst VideoProcessorEventObserver = require('./videoprocessoreventobserver');\nconst { DEFAULT_FRAME_RATE } = require('../../util/constants');\n\n/**\n * A {@link VideoTrack} is a {@link Track} representing video.\n * @extends Track\n * @property {boolean} isStarted - Whether or not the {@link VideoTrack} has\n *   started; if the {@link VideoTrack} started, there is enough video data to\n *   begin playback\n * @property {boolean} isEnabled - Whether or not the {@link VideoTrack} is\n *   enabled; if the {@link VideoTrack} is not enabled, it is \"paused\"\n * @property {VideoTrack.Dimensions} dimensions - The {@link VideoTrack}'s\n *   {@link VideoTrack.Dimensions}\n * @property {Track.Kind} kind - \"video\"\n * @property {MediaStreamTrack} mediaStreamTrack - A video MediaStreamTrack\n * @property {?MediaStreamTrack} processedTrack - The source of processed video frames.\n * It is null if no VideoProcessor has been added.\n * @property {?VideoProcessor} processor - A {@link VideoProcessor} that is currently\n *   processing video frames. It is null if video frames are not being processed.\n * @emits VideoTrack#dimensionsChanged\n * @emits VideoTrack#disabled\n * @emits VideoTrack#enabled\n * @emits VideoTrack#started\n */\nclass VideoTrack extends MediaTrack {\n  /**\n   * Construct a {@link VideoTrack}.\n   * @param {MediaTrackTransceiver} mediaTrackTransceiver\n   * @param {{log: Log}} options\n   */\n  constructor(mediaTrackTransceiver, options) {\n    super(mediaTrackTransceiver, options);\n    Object.defineProperties(this, {\n      _captureTimeoutId: {\n        value: null,\n        writable: true\n      },\n      _isCapturing: {\n        value: false,\n        writable: true\n      },\n      _inputFrame: {\n        value: null,\n        writable: true\n      },\n      _outputFrame: {\n        value: null,\n        writable: true\n      },\n      _processorEventObserver: {\n        value: null,\n        writable: true,\n      },\n      _processorOptions: {\n        value: {},\n        writable: true,\n      },\n      _unmuteHandler: {\n        value: null,\n        writable: true\n      },\n      dimensions: {\n        enumerable: true,\n        value: {\n          width: null,\n          height: null\n        }\n      },\n      processor: {\n        enumerable: true,\n        value: null,\n        writable: true\n      }\n    });\n\n    this._processorEventObserver = new (options.VideoProcessorEventObserver || VideoProcessorEventObserver)(this._log);\n\n    return this;\n  }\n\n  /**\n   * @private\n   */\n  _checkIfCanCaptureFrames(isPublishing = false) {\n    let canCaptureFrames = true;\n    let message = '';\n    const { enabled, readyState } = this.mediaStreamTrack;\n\n    if (!enabled) {\n      canCaptureFrames = false;\n      message = 'MediaStreamTrack is disabled';\n    }\n    if (readyState === 'ended') {\n      canCaptureFrames = false;\n      message = 'MediaStreamTrack is ended';\n    }\n    if (!this.processor) {\n      canCaptureFrames = false;\n      message = 'VideoProcessor not detected.';\n    }\n    if (!this._attachments.size && !isPublishing) {\n      canCaptureFrames = false;\n      message = 'VideoTrack is not publishing and there is no attached element.';\n    }\n\n    if (message) {\n      this._log.debug(message);\n    }\n    return { canCaptureFrames, message };\n  }\n\n  /**\n   * @private\n   */\n  _captureFrames() {\n    if (this._isCapturing) {\n      this._log.debug('Ignoring captureFrames call. Capture is already in progress');\n      return;\n    }\n    if (!this._checkIfCanCaptureFrames().canCaptureFrames) {\n      this._isCapturing = false;\n      this._log.debug('Cannot capture frames. Ignoring captureFrames call.');\n      return;\n    }\n    this._isCapturing = true;\n    this._processorEventObserver.emit('start');\n    this._log.debug('Start capturing frames');\n\n    let startTime = Date.now();\n    let processFramePeriodMs;\n\n    this._dummyEl.play().then(() => {\n      const captureFrame = cb => {\n        clearTimeout(this._captureTimeoutId);\n        const { frameRate = DEFAULT_FRAME_RATE } = this.mediaStreamTrack.getSettings();\n        const capturePeriodMs = Math.floor(1000 / frameRate);\n        let delay = capturePeriodMs - processFramePeriodMs;\n        if (delay < 0 || typeof processFramePeriodMs !== 'number') {\n          delay = 0;\n        }\n        this._captureTimeoutId = setTimeout(cb, delay);\n      };\n      const process = () => {\n        const checkResult = this._checkIfCanCaptureFrames();\n        if (!checkResult.canCaptureFrames) {\n          this._isCapturing = false;\n          this._processorEventObserver.emit('stop', checkResult.message);\n          this._log.debug('Cannot capture frames. Stopping capturing frames.');\n          return;\n        }\n        startTime = Date.now();\n\n        const { width = 0, height = 0 } = this.mediaStreamTrack.getSettings();\n        // Setting the canvas' dimension triggers a redraw.\n        // Only set it if it has changed.\n        if (this._outputFrame && this._outputFrame.width !== width) {\n          this._outputFrame.width = width;\n          this._outputFrame.height = height;\n        }\n        if (this._inputFrame) {\n          if (this._inputFrame.width !== width) {\n            this._inputFrame.width = width;\n            this._inputFrame.height = height;\n          }\n          this._inputFrame.getContext('2d').drawImage(this._dummyEl, 0, 0, width, height);\n        }\n\n        let result = null;\n        try {\n          const input = this._processorOptions.inputFrameBufferType === 'video' ? this._dummyEl : this._inputFrame;\n          result = this.processor.processFrame(input, this._outputFrame);\n        } catch (ex) {\n          this._log.debug('Exception detected after calling processFrame.', ex);\n        }\n        ((result instanceof Promise) ? result : Promise.resolve(result))\n          .then(() => {\n            if (this._outputFrame) {\n              if (typeof this.processedTrack.requestFrame === 'function') {\n                this.processedTrack.requestFrame();\n              }\n              this._processorEventObserver.emit('stats');\n            }\n          })\n          .finally(() => {\n            processFramePeriodMs = Date.now() - startTime;\n            captureFrame(process);\n          });\n      };\n      captureFrame(process);\n    }).catch(error => this._log.error('Video element cannot be played', { error, track: this }));\n  }\n\n  /**\n   * @private\n   */\n  _initialize() {\n    super._initialize();\n    if (this._dummyEl) {\n      this._dummyEl.onloadedmetadata = () => {\n        if (dimensionsChanged(this, this._dummyEl)) {\n          this.dimensions.width = this._dummyEl.videoWidth;\n          this.dimensions.height = this._dummyEl.videoHeight;\n        }\n      };\n      this._dummyEl.onresize = () => {\n        if (dimensionsChanged(this, this._dummyEl)) {\n          this.dimensions.width = this._dummyEl.videoWidth;\n          this.dimensions.height = this._dummyEl.videoHeight;\n          if (this.isStarted) {\n            this._log.debug('Dimensions changed:', this.dimensions);\n            this.emit(VideoTrack.DIMENSIONS_CHANGED, this);\n          }\n        }\n      };\n    }\n  }\n\n  /**\n   * @private\n   */\n  _restartProcessor() {\n    const processor = this.processor;\n    if (processor) {\n      const processorOptions = Object.assign({}, this._processorOptions);\n      this.removeProcessor(processor);\n      this.addProcessor(processor, processorOptions);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _start(dummyEl) {\n    this.dimensions.width = dummyEl.videoWidth;\n    this.dimensions.height = dummyEl.videoHeight;\n\n    this._log.debug('Dimensions:', this.dimensions);\n    this.emit(VideoTrack.DIMENSIONS_CHANGED, this);\n    return super._start.call(this, dummyEl);\n  }\n\n  /**\n   * Add a {@link VideoProcessor} to allow for custom processing of video frames belonging to a VideoTrack.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to use.\n   * @param {AddProcessorOptions} [options] - {@link AddProcessorOptions} to provide.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * Video.createLocalVideoTrack().then(function(videoTrack) {\n   *   videoTrack.addProcessor(new GrayScaleProcessor(100));\n   * });\n   */\n  addProcessor(processor, options) {\n    if (!processor || typeof processor.processFrame !== 'function') {\n      throw new Error('Received an invalid VideoProcessor from addProcessor.');\n    }\n    if (this.processor) {\n      throw new Error('A VideoProcessor has already been added.');\n    }\n    if (!this._dummyEl) {\n      throw new Error('VideoTrack has not been initialized.');\n    }\n\n    this._log.debug('Adding VideoProcessor to the VideoTrack', processor);\n\n    if (!this._unmuteHandler) {\n      this._unmuteHandler = () => {\n        this._log.debug('mediaStreamTrack unmuted');\n        // NOTE(csantos): On certain scenarios where mediaStreamTrack is coming from muted to unmuted state,\n        // the processedTrack doesn't unmutes automatically although enabled is already set to true.\n        // This is a terminal state for the processedTrack and should be restarted. (VIDEO-4176)\n        if (this.processedTrack.muted) {\n          this._log.debug('mediaStreamTrack is unmuted but processedTrack is muted. Restarting processor.');\n          this._restartProcessor();\n        }\n      };\n      this.mediaStreamTrack.addEventListener('unmute', this._unmuteHandler);\n    }\n\n    this._processorOptions = options || {};\n    let { inputFrameBufferType, outputFrameBufferContextType } = this._processorOptions;\n    if (typeof OffscreenCanvas === 'undefined' && inputFrameBufferType === 'offscreencanvas') {\n      throw new Error('OffscreenCanvas is not supported by this browser.');\n    }\n    if (inputFrameBufferType && inputFrameBufferType !== 'video' && inputFrameBufferType !== 'canvas' && inputFrameBufferType !== 'offscreencanvas') {\n      throw new Error(`Invalid inputFrameBufferType of ${inputFrameBufferType}`);\n    }\n    if (!inputFrameBufferType) {\n      inputFrameBufferType = typeof OffscreenCanvas === 'undefined' ? 'canvas' : 'offscreencanvas';\n    }\n\n    const { width = 0, height = 0, frameRate = DEFAULT_FRAME_RATE } = this.mediaStreamTrack.getSettings();\n    if (inputFrameBufferType === 'offscreencanvas') {\n      this._inputFrame = new OffscreenCanvas(width, height);\n    }\n    if (inputFrameBufferType === 'canvas') {\n      this._inputFrame = document.createElement('canvas');\n    }\n    if (this._inputFrame) {\n      this._inputFrame.width = width;\n      this._inputFrame.height = height;\n    }\n\n    this._outputFrame = document.createElement('canvas');\n    this._outputFrame.width = width;\n    this._outputFrame.height = height;\n\n    // NOTE(csantos): Initialize the rendering context for future renders. This also ensures\n    // that the correct type is used and on Firefox, it throws an exception if you try to capture\n    // frames prior calling getContext https://bugzilla.mozilla.org/show_bug.cgi?id=1572422\n    outputFrameBufferContextType = outputFrameBufferContextType || '2d';\n    const ctx = this._outputFrame.getContext(outputFrameBufferContextType);\n    if (!ctx) {\n      throw new Error(`Cannot get outputFrameBufferContextType: ${outputFrameBufferContextType}.`);\n    }\n\n    // NOTE(csantos): Zero FPS means we can control when to render the next frame by calling requestFrame.\n    // Some browsers such as Firefox doesn't support requestFrame so we will use default, which is an undefined value.\n    // This means, the browser will use the highest FPS available.\n    const targetFps = typeof CanvasCaptureMediaStreamTrack !== 'undefined' && CanvasCaptureMediaStreamTrack.prototype &&\n      // eslint-disable-next-line\n      typeof CanvasCaptureMediaStreamTrack.prototype.requestFrame === 'function' ? 0 : undefined;\n\n    this.processedTrack = this._outputFrame.captureStream(targetFps).getTracks()[0];\n    this.processedTrack.enabled = this.mediaStreamTrack.enabled;\n    this.processor = processor;\n\n    this._processorEventObserver.emit('add', {\n      processor,\n      captureHeight: height,\n      captureWidth: width,\n      inputFrameRate: frameRate,\n      isRemoteVideoTrack: this.toString().includes('RemoteVideoTrack'),\n      inputFrameBufferType,\n      outputFrameBufferContextType\n    });\n    this._updateElementsMediaStreamTrack();\n    this._captureFrames();\n    return this;\n  }\n\n  /**\n   * Create an HTMLVideoElement and attach the {@link VideoTrack} to it.\n   *\n   * The HTMLVideoElement's <code>srcObject</code> will be set to a new\n   * MediaStream containing the {@link VideoTrack}'s MediaStreamTrack.\n   *\n   * @returns {HTMLVideoElement} videoElement\n   * @example\n   * const Video = require('twilio-video');\n   *\n   * Video.createLocalVideoTrack().then(function(videoTrack) {\n   *   const videoElement = videoTrack.attach();\n   *   document.body.appendChild(videoElement);\n   * });\n  *//**\n   * Attach the {@link VideoTrack} to an existing HTMLMediaElement. The\n   * HTMLMediaElement could be an HTMLAudioElement or an HTMLVideoElement.\n   *\n   * If the HTMLMediaElement's <code>srcObject</code> is not set to a MediaStream,\n   * this method sets it to a new MediaStream containing the {@link VideoTrack}'s\n   * MediaStreamTrack; otherwise, it adds the {@link MediaTrack}'s\n   * MediaStreamTrack to the existing MediaStream. Finally, if there are any other\n   * MediaStreamTracks of the same kind on the MediaStream, this method removes\n   * them.\n   *\n   * @param {HTMLMediaElement} mediaElement - The HTMLMediaElement to attach to\n   * @returns {HTMLMediaElement} mediaElement\n   * @example\n   * const Video = require('twilio-video');\n   *\n   * const videoElement = document.createElement('video');\n   * document.body.appendChild(videoElement);\n   *\n   * Video.createLocalVideoTrack().then(function(videoTrack) {\n   *   videoTrack.attach(videoElement);\n   * });\n  *//**\n   * Attach the {@link VideoTrack} to an HTMLMediaElement selected by\n   * <code>document.querySelector</code>. The HTMLMediaElement could be an\n   * HTMLAudioElement or an HTMLVideoElement.\n   *\n   * If the HTMLMediaElement's <code>srcObject</code> is not set to a MediaStream,\n   * this method sets it to a new MediaStream containing the {@link VideoTrack}'s\n   * MediaStreamTrack; otherwise, it adds the {@link VideoTrack}'s\n   * MediaStreamTrack to the existing MediaStream. Finally, if there are any other\n   * MediaStreamTracks of the same kind on the MediaStream, this method removes\n   * them.\n   *\n   * @param {string} selector - A query selector for the HTMLMediaElement to\n   *   attach to\n   * @returns {HTMLMediaElement} mediaElement\n   * @example\n   * const Video = require('twilio-video');\n   *\n   * const videoElement = document.createElement('video');\n   * videoElement.id = 'my-video-element';\n   * document.body.appendChild(videoElement);\n   *\n   * Video.createLocalVideoTrack().then(function(track) {\n   *   track.attach('#my-video-element');\n   * });\n   */\n  attach() {\n    const result = super.attach.apply(this, arguments);\n    if (this.processor) {\n      this._captureFrames();\n    }\n    return result;\n  }\n\n  /**\n   * Detach the {@link VideoTrack} from all previously attached HTMLMediaElements.\n   * @returns {Array<HTMLMediaElement>} mediaElements\n   * @example\n   * const mediaElements = videoTrack.detach();\n   * mediaElements.forEach(mediaElement => mediaElement.remove());\n  *//**\n   * Detach the {@link VideoTrack} from a previously attached HTMLMediaElement.\n   * @param {HTMLMediaElement} mediaElement - One of the HTMLMediaElements to\n   *   which the {@link VideoTrack} is attached\n   * @returns {HTMLMediaElement} mediaElement\n   * @example\n   * const videoElement = document.getElementById('my-video-element');\n   * videoTrack.detach(videoElement).remove();\n  *//**\n   * Detach the {@link VideoTrack} from a previously attached HTMLMediaElement\n   *   specified by <code>document.querySelector</code>.\n   * @param {string} selector - The query selector of HTMLMediaElement to which\n   *    the {@link VideoTrack} is attached\n   * @returns {HTMLMediaElement} mediaElement\n   * @example\n   * videoTrack.detach('#my-video-element').remove();\n   */\n  detach() {\n    return super.detach.apply(this, arguments);\n  }\n\n  /**\n   * Remove the previously added {@link VideoProcessor} using `addProcessor` API.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to remove.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * Video.createLocalVideoTrack().then(function(videoTrack) {\n   *   const grayScaleProcessor = new GrayScaleProcessor(100);\n   *   videoTrack.addProcessor(grayScaleProcessor);\n   *   document.getElementById('remove-button').onclick = () => videoTrack.removeProcessor(grayScaleProcessor);\n   * });\n   */\n  removeProcessor(processor) {\n    if (!processor) {\n      throw new Error('Received an invalid VideoProcessor from removeProcessor.');\n    }\n    if (!this.processor) {\n      throw new Error('No existing VideoProcessor detected.');\n    }\n    if (processor !== this.processor) {\n      throw new Error('The provided VideoProcessor is different than the existing one.');\n    }\n\n    this._processorEventObserver.emit('remove');\n    this._log.debug('Removing VideoProcessor from the VideoTrack', processor);\n    clearTimeout(this._captureTimeoutId);\n    this.mediaStreamTrack.removeEventListener('unmute', this._unmuteHandler);\n    this._processorOptions = {};\n    this._unmuteHandler = null;\n    this._isCapturing = false;\n\n    this.processor = null;\n    this.processedTrack = null;\n    this._inputFrame = null;\n    this._outputFrame = null;\n\n    this._updateElementsMediaStreamTrack();\n    return this;\n  }\n}\n\nVideoTrack.DIMENSIONS_CHANGED = 'dimensionsChanged';\n\nfunction dimensionsChanged(track, elem) {\n  return track.dimensions.width !== elem.videoWidth\n    || track.dimensions.height !== elem.videoHeight;\n}\n\n/**\n * A {@link VideoTrack}'s width and height.\n * @typedef {object} VideoTrack.Dimensions\n * @property {?number} width - The {@link VideoTrack}'s width or null if the\n *   {@link VideoTrack} has not yet started\n * @property {?number} height - The {@link VideoTrack}'s height or null if the\n *   {@link VideoTrack} has not yet started\n */\n\n/**\n * A {@link VideoProcessor}, when added via {@link VideoTrack#addProcessor},\n * is used to process incoming video frames before\n * sending to the encoder or renderer.\n * @typedef {object} VideoProcessor\n * @property {function} processFrame - A callback to receive input and output frame buffers for processing.\n * The input frame buffer contains the original video frame which can be used for additional processing\n * such as applying filters to it. The output frame buffer is used to receive the processed video frame\n * before sending to the encoder or renderer.\n *\n * Any exception raised (either synchronously or asynchronously) in `processFrame` will result in the frame being dropped.\n * This callback has the following signature:<br/><br/>\n * <code>processFrame(</code><br/>\n * &nbsp;&nbsp;<code>inputFrameBuffer: OffscreenCanvas | HTMLCanvasElement | HTMLVideoElement,</code><br/>\n * &nbsp;&nbsp;<code>outputFrameBuffer: HTMLCanvasElement</code><br/>\n * <code>): Promise&lt;void&gt; | void;</code>\n *\n * @example\n * class GrayScaleProcessor {\n *   constructor(percentage) {\n *     this.percentage = percentage;\n *   }\n *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n *     const context = outputFrameBuffer.getContext('2d');\n *     context.filter = `grayscale(${this.percentage}%)`;\n *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n *   }\n * }\n */\n\n/**\n * Possible options to provide to {@link LocalVideoTrack#addProcessor} and {@link RemoteVideoTrack#addProcessor}.\n * @typedef {object} AddProcessorOptions\n * @property {string} [inputFrameBufferType=\"offscreencanvas\"] - This option allows you to specify what kind of input you want to receive in your\n * Video Processor. The default is `offscreencanvas` and will fallback to a regular `canvas` if the browser does not support it.\n * Possible values include the following.\n * <br/>\n * <br/>\n * `offscreencanvas` - Your Video Processor will receive an [OffscreenCanvas](https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas)\n * which is good for canvas-related processing that can be rendered off screen.\n * <br/>\n * <br/>\n * `canvas` - Your Video Processor will receive an [HTMLCanvasElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement).\n * This is recommended on browsers that doesn't support `OffscreenCanvas`, or if you need to render the frame on the screen.\n * <br/>\n * <br/>\n * `video` - Your Video Processor will receive an [HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement).\n * Use this option if you are processing the frame using WebGL or if you only need to [draw](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage)\n * the frame directly to your output canvas.\n * @property {string} [outputFrameBufferContextType=\"2d\"] - The SDK needs the [context type](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext)\n * that your Video Processor uses in order to properly generate the processed track. For example, if your Video Processor uses WebGL2 (`canvas.getContext('webgl2')`),\n * you should set `outputFrameBufferContextType` to `webgl2`. Or if you're using Canvas 2D processing (`canvas.getContext('2d')`),\n * you should set `outputFrameBufferContextType` to `2d`.\n */\n\n/**\n * The {@link VideoTrack}'s dimensions changed.\n * @param {VideoTrack} track - The {@link VideoTrack} whose dimensions changed\n * @event VideoTrack#dimensionsChanged\n */\n\n/**\n * The {@link VideoTrack} was disabled, i.e. \"paused\".\n * @param {VideoTrack} track - The {@link VideoTrack} that was disabled\n * @event VideoTrack#disabled\n */\n\n/**\n * The {@link VideoTrack} was enabled, i.e. \"unpaused\".\n * @param {VideoTrack} track - The {@link VideoTrack} that was enabled\n * @event VideoTrack#enabled\n */\n\n/**\n * The {@link VideoTrack} started. This means there is enough video data to\n * begin playback.\n * @param {VideoTrack} track - The {@link VideoTrack} that started\n * @event VideoTrack#started\n */\n\nmodule.exports = VideoTrack;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}